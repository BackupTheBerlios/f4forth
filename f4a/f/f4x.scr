=================== < F4 hi-level extensions > =================provided an installation to the standard F4 library location as by <make install> the entire screen-file as well as any single  word appearing in the rsp. index (top) line can be compiled:                                                                        { " /usr/local/lib/f4a/f4x.scr" USING 6 LOAD }                                                                              or,                                                             x    { LLOAD forthword }                                                                                                        which compiles the rsp. 'forthword' with the least possible     overhead of probably required supporting words. if F4 compiled  w.o. the "lload" extension, for instance, begin with                { 0 " LLOAD" L-LOAD DROP ' LLOAD NFA FENCE ! }              with 'lload' being safe against 'forget', 'empty' and, 'cold'.  NOTE: some words depend on standard flag value, true = 1.       ( ================ < F4 hi-level extensions > ================ )                    6 b/scr * 1+ blk ! 0 in !                                                                                                              <f4x.scr>                                    Copyright (C) 2003 berlin by h.-peter recktenwald                experimental software, not tested, no warranty!                                                                                         f4x -at- lxhp . in-berlin . de                                                                                                       Sa 2002-09-14 14:31                                             Mo 2003-08-18 18:32                                                                                                                                                                                                                                                                                                                                                       ( ================ < F4 hi-level extensions > ================ )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( ================ < F4 hi-level extensions > ================ )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1234567890                                            1234567890(  ERROR MESSAGES  ) -->                                        EMPTY STACK                                                     DICTIONARY FULL                                                 HAS INCORRECT ADDRESS MODE                                      ISN'T UNIQUE                                                                                                                    DISC RANGE ?                                                    FULL STACK                                                      DISC ERROR !                                                                                                                                                                                                                                                                                                                                                                                                                                                    F4                                                   SEP 2, 2002(  ERROR MESSAGES  ) -->                                        COMPILATION ONLY, USE IN DEFINITION                             EXECUTION ONLY                                                  CONDITIONALS NOT PAIRED                                         DEFINITION NOT FINISHED                                         IN PROTECTED DICTIONARY                                         USE ONLY WHEN LOADING                                           OFF CURRENT EDITING SCREEN                                      DECLARE VOCABULARY                                                                                                                                                                                                                                                                                                                                                                                                                                              F4                                                   SEP 2, 2002( == : F4 ) forth definitions decimal ( == : load-screen : == ) lload? !hlp                                                         warning @ 0= 0= abs warning !  ( screenfile text messages )     0. lword 2!                    ( prevent "lword" selection)     10 load            1 warning ! ( load -almost- everything )     ;S                             ( done, return to {quit}   )                                                                  ( test, display blk & stack before advancing to next screen: )  : (-->) blk ? lword print .s [-->] ; immediate ' (-->) is -->                                                                  \ show/sto changes of dstack depth while loading                0. 2constant d?     \ e.g: { d? 2@ . 2@ . }... display blocks ) : ?d depth d? drop = -exit                                        scr ? blk ? .s depth d? sdrop here swap , to d? blk@ , ;      : [>] ?d [-->] ; ' [>] is -->                                                                                                   ( : thru                                         == -test- == )                                found? end-thru? if-true -->                                lword @ if-true -l ?? if-true ;s     hidden definitions                                              : [et] forth lword @ -exit                                        scr @ end-thru < if rdrop exit endif [_] --> ;                                                                                root definitions hidden                                         ' [et] defer end-thru?                                                                                                  -->                                                                                                                                                                                                                                                                                                                                                                                                      found? thru if-true --> ( : thru : ?thru        == -test- == )                                                                 \ ?thru to testing "forget", instead of "found?"                hidden definitions                                              : ?thru      forth     ( check whether 'thru' already defined )   if 2drop rdrop endif ( exit this screen if 'thru' found     )   " ?thru" sforget ;   ( in either case, forget testing word  ) -find thru ?thru                                                                                                                forth definitions root definitions forth                        : thru                  ( n1 n2 -- )    ( load scr n1 till n2 )   1+ 2dup = if 2drop exit endif swap    ( n2 inclusive        )   do i load dr? bchan ch-rnum 0= -leave loop ; ( leave at eof )                                                                                                                         -->                                                                     ( test whether screen-file loading may pass parameters - ok   )                                                                 forth definitions               blk @ b/scr / 1+                                                                                                                                        ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( : ??                              == f4 == short "where" == )                                     if-found ?? 3 +continue                                                                                              found? end-thru? if-true end-thru?                                lword @ if-true -l ?? if-true ;s                                                             -->                                                                                                                                                                                                                                                                     \                                                               \ ??            ( col blk -- )                                  \   display source of latest error by scr#, block and column    \   short aequivalent to editor voc. "where"                                                                                                                                                    ( : 2nd-voc : >vs : vs> == set/define initial search order == )    lword @ 0= -l 2nd-voc -l >vs or -l vs> or 0= or if-true -->  -wl 2nd-voc if-true   2nd-voc linux hidden  2nd-voc forth linux -wl 2nd-voc if-true   2nd-voc editor forth  2nd-voc root forth  -wl 2nd-voc if-true 8 +continue                                 \ => search order: forth hidden linux editor assembler          : >vs ' hidden is forth ' linux is hidden                         ' editor is linux ' assembler is editor ;                                                                                     \ => search order: forth hidden linux elf editor vt assembler   : vs> >vs if-found elf ' elf is linux ' editor is elf             if-found vt ' vt is editor ' assembler is vt                    ' linux is root ' forth is assembler ;                                 found? end-thru? if-true lword @ 0= if-true end-thru?           -wl 2nd-voc -wl >vs or -wl vs> or if-true          ;s                                                             -->  ( : marker ) forth definitions decimal ( == f4 ====== util == )                                 if-found marker 8 +continue     : marker blk 2@ 2>r name hidden sfind ( forget re-def'd marker )  if drop dup@ [ here rot rot here ] literal -                    if drop else cfa execute endif endif 2r> blk 2!                 <builds current @ v> , context @ v> , base@ ,                   latest count $1f and here over 2+ allot                         2dup c! 2dup + 0 swap c! 1+ swap cmove                          does> [ here swap 4+ ! ]             ( patch for 'domarker' )   @+ >v current ! @+ >v context ! @+ base ! sforget ;                                                        -l f4 if-true -->                                                                  \ marker        ( markername, -- )              forth           \    executing a 'marker' or re-defining, restores current and  \    context vocabularies and @base figure, then forgets itself \    if re-defining, an equally named marker set up, afterwards ( == : safe! : kdef? == ) root definitions forth decimal                                            if-found safe! 2 +continue  : safe!         ( -- )  \ protect the entire dictionary           last @ fence ! ;                                                                                                                                                  if-found kdef? 4 +continue  : x ; immediate latest c@ -32 and fld ! forget x                : kdef? -find 0= if 0 exit endif            ( not found )         [ fld @ ] literal < 0= if 0= exit endif   ( immediate )         ' task 1+ < ;                             ( kernel word )                                                -l f4 if-true -->                                                                    ( ----------------------------------------------------------- ) ( use "-->"     to continue at next screen                    ) ( or, ";S"      to terminate "load"ing before end of screen   ) ( ----------------------------------------------------------- ) ( ========= : do-opt : no-opt : opt? : cmc0  ) root definitions             -l do-opt 0= found? do-opt or if-true 1 +continue   : do-opt -1. cmc ! cmo ! ;  immediate                                       -l no-opt 0= found? no-opt or if-true 1 +continue   : no-opt cmc off cmo off ;  immediate                                       -l cmc0   0= found? cmc0   or if-true 1 +continue   : cmc0 -1 cmc ! ;                                                           -l opt?   0= found? opt?   or if-true 1 +continue   : opt? cmc @ cmo @ and ;                                                                                     -l f4 if-true -->  \ no-opt        ( -- )          (i)     root                    \ do-opt        ( -- )          (i)     root                    \ cmc0          ( -- )                  root                    \   dis/enable conditional branches & end-recursion modifying   \ opt?          ( -- flg )              root                    \   true flag if 'optimizing' enabled                           --> ( initial 'l-load'ing, before 'stg' or aequivalents def'd )                                                                 \ example to "l-load" w.o. the "stg" defn:                      \ for instance, to 'l-load' the word 'if-found' from 'f4c.scr':     " if-found" count pad 100 + 2dup c! 1+ swap cmove               " /f4c.scr" swap over                                           libdir count swap libdir swap - + pad +                         2dup c! 1+ swap cmove docdir pad over c@ 1+ cmove               pad c@ + pad c! pad dup 100 + l-load                                                                                        \ or, by auxilary, temporary word definition:                   : tmp libdir count pad 2dup c! 1+ swap cmove                      " /f4c.scr" count pad count + swap >rr cmove                    pad r> over c@ + over c! " if-found" ;                                                      tmp forget tmp l-load                                                                             ( == f4 ==================================== : prim? : palias ) root definitions forth                                                                         -l prim? 0= if-true 1 +continue  if-nfound prim? : prim? cfa dup@ over- 0= swap ' task < or ;                                                                                                  -l palias 0= if-true 3 +continue                         lload prim? if-found palias 2 +continue  : palias dup prim? 0= if nfa id. 20 error endif                   create unsmudge cfa @ latest pfa cfa ! ;                                                                                                                                   -l f4 if-true -->                                                                  \ prim?     ( pfa -- flg )                                      \   tf if pfa belongs to a primitive word                       \ palias    ( ccc, pfa -- | abort-20 )                          \   define synonym of a primitive (only!)                       ( == F4 == : vt-chr ================= : <lf> : <nl> : \e : bs )                                       forth definitions decimal -l <nl> -l vt-chr or 0= if-true 1 +continue                     if-nfound <nl> 10 constant    <nl>  ( new-line code           )                                                                 -l <lf> -l vt-chr or 0= if-true 1 +continue                     if-nfound <lf> 10 constant    <lf>  ( line-feed code          )                                                                 -l  \e  -l vt-chr or 0= if-true 1 +continue                     if-nfound \e   27 constant    \e    ( ascii <esc>ape code     )                                                                 -l  bs  -l vt-chr or 0= if-true 1 +continue                     if-nfound bs   : bs s" \b" here e\stg type ;  ( backspace     )                                                                                                      -l f4       if-true -->                                                                    ( == f4 cons == : palign : page-size : page-mask : page-align ) linux definitions forth decimal                                                             if-found page-align 3 +continue     if-nfound page-size  4K              constant page-size         if-nfound page-mask  page-size minus constant page-mask         if-nfound page-align page-size 1-    constant page-align                                                                                                        if-found palign 3 +continue     if-nfound palign- : palign- page-mask and ;     \ n' \< n       if-nfound palign+ : palign+ page-size align ;   \ n' >/ n       if-nfound palign  : palign  s->d if palign- exit endif palign+ ;                                                                                                             -l f4 if-true -->                                                                  \ palign    ( n -- n' )                                         \   +/- page-size align the figure of n                         ( == f4 cons ============== : cdt-size : stat-size : path-max ) forth definitions decimal                                                                        if-found cdt-size 2 +continue                             -wl cdt-size 0= if-true 1 +continue  1 cdt 0 cdt - constant cdt-size     ( channel defn table, ea. )                                                                 linux definitions decimal                                                                       if-found stat-size 3 +continue                            -wl stat-size 0= if-true 2 +continue  pad 200 -1 fill pad 0 fstat 200 -1 rskip sdrop minus 201 +                    constant stat-size    ( 'fstat' system call     )                                                                 if-nfound path-max 4K               constant    path-max                                                     -l f4 if-true -->                                                                                                                                  ( == uvari 'constants' == )         forth definitions decimal                                                                   if-nfound dpl@     dpl (up) -     ucons dpl@     \ : dpl@       if-nfound csp@     csp (up) -     ucons csp@     \ : csp@       if-nfound hld@     hld (up) -     ucons hld@     \ : hld@       if-nfound out@     out (up) -     ucons out@     \ : out@       if-nfound fld@     fld (up) -     ucons fld@     \ : fld@       if-nfound tib@     tib (up) -     ucons tib@     \ : tib@       if-nfound in@      in  (up) -     ucons in@      \ : in@        if-nfound context@ context (up) - ucons context@ \ : context@   if-nfound tib-size (tb) 4+ (up) - ucons tib-size \ : tib-size   if-nfound col      (col) (up) -   ucons col      \ : col        if-nfound row      (row) (up) -   ucons row      \ : row                                                                                                                     -l f4 if-true -->                                                                  ( =========================================================== ) forth definitions decimal                     -l f4 if-true -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( == ucons ================== : @max-xy : max-x : max-y : mxy ) forth definitions                                                                               if-found max-x 1 +continue      -wl mxy -wl max-x or if-true : max-x max-xy drop ;                                              if-found max-y 1 +continue      -wl mxy -wl max-y or if-true : max-y max-xy sdrop ;                                                                             -wl mxy -wl @max-xy or found? !max-xy and found? @max-xy 0= and if-true     create @max-xy -4 allot ' !max-xy cfa @ 4- , smudge                                                                                                            -l f4 if-true -->    \ max-x     ( -- x )                                            \ max-y     ( -- y )                                            \   fetch window width(x) or window height(y) chars count, rsp. \ @max-xy   ( -- x y )                                          \   forcedly fetch window sizes independently of stored figures ( == memory ===================== : +mem : +tib : +stk : +blk ) hidden definitions decimal                    if-found +mm -->                                               -l f4 if-true -->                                                                  : +mm >r -4096 and r> 2>rr @+ -4096 and      ( R: -- sz uvari )   dup rot @ dup 4 roll + mremap dup -4095 u< ( .. -- adr f    )   dup if                                                           2r 4+ +!                                  ( inc. size uvari)    over 2r> sdrop ! ;s                       ( new base addr  )   endif 2rdrop ;                                                                                                           -->                                                                                                                                                                                                  \ +mm           ( size-incement uvari -- mem-addr flag ) hidden \   aux. defn to memory resizeing. on failure, flg:=0, else 1   ( == memory ===================== : +mem : +tib : +stk : +blk ) forth definitions decimal                   -l f4 if-true -->                                                                   if-nfound +tib : +tib (tb) +mm (tb) @ tib ! ;                                                              -wl +tib if-true ;s                                                                                                       if-found +blk 2 +continue  : +blk (ib) +mm dup 0= -exit (ib) @+ dup is first                 swap @ dup first dup +buf drop swap - mod - + is limit ;                                                 -wl +blk if-true ;s                                                             -->                                                                  \ +tib          ( sz -- a er )                  forth           \   resize terminal input buffer                                \ +blk          ( sz -- a er )                  forth           \   resize block-file buffer spae                               ( == memory ======================================= +mem +stk ) forth definitions decimal                    -l f4 if-true -->                                                                                                       if-found +stk 2 +continue  : +stk s0 @ (pb) @ - swap (pb) +mm                                dup 0= if rot drop exit endif >r dup rot + s0 ! r> ;                                                                                                               if-found +mem 1 +continue  : +mem dup allot minus allot (db) @ -sp 0= ;                                                                                                                                                                                                                    \ +mem          ( sz -- a er )                  forth           \   resize dictionary memory                                    \ +stk          ( sz -- a er )                  forth           \   resize data-stack memory                                    ( == memory ========================================== : mem? ) hidden definitions decimal                   -l f4 if-true -->                                      if-found mem? 10 +continue                                       lload u.r lload page-size  : [m?] cr print ": emit tab    [ page-size minus ]                @+ literal and dup 12 u.r swap @ dup 12 u.r + 12 u.r ;        : [rs] cr ." rs:" tab r0 @ dup 12 u.r                             rp@ sover - 12 u.r 12 u.r ;                                                                                                   forth definitions decimal                                       : mem?          ( -- )                   ( display memory map )   (tb) " tib" [m?] (ib) " blk" [m?]  u0 " usr" [m?]               (db) " dic" [m?] (vb) " var" [m?] (pb) " ds" [m?] [rs] cr ;                                                                                                                                                                                                   ( == f4 = continue loading at @scr + disp  : cwd@ : pwd : ==> )                                                                                                      -l f4 if-true 2 +continue                                        if-found ==> 1 +continue  : ==> blk@ b/scr / + dup scr ! b/scr * blk ! 0in! ; immediate                                               -wl ==> if-true ;s                                                                                                       -l f4 if-true 4 +continue                                        if-found pwd 3 +continue  : cwd@      ( p u -- p1 u1 ) ( fetch current working directory)   swap sp@ sys getcwd sdrop rot drop ;                          : pwd 4K |loc l0 4K cwd@ type -4K |loc ;    ( display cwd     )                                                                                                             -wl cwd@ if-true ;s                                                            -->                                                                  ( == f4 =================================== : pad-size : pad2 ) forth definitions decimal                                                                                                        if-found pad-size 2 +continue                                   lword @ if-true -l pad-size -l pad2 or 0= if-true 1 +continue  pad here -    constant pad-size     ( disp from 'here' to pad )                                                                  found? pad2 lword @ 0> -l pad2 0= and or if-true 3 +continue    lload pad-size lload path-max                                  : pad2 [ path-max 2* pad-size 4* max ]                            literal -allot pad pad-size + ;                                                                            -l f4 if-true -->  \ pad-size      ( -- n )                                        \   disp from 'here' to pad                                     \ pad2          ( -- a )                                        \   buffer at pad + pad-size, at least pad-size 4* allocated mem( == f4 == compat ====================== : cells : chars : 3+ ) forth definitions decimal                                                                           if-found cells 2 +continue                                -wl cells 0= if-true 1 +continue  : cells [ here 0  , here - dup allot abs ] literal * ;                                                                                                        -wl chars 0= if-true 2 +continue                                      if-found chars 1 +continue  : chars [ here 0 c, here - dup allot abs ] literal * ;                                                                          -l 3+ if-true if-nfound 3+ 3 cons+ 3+                                                                                                                                        -l f4 if-true -->                                                                                                                                                                                                  ( == f4 == compat ==================== : imed  : #tib : imed? ) forth definitions decimal                                                                                                       -l #tib if-true if-nfound #tib : #tib tib @ zcount sdrop ;                                                                                          -l imed -l imed? or 0= if-true 2 +continue  if-nfound imed 0 constant imed                                            latest c@ immediate latest c@ immediate xor to imed                                                                                                  -l imed? 0= if-true 1 +continue  if-nfound imed? : imed? nfa c@ imed and ; ( pfa -- imed-flg|0 )                                                                                                              -l f4 if-true -->                                                                                                                                                                                                  ( == f4 == compat =============================== : -compile )                                                                                             -wl -compile 0= if-true 3 +continue                                   if-found -compile 2 +continue  : -c cfa state@ if , 0 cmc ! exit endif execute ;               : -compile [_] ' compile -c 0 cmc ! ; immediate    ( ccc, -- )                                                                                                                                                                              -l f4 if-true -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( F4 = : n^ : dn^ : qn^ ===================================== )                    -wl qn^ -wl dn^ -wl n^ or or 0= if-true -->                                  -wl n^ 0= if-true 3 +continue   : n^ >r 1 swap      ( n1 -- n2 ) ( n2 := n1^n2 )                  begin r 1and if swap over * swap endif                          s->d d^2 or or r> 2/ >rr 0= or until drop rdrop ;                                            -wl dn^ 0= if-true 3 +continue   : dn^ 2>r 1. 2swap      ( d1 d2 -- d3 )                           begin 2r drop 1and if 2sover d* 2swap endif                     d^2 or 2r> d2/ 2>rr d0= or until 2drop 2rdrop ;                                              -wl qn^ 0= if-true 3 +continue   : qn^ >r 1. 0. 4swap    ( q1 n2 -- q3 )                           begin r 1and if 4sover uq* 4drop 4swap endif                    4dup uq* q0= 0= r> 2/ >rr 0= or until 4drop rdrop ;                                                                       ;s  \ exp.fn in kernel: u^,mq^,umq^,uq^.-1^,2^,^2,u^2,d^2,uq^2      ( == F4 ===================================================== )                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( == F6 ======================= : to-chan : to-work : is-chan ) forth definitions                 lload cdt-size                                                  if-found to-chan 2 +continue  : to-chan   ( ch1 ch2 -- )                                        dup close over close 2drop cdt swap cdt swap cdt-size cmove ; if-nfound to-work : to-work work chan to-chan ;                 if-nfound is-chan : is-chan work chan swap to-chan ;                                                                             -wl to-chan -wl to-work or -wl is-chan or if-true ;s                                                                      -->  \ to-chan       ( ch1 ch2 -- )                                  \   copy channel c1 to channel c2 definition table              \ to-work       ( ch -- )                                       \   close rel {work}, copy chhannel ch description to {work} chn\ is-chan       ( ch -- )                                       \   close channel ch, copy rel {work} description to channel ch ( == F6 =========================================== : 'xecute )                                           1 -wl 'xecute and 0=                                             if-true 1 +continue  if-nfound 'xecute   : 'xecute cfa execute ;                                                                                                                             -wl 'xecute if-true ;s                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( == headerless defn ==: h; : h, : h] : x; ) forth definitions    lword @ 0= -l h] -l h, or -l h; or 0= or if-true 7 +continue                                         lload? cmc0                                                     if-found h] 1 +continue  : h] ?exec here !csp [ ' task cfa @ ] literal , ] ; immediate   if-nfound h,  : h, ?comp -4 csp +! , ;              immediate   if-nfound h;  : h; ?comp ?csp cmc0 [_] exit [_] [ ; immediate   if-nfound x;  : x; [_] h; >rr execute r> dp ! ;     immediate                                                                   lword @ 0=/= -l h] -l h, or -l h; or -l x; or and 0= if-true -->                                                                \ h]    ( -- ca )                                               \   def: H] ..words.. H;     ( -- ca )                          \   use: : name .. H, ..     ( .x. ca -- .x. )                  \   hi-level header-less words, xec with {execute}              \   use {x;} for immediate execution and removal of cpl'd code  ( == f4 == Lau's case by ======== : sel : on : endon : endsel ) forth definitions  found? sel -l sel 0= or if-true 7 +continue                                         lload? csp@ lload? cmc0  : sel ?comp csp @ !csp "sel cmc0 ;          immediate           : on "sel ?pairs [_] if "on cmc0 ;          immediate           : endon "on ?pairs [_] else "sel cmc0 ;     immediate           : endsel "sel ?pairs                                              enter begin [_] endif entry sp@ csp @ = until                   csp ! cmc0 ; immediate                                                                                    -wl sel if-true ;s                                                             -->  \ sel       ( n -- ... )                                        \   executes words between {on} and corresponding {endon} if a  \   non-zero flag passed to {on}, followed by jump past {endsel}\   If none of the {on}s get done, the bit before {endsel} is   \   executed. These constructs can be nested.                   ( == F4 == : elf : <f> : vdef ) root definitions                if-nfound <f>   : <f> [_] forth definitions ;      immediate <f>if-nfound elf   linux definitions vocabulary elf   immediate <f>if-nfound vt                      vocabulary vt    immediate    if-nfound float                   vocabulary float immediate                                                                     found? complex if-true 8 +continue                             2nd-voc forth     editor  ( circular chain through all vocs;  ) 2nd-voc editor    vt      ( don't change forth->editor because) 2nd-voc vt        linux   ( of ambiguous words as R, I, etc!  ) 2nd-voc linux     elf     ( link new vocs:                    ) 2nd-voc elf       float   (     ' parent v2>pfa is new        ) 2nd-voc float     hidden  (     ' new is parent               ) 2nd-voc hidden    assembler                                     2nd-voc assembler forth                                          -wl vdef -l elf or -l <f> or 0= if-true -->                    ( == f4 == Lau's : case ======== Eaker's variant by : endcase ) forth definitions                      -wl endcase if-true -->                                                       lload sel           if-found case ' case @ ' sel cfa = if-true 5 +continue : case [_] sel ;                      immediate                 : of [_] over [_] =                                               [_] on [_] drop cmc0 ;              immediate                 : endof [_] endon ;                   immediate                 : endcase [_] drop [_] endsel ;       immediate                                             -wl case found? sel and if-true ;s                                                             -->                                                                  \ case          ( n -- .xx. )                                   \   Lau's 'case' construct, based on 'sel' &c                   \   { case ( n n1 ) of .(true part). endof .(default). endcase }\   re {case:} which, mostly would compile more efficient code. ( == eaker's case == by LLOAD endcase, only ======= : endcase ) forth definitions                        lword @ 0= if-true -->             found? endcase -l endcase 0= or if-true 7 +continue                                        lload? csp@ lload? cmc0  : case ?comp csp @ !csp "case cmc0 ;                immediate   : of "case ?pairs [_] =if "of cmc0 ;                immediate   : endof "of ?pairs [_] else "case cmc0 ;            immediate   : endcase                                                         "case ?pairs compile drop                                       enter begin [_] endif entry sp@ csp @ = until cmc0 ; immediate                                        -wl endcase if-true ;s                                                             -->  \ endcase       ( -- )                                          \   use: n CASE ... OF ... ENDOF ... ENDCASE   ( not tested! )  \   unefficient code, simplifies writing of multiply nested 'if'\   re positional executing/compiling construct by "lload case:"( == f4 == util ================= : seed : random : randomize )                                    if-found random 8 +continue  -wl random -wl seed or -wl randomize or 0= if-true 7 +continue  0 constant seed                                                 : randomize     ( -- )                                            " /dev/urandom" r/o new-chan open                               >r sp@ 4+ 4 r -1 fread r> close 2drop to seed ;               : random        ( n1 -- n2 )                                      enter begin randomize entry seed -dup until                     $7549d83b m* over to seed xor u* sdrop ;                                                              lword @ 0= if-true -->                                                              ;s  \ randomize     ( -- )                                          \   initiate cons {seed} w. value from /dev/urandom             \ random        ( n1 -- n2 )                    (lload key)     \   init {seed} if zero, ret random number n2 in range [0,n1)   ( == numeric output ======= : ud.r : ud. : udb.r : ub.r : ub. )                                    if-found (ud.r) 5 +continue  : (ud.r) >r 0     ( dn r -- a u )                                 <# r 0< if bl hold endif                  \ -ve r: trailing bl  >rr if dabs endif #s r> if "- hold endif                        r r> 0< if not endif pad hld @ - - 0max   \ one's cpl fieldwdt  -dup if 0 do bl hold loop endif #> ;                                                                                          if-nfound ud.r  : ud.r (ud.r) type ;                            if-nfound udb.r : udb.r base@ >r base ! ud.r r> base ! ;                                                                -->     \ (ud.r)    ( dn field -- a u )                                 \ ud.r      ( dn field -- )                                     \ udb.r     ( dn field base -- )                                \   display unsigned double right justified in |field| chars    \   filled w. blanks, w. trailing bl if field = -ve one's cpl   ( = numeric output ==   ud.r   ud.   udb.r   ub.r   ub. : u.r )                                         lword @ 0= if-true -->  -wl u.r  if-true if-nfound u.r          : u.r  0 swap d.r ;  ;s                                                                 -wl ud.  if-true if-nfound ud.          : ud. -1 ud.r ;                                                                         -wl udb. if-true if-nfound udb.         : udb. -1 swap udb.r ;  0 -wl ub.r -wl ub. or or                                                 if-true if-nfound ub.r         : ub.r 0 rot rot udb.r ;-wl ub.  if-true if-nfound ub.          : ub. -1 swap ub.r ;                                                                    \ u.r   ( un field -- )                                         \ ud.   ( ud -- )                                               \ udb.  ( ud base -- )                                          \ ub.r  ( un field base -- )                                    \ ub.   ( un base -- )                                          ( == numeric output ==================================== : (#q)                           lword @ 0= -l (#q) 0= or if-true -->                                                if-found (#q) ;s  : (#q)  ( q wdt flg -- a u )                                      <# sdup 1abs >r 0< if bl hold endif                             >rr if r> over >r >r qabs endif                                 begin q# ?q0= until                                             r> if r> 0< if "- hold endif endif 2drop #>                     r> over- spaces type ;                                                                                                        \ (#q)  ( q n f -- a u )                                        \   q quad integer (4 cells, 128 bits).                         \   f flag, display as signed num if non-zero.                  \   n no. of columns within which to display, right justified.  \     no leading blanks if width given is less than the output  \     string length; one trailing blank if wdt is -ve ones cpl. ( numeric output = : uq.r : uq. : ud. : q. : q.r : qb. : uqb. )  lload? (#q)                                                                    if-nfound uq.               : uq. -1 0 (#q) ;                   if-nfound  q.               : q. -1 -1 (#q) ;   -l uq.r if-true if-nfound uq.r              : uq.r   0 (#q) ;   -l q.r  if-true if-nfound q.r               : q.r    1 (#q) ;   -l ud.  if-true if-nfound ud.               : ud. 0. uq. ;                                                                                                       -l qb. 0= if-true 1 +continue  if-nfound qb.   : qb. base@ >r base ! q. r> base ! ;                                            -l uqb. 0= if-true 1 +continue  if-nfound uqb.  : uqb. base@ >r base ! uq. r> base ! ;                                                  lword @ 0= if-true -->                                                                                                                                                                                                  ( : . : %. : &. : #. : $. : d%. : d#. : d$. : q%. : q#. : q$. ) forth definitions decimal  ( : m. )          -l f4 if-true -->  -wl %. -l &. or -l $. or -l . or if-true lload? ub.             -wl  %. -l  . or if-true if-nfound  %.          :  %.   2 ub. ; -wl  &. -l  . or if-true if-nfound  &.          :  &.   8 ub. ; -wl  #. -l  . or if-true if-nfound  #.          :  #.  10  b. ; -wl  $. -l  . or if-true if-nfound  $.          :  $.  16 ub. ;     -wl d%. -l d$. or -l m. or if-true lload? udb.              -wl d%. -l m. or if-true if-nfound d%.          : d%.  2 udb. ; -wl d#. -l m. or if-true if-nfound d#.          : d#. 10  db. ; -wl d$. -l m. or if-true if-nfound d$.          : d$. 16 udb. ;     -wl q%. -l q$. or -l m. or if-true lload? uqb.              -wl q%. -l m. or if-true if-nfound q%.          : q%.  2 uqb. ; -wl q#. -l m. or if-true if-nfound q#. lload qb. : q#. 10 qb. ; -wl q$. -l m. or if-true if-nfound q$.          : q$. 16 uqb. ;                                                                 ( == numeric f4 ======================= : dmin : dmax : d0max )                                                                                                     if-found dmxm 1 +continue   : dmxm >r 4 ndup d- sdrop 0< r> xor if 2swap endif 2drop ;      -l dmin  if-true            if-nfound dmin  : dmin  1 dmxm ;    -l dmax -l d0max or if-true if-nfound dmax  : dmax  0 dmxm ;    -l d0max if-true            if-nfound d0max : d0max 0. dmax ;                                                                                                           lword @ 0= if-true -->                                                                                                                                                                                                                                                                                                                                  \ d0max     ( d -- d' )                                         \   adjust d to not below zero                                  ( == f4 == util ================================= : [e] : [f] ) forth definitions root if-found [e] if-found [f] 9 +continue    hidden definitions     if-found [fv] 3 +continue                                       lload? context@                          : [fv] context@ >r cfa execute -find r> context !                 0= dup 0= ?error state@ < if cfa , exit endif cfa execute ;                                                                   root definitions    \ forcedly cpl a {forth} or, {editor} word: -wl [f] if-true if-nfound [f] : [f] ' forth  [fv] ; immediate   -wl [e] if-true if-nfound [e] : [e] ' editor [fv] ; immediate                                                                                                           lword @ 0= if-true -->                                                                  \ [f]           ( ccc, -- | abort-0 )           root            \   { ..words.. [f] forthword ..words.. }; re {vfind}           \   search {forth} 1st, leaving search order unchanged          ( == f4 == util === : argstg : arg? : a? : argc : argp : (argc) forth definitions                                               if-nfound argp (argp) (up) -                       ucons argp   if-nfound argc (argp) (up) - 4- dup  user (argc)   ucons argc   if-nfound ?esc : ?esc chmax ?input dup if drop #27 = endif ;                                       if-found argstg 2 +continue  : argstg dup argc 1+ <  ( n -- p u | 0 0 ( inactive arg   )       if 4* argp + @ zcount ;s endif 0and dup ;                                                                                                                          if-found arg? 3 +continue  : arg? -1 begin     ( -- ( display inactive cmd line arguments)   1+ dup argstg sover type dup -cr 0= ?esc or until drop ;      : a? argstg -dup 0= -exit type ;  ( n -- |0 )                                                                                                                                -l f4 if-true -->                                                                  ( == f4 == util ====================================== : envp ) forth definitions                                                                                                               lword @ 0= found? envp and if-true -->                                                                                          if-nfound envp        (argp) (up) - 4+ ucons envp                                                                                                                    lword @ 0= if-true -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( == f4 == util == env vari ======================== : envstg ) forth definitions                  if-found envstg 7 +continue                                                    lload? envp   : envstg        ( n -- a u | 0 ( env-vari by num )                envp swap 1- dup                                                begin sdrop swap @+ dup                                         while rot 1- dup 0<                                             until abs minus and sdrop                                       dup 0dup 0= -exit zcount ;                                                                                                                                             -wl envstg if-true ;s                                                             -->                                                                                                                                  \ envstg        ( n -- a )                      forth           \   ret string w. name and content of env-vari by number        ( == f4 == util == env vari ======================== : getenv ) forth definitions                  if-found getenv 7 +continue                                                    lload? envp   : getenv envp           ( a1 -- a2 u | 0 ( env-vari by name )     begin @+ dup                                                     if zcount 2dup "= scan sdrop - 3 pick count s=                  else 2drop 0= 0. endif                                         0= until -dup 0= -exit                                          4- @ sdrop zcount "= scan 1/string ;                                                                                                                                   -wl getenv if-true ;s                                                             -->                                                                                                                                  \ getenv        ( a1 -- a2 u | 0 )              forth           \   ret string w. content of env vari by name                   ( == f4 == stack - F8 substitutes ============ : rotd : oswap )                                                                 -l rotd found? rotd 0= and dup                                           if-true if-found  drop2  ' drop2 palias rotd                    if-true if-nfound drop2  : rotd rot drop ;                                                       -wl rotd  if-true ;s                                                                  -l oswap found? oswap 0= and if-true : oswap over swap ;                                                  -wl oswap if-true ;s                                                                                                                             -->                                                                  \ rotd      ( n1 n2 n3 -- n2 n3 )                               \   { rot drop }                                                \ oswap     ( n1 n2 -- n1 n1 n2 )                               \   { over swap }                                               ( == ernum decoder ======================== : .er : #er : "er )                           lword @ 0= found? er# or if-true -->                       -l .er -l "er or -l #er or 0= if-true -->  hidden definitions decimal                                      lload place lload evaluate  lload >loc                          lload stg   lload to-stg    lload erfile                                                                                        erfile scount #4096 stg #def                                                                    ( source file, dft errno.h    ) bl 8 << bl or constant blbl     ( scan w. ctrls : blbl ( cons )            0. 2variable er#     ( link, max.errno : #er (vari )                                                    -->                                                                          \ #def          ( -- a )                        hidden          \   text source w. #define-d names used for the rsp. forth words\   may be any such file, dft 'erfile' = errno.h of Linux kernel( == ernum decoder ========================   .er   #er   "er )                           lword @ 0= found? -?- or if-true -->                       -l .er -l "er or -l #er or 0= if-true -->  hidden definitions decimal                                      : flin pad 200 rot 10 fread ;           ( ch -- a u )                                                                           : #define <builds  ( ccc, -- a  ( [ link|0, -ernum, string ] )    here er# @ , er# ! 1 er# 4+ +! name >rr [number]                if 2drop r sfind if drop cfa execute 4+ @ else -4095 endif      else drop minus endif , rdrop                                   "* word here c@ 1+ allot 0 c, does> ;                                                                                         linux definitions hex                                           #define -?- 0 *    unknown code *                                                                                          -->                                                                  ( == ernum decoder ========================   .er   #er   "er )                           lword @ 0= found? oer or if-true -->                       -l .er -l "er or -l #er or 0= if-true -->  hidden definitions decimal                                      : er@           ( a u -- )  ( evaluate error number defn )        1K >loc l0 place l0 count                                       2dup begin blbl scan dup 1- 0< 0=                               while over bl swap c! 1/string repeat                           sdrop 0< if 2drop exit endif                                    2dup "* scan over blbl swap 1- w! 1/string "* scan              sdrop - 1+ l0 place l0 evaluate 1K loc> ;                                                                                     : oer #def r/o new-chan >rr open            ( -- ch )             r over- if rdrop exit endif mmapf sdrop                         r close dropd 0< if rdrop exit endif drop r> ;                                                                           -->  ( == ernum decoder ========================   .er   #er   "er )                          lword @ 0= found? [er] or if-true -->                       -l .er -l "er or -l #er or 0= if-true -->  hidden definitions decimal                                      : >er ?exec oer dup 0< over ?error                                4K +sp drop >input >rr flin r flin r flin 6 ndrop               decimal [_] linux definitions                                   begin r flin                                                     2dup s" /*" match drop 0=/= >r over @ "fed# = r> and            if er@ else 2drop endif r ch-rnum 1- 0<                        until r> close input> drop ;                                                                                                  : [er] er# 4+ @ 2- 0< state@ or 0= -exit >er ;                                                                            -->   \ >er  ( -- ( 'evaluate' ernum definitions   )                  \   implicitely by "er, "er by .er, if error words not found    ( == ernum decoder ========================   .er   #er   "er ) linux definitions decimal lword @ 0= found? .er or if-true -->                       -l .er -l "er or -l #er or 0= if-true -->  : "er [er] abs minus er# dup 4+ @ 0                               do @ 2dup 4+ @ = -leave loop dup if 8+ endif sdrop ;                                                                          : .er "er -dup 0= -exit dup 12 - nfa id. print ;                                                            -wl .er if-true ;s                                                             -->  \ "er           ( n -- a )                      linux           \   ret ptr to linux error message string for error code |n|    \   display error message w. { ( num -- ) "er print }           \   or, error name w. { ( num -- ) "er 12 - nfa id. }           \ .er           ( n -- )                        linux           \   by ernum n display error code name and message text. "er and\   .er compile the error words to linux voc if not already done( == ernum decoder =================== ?er   ?rms   #er   "er ) linux definitions lword @ 0= -l #er  0= or if-true -->          lload? is@                                                      hidden definitions                                              \ redirect 'message', -ve ernum for linux, else forth error text: [m] dup 0< if .er ;s endif [ ' message is@ sdrop , ] ;         ' [m] is message                                                                                           -wl .er if-true ;s                                        if-found #er 3 +continue  : #er [er] count er# dup 4+ @ 0                                   do @ dup 2over rot 4- nfa count 31 and s= 0= -leave loop        >r 2drop r> 4+ @ ;                                                                                                            \ #er           ( a -- n|0 )                    linux           \   ret -ve ernum by name of linux error code, 0 if invalid. on \   1st attempt compiles the error words if not already present ( == ernum decoder ============================= : ?er : ?rms ) linux definitions decimal                    -l f4 if-true -->                                -l ?er -l ?rms or 0= if-true -->                                                      lload? .er                   -l ?rms 0= found? ?rms or if-true 3 +continue  : ?rms [er] (ti) @ >r 1 (ti) !  ( show ernum decoding )           25 er# 4+ @ minus                                               do i . i message cr 0 w4f ?esc -leave loop r> (ti) ! ;                                    -l ?er 0= found? ?er or if-true ;s  : ?er [er] (ti) @ >r 1 (ti) !   ( show error codes by names )     depth >r er# dup begin @ dup -dup 0= until drop                 begin >rr 4+ @+ -5 .r r> 4- nfa id. tab print cr                dup er# = 0 w4f ?esc or until depth r> - ndrop r> (ti) ! ;                                                                    \ ?er           ( -- )                          linux           \   display erro no. encodings as def'd by linux and F4 dr0-file( == f4 == util ================================= : is@ : is? ) root definitions                                                            ( pfa -- dftpa cfa )    if-found is@ 3 +continue    : is@ dup dup cfa @ [ ' emit cfa @ ' (ok) cfa @ ] literal         =if >body else [ rot ] literal - if 2drop 0. exit               else @ (up) + endif endif @ swap 4+ @ swap ;                                                                                                                      if-found is? 2 +continue    : is.id -dup 0= -exit nfa id. ;                                 : is? is@ dup if c>pfa endif is.id is.id ; ( display deferred)                                              -l f4 if-true -->                                                                   \ is@       ( pfa -- default-pfa|0 exec-cfa|0 ) root            \   find execution pointers of a user-/deferred word            \ is?       ( pfa -- )                          root            \   display execution names of a deferred word                  ( == f4 == util ===================================== : vfind ) root definitions                                                                                    if-found vfind 2 +continue  : vfind     ( vvv www( -- pfa byte 1 | 0   ( find word in voc )   [_] ' >body ( @ >v) pfa lfa @ name swap (find) ;                                                                                               -l [vf] 0= found? [vf] or if-true 1 +continue  : [vf] >body pfa lfa @ (find) ;     ( name pfa -- pfa b 1 | 0 )                                                                                                              -l f4 if-true -->                                                                                                                                  \ vfind     ( vvv www, -- pfa byte flg | 0 )    root            \   find word www in vocabulary vvv, exclusively                \ [vf]      ( a-name vocpfa -- pfa byte 1 | 0 ) root            \   find in single vocabulary, use: { " here" ' forth [vf] }    ( == util ====================== : [vf] : v2nd : n2nd : v2pfa ) forth definitions decimal                    -l f4 if-true -->                                                                  if-nfound l>pfa lload palias    ' 8+ palias l>pfa               if-nfound v2nd                  : v2nd >body pfa >body ;                                                                        -l n2nd -l '2nd or found? n2nd 0= and                              if-true                      : n2nd v2nd l>pfa v<nfa ;       -l v2>pfa if-true if-nfound v2>pfa : v2>pfa n2nd pfa ; ( kernel)                                                                \ v2nd  ( pfa -- vlfa )                         forth           \   fetch voc-head lfa of 2nd-ary voc, use: ' forth v2nd.       \ n2nd  ( pfa -- nfa )                                          \   display 2nd voc. name with { ' voc n2nd id. }.              \ v2>pfa ( pfa1 -- pfa2 )                                       \   2nd-ary search voc pfa2 of vocabulary by pfa1 .             ( == util =========================================== : words ) forth definitions decimal                                                                           if-found words 5 +continue  : words                                                           context @ voc-link                                              enter begin dup 4- context ! vlist cr                           entry +@ -dup 0= ?esc or                                        until context ! ;                                                                                       -wl words if-true ;s                                                             -->                                                                                                                                                                                                                                                                  \ words         ( -- )                          forth           \   display all words of all vocabularies, in voc-link sequence ( == util =============================================== : w ) forth definitions decimal               lword @ 0= if-true -->                                          if-found w 8 +continue  : w dup 1- 0< 0= if cfa @ endif last @                            begin                                                            2dup pfa cfa @ 2dup = rot rot ' noop < 0= = or -dup 0=          if over 1+ 0= 0dup                                               if [ latest c@ immediate latest c@ immediate xor ]              dup c@ literal and endif                                       endif if dup id. endif t<nfa swap drop -dup 0=                 until drop cr ;                                                                                             -wl w if-true ;s                                                             -->  \ w             ( pfa|-1 | 0 -- )               forth           \   sequentially list all words of definition type equal to word\   by pfa parameter, pfa=0 for kernel words, -1 for immediates.( == f4 == util ====================================== : vocs ) root definitions forth          if-found vocs 3 +continue                                                                       : vocs voc-link ( -- )                                            enter begin dup 4+ v<nfa id. entry +@ -dup 0= until ;                                                                                                         lword @ 0= if-true -->                                                                                                                                                                                                                                                                                                                                                                                                          \                                                               \ vocs          ( -- )                          root            \   display the {voc-link}ed vocabulary names                   ( == f4 ===================================== : @vocs : @vocs ) root definitions forth              if-found @vocs 7 +continue                                                                  : @vocs depth >r voc-link                                         enter begin dup 4+ @ swap entry +@ -dup 0= until                voc-link +@ context @ v> current @ v> depth r> - ;                                                                            : !vocs >rr ?depth >v current ! >v context ! r> 2- ddup           do 1 do j i - pick over 4+ ! +@ loop i ndrop leave loop ;                                                                                                     lword @ 0= if-true -->          \ @vocs         ( -- .xx. n )                    root           \ !vocs         ( .xx. n -- )                    root           \   get/set (rst) current & context vocabularies search order   \   voc-data block: [-1,vnfa] [vlfa]  [vcfa]  [vpfa] [vpf2]     \                   dummyname voclink 2nd-voc flags  nfa        ( === : !order : @order : order : v<flg : [cv] : .voc : .vocl )                  -l @order -l !order or 0= if-true 4 +continue  root definitions forth          if-found @order 2 +continue     : @order context 2@ ;       immediate                           : !order context 2! ;       immediate                                                      -wl @order -wl !order or if-true ;s  hidden definitions forth                     if-found .voc -->  8 cons+ v<flg           ( pfa -- vfa ( ptr to voc-flags )       : [cv] voc-link                                                   enter begin 0 over v<flg c! entry +@ -dup 0= until ;                                                                          : .voc      ( vlfa -- next|0 )                                    4+ dup v<flg c@ if 0= ;s endif                                  1 over v<flg c! dup 4+ v<nfa id. 4+ @ dup 0= -exit >v ;                                                                  -->                                                                  ( == f4 == util ===================================== : order ) hidden definitions forth            if-found order 7 +continue                                                                  : .vocl [cv] ( pfa -- ( vocs chain by 'context'/'current' pfa )   dup nfa id. ": emit cfa execute                                 @ begin .voc -dup 0= until cr ;                                                                                               root definitions forth                                          : order hidden ' context .vocl ' current .vocl ; immediate                                                                                                              lword @ 0= if-true -->                                                                                                                                                                                                  \ order         ( -- )                          root imed       \   display context and current search order                    ( == f4 == util ============================= : bye" : abort" ) hidden definitions root cmo @   -wl bye" if-true 3 +continue                            0 cmo !  if-found abort" 2 +continue    : (abt") swap                                                     if print space here print in @ blk@ [_] [ quit endif drop ;   hidden definitions root          if-found bye" 1 +continue      : (bi") swap if print space here print [_] [ bye endif drop ;                              if-nfound -compile lload -compile                                    -wl bye" if-true 3 +continue    root definitions                 if-found abort" 2 +continue    : abort"       ( 0 -- ( n -- , abort w. message text; imed   )    [_] " -compile (abt") ;    immediate                          root definitions                 if-found bye" 1 +continue      : bye" [_] " -compile (bi") ; immediate                                                 cmo !  lword @ 0= if-true -->                                                                           ( ====================== : lload" ) -l f4 -l nix or if-true -->                                                                                               -l lload" 0= if-true 9 +continue  : lload"                                                          [_] f" -dup 0= over ?error                                      [ -2K dup minus ] literal |loc l0 place                         dup count l0 1K + place                                         l0 swap l-load                                                  1- 0< if l0 1K + cr print ."  -?- " endif                       literal |loc ;                                                                                                                                                                                                                                                                                                                \ lload"    ( ccc, a -- )                       cvoc            \   lload word name at a from file w. path-expandable name ccc  (  == : lfile" )                 -l f4 -l garnix or if-true -->            lload? basename lload? place lload? f" lload? "hlp                                                                   : <lfile [_] f" [ -2K dup minus ] literal |loc l0 place           l0 scount basename 2dup ". rscan sdrop - here place             here head smudge 0 , l0 [_] s, literal |loc ;                                                                                 : .lfile warning @ 0= -exit dup cr ": emit print ": emit ;                                                                      : lfile >input 1 dr? - dr! using 1 load empty-buffers input> ;                                                                  : lfile" <lfile does> .lfile dup "hlp lfile ;                                                                                   \ lfile"    ( ccc, -- )                         cvoc            \   define screen-file ccc loading word of name 'basename .ext' \   on execution, defines filename ccc string for {help}.       (  == : edline )                 -l f4 -l garnix or if-true -->                                                                 if-found edline  2 +continue                                    : edline over scount drop dup rot edlin zcount rot place ;                                                                                                                                                                                -wl edline if-true ;s                                                             -->                                                                                                                                                                                                                                                                                                                                 \ edline    ( p u -- )                          cvoc            \   edit and store max u chars of string from rstdin to buffer  \   at p, useing default text from char-string at p             \ = : >col : (bot) : (wid) : >bot : b> : p> : o> : t> : k> : k)                                         lword @ 0= if-true -->                                  -l >col 0= if-true 1 +continue  if-nfound >col : >col xy sdrop at-xy ;     ( n1 -- ( at column)                                                                 if-nfound (bot) max-xy      1- constant (bot) drop              if-nfound (wid) max-xy drop 1- constant (wid)                                    found? >bot -l (bot) -l (wid) or or if-true ;s : >bot <builds ,                                                  does>@ out off max-xy ddup 1- to (bot)                          2swap 1- to (wid) + min 0max 0 swap at-xy ;                       -1 >bot b>  -2 >bot p>  -3 >bot k) ' k) defer k>    \ : k)      -4 >bot o>              1 max-xy sdrop - >bot t>                                                                            \ >bot  ( ccc, disp -- )                                        \   define positioning word at line { disp max-y - }, column = 0( == mem-cons, byte-cons, fixed val == : cons : mcons : bcons ) forth definitions                       lword @ 0= if-true -->                 -l mcons 0= found? mcons or if-true 2 +continue  : mcons <builds ( C: ccc, location -- )     ( X: -- @location )   [ ' first cfa @ ] literal latest pfa cfa ! -4 allot , ;                                                 -wl mcons if-true ;s                                                                                 -l bcons 0= found? bcons or if-true 2 +continue  : bcons <builds ( C: ccc, c -- )           ( X: -- sign xtd c )   [ ' bl cfa @ ] literal latest pfa cfa ! -4 allot c, ;                                                   -wl bcons if-true ;s                                                                                            -l cons 0= found? cons or if-true --> : cons <builds  ( C: ccc, n -- )           ( X: -- n )            [ ' use cfa @ ] literal latest pfa cfa ! -4 allot , ;                                                                         ( == : ans compat, vmem cons ==== : value =================== ) forth definitions                       lword @ 0= if-true -->                              -l value 0= if-true 1 +continue     if-nfound value : value constant ;     ( alterable 'constant' )                                                                                                         -wl ans if-true -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ value         ( ccc, n -- )                   forth           \   ANS-4th alterable constant, F4 synonym 'cons'.              ( == f4 ===================================================== )                                                         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( == f4 == ================================ : docdir : erfile )                                                                               lword @ if-true -l docdir 0= if-true 1 +continue   if-nfound docdir libdir count + 1+ count + 1+ constant docdir                lword @ if-true -l erfile 0= if-true 3 +continue                                     if-found erfile 2 +continue         libdir count + 1+ count + 1+                                           count + 1+ count + 1+ count + 1+ constant erfile                                                                                                       lword @ 0= if-true -->                                            -l docdir if-true ;s                                                             -->     \ docdir        ( -- a )                -cplvoc-                \   path to F4 installed documentation files                    \ erfile        ( -- a )                -cplvoc-                \   path to Linux sources header file w. the errors' coding     ( =================== all : string words, abort", evaluate == ) forth definitions decimal               lword @ 0= if-true -->                                         -l string 0= if-true ;s                                                                   lload? stg        \ implies {place}                             lload? to-stg     \ implies {place}, {abort"}                   lload? +to-stg    \ implies {+place}                            lload? c+stg      \ implies {c+place}                           lload? vplace,                                                  lload? evaluate                                                                                                                                                    ;s                           lload? abort"                                                   lload? place                                                    lload? c+place    \ implies {+place}                                                                                            --> == counted & asciz string manipulation == place stg == <--                                                                                                                                                                                                                                                                                                                                 \                                                               \ place         ( a1 n a2 -- )                                  \       store unlimited size string at q1, len n, to mem at a2  \ +place        ( a1 +-/n a2 -- )                               \       +n: append, -n: prepend string a1,|n| to string at a2   \ c+place       ( char +-n a2 -- )                              \       a-/pre-pend |n| bytes of multi-byte char to string at a2\                                                               \ STRINGs may either be of type 'counted stg', chars preceded by\ a count-byte or, any length sequence, enclosed by <nul> bytes.( ==== string storage ================================= : c>b ) hidden definitions forth decimal                                                                                                if-nfound c>b : c>b dup 256 u< -exit 0and ; ( byte -- 0|byte )                                                                                  lword @ if-true -l c>b if-true ;s                                                                       -->                                                                                                                                                                                                                                                                                                                                                                                                     \ auxilary for "place" words and modifying a string vari;       \ determines whether a string can be stored w. leading count    \ byte or, should be enclosed in <nul> bytes.                   ( == f4 == == string storage ======================== : place ) forth definitions decimal                                                                           if-found place 7 +continue  hidden                              lload? c>b                  forth definitions                                               : place                     ( a1 u a2 -- ( a1, a2 may overlap )   -dup if 2dup + >r 2 pick               ( a1, a2 =/= 0 )          if over c>b over 2>r 1+ swap move 2r> c! 0 0. endif             swap r> 1+ c!                                                  endif 2drop ;                                                                                           -wl place if-true ;s                                                             -->  \                                                               \ place         ( a1 u a2 -- )                                  \       store text a1 of length u1 as a counted, if u < 256, or \       enclosed by <nul>-chars string to address a2.           ( == string concatenation f4 : pl>   <pl   +place   c+place   ) hidden definitions decimal     ( c+place also 'lload's +place )                                                                                                       if-found pl> 5 +continue                                        lload? c>b                : pl>    forth                  ( a1 +n a2 -- ( append to stg )   2>rr scount >rr +                  ( -- a1 n a3  R: -- n a2 )   2>rr swap move 0 2r> + c!          ( --          R: -- n a2 )   r> 2r> rot rot + c>b swap c! ;                                                                                                                                                                                                        lword @ 0= if-true -->                                               -l pl> if-true ;s                                                             -->                                                                                                                                  ( ==== string concatenation == f4 === : <pl  c+place   +place ) hidden definitions decimal                                                                            if-found <pl 7 +continue                                        lload? c>b                : <pl    forth                  ( a1 -n a2 -- ( prepend to stg)   swap abs swap 2dup                                                           ( -- a1 n a2+n a2 u2+1 -- a1 n (R: a2 a2' u2   )   >rr r scount 2>r + r 2+ move ( + countbyte & trailing <nul> )   2r> >r swap >rr move                   ( -- (R: a2 u2 n     )   2r> + c>b r> c! ;                                                                                                                                                  lword @ 0= if-true -->                                            -l <pl if-true ;s                                                                -->                                                                                                                                     ( ==== string concatenation == f4 == == : +place   c+place    ) forth definitions            ( +place also by 'lload c+place' )                                                                                                 if-found +place 4 +continue                                      lload? <pl                                                      lload? pl>                     : +place  hidden        ( a1 +/-n a2 -- ( a1, a2 may overlap  )   over 0< if <pl ;s endif pl> ;   ( +n append / -n prepend stg)                                                                                                        lword @ 0= if-true -->                                            -l +place if-true ;s                                                             -->   \                                                               \ +place        ( a1 n a2 -- )                                  \       pre-/append n bytes of text at address a1 to counted    \       string at address a2. +n appends, -n pre-pends.         ( === f4 == concat stg w. multi-byte char ========= : c+place ) forth definitions               if-found c+place 4 +continue                                                   lload? +place                                                                    : c+place               ( c +/-n a2 --  ( n=byte-count of chr )   2>r sp@ 2r> +place drop ;                                                                                                                                          lword @ 0= if-true -->                                       -l c+place if-true ;s                                                                 -->                                                                                                                                     \                                                               \ c+place       ( c n a -- )                                    \       pre-/append n bytes of multi-byte char c, l.s.byte 1st, \       to counted string at address a. +n appends, -n prepends.( ==== f4 == string storage ======================= : vplace, ) forth definitions decimal                                                   -l vplace, 0= found? vplace, or if-true 5 +continue                                                      lload? c>b                                                                 : vplace,    ( a -- a' )            ( cpl string to vari-mem )    scount dup 2+ dup vallot vhere swap - >rr                       over c>b over c! 1+ swap 2dup + 0 swap c! cmove r> ;                                                                                                               lword @ 0= if-true -->                                           -l vplace, if-true ;s                                                             -->     \                                                               \ vplace,       ( a -- a' )                                     \   compile counted string a to vari mem and append <nul> byte, \   ret destn address a'.                                       ( ==== f4 == initiated string variable ================ : stg ) forth definitions decimal                         lload? place                                                                                                        if-found stg 3 +continue  : stg <builds   \ C: ccc( a u n -- ( X: -- a ( ptr to string )    (vp) @ , over max 4+ dup v,                                     (vp) @ over vallot >v dup rot erase place does>v 4+ ;                                                                                                                                                                   lword @ if-true -l stg if-true ;s                                                             -->                                                                                                                                     : label <builds latest count 31 and swap , , does> @+ swap @ ;                                                                                                                                  ( == f4 == assign/concat stg vari ====== : ?stg : stg@ : stg? ) forth  definitions                     lload? abort" lload? stg                                                                 hidden definitions                   if-found ?stg 1 +continue  : ?stg > 0= forth abort" stg ovf ";                                                                                                                                  if-found stg@ 3 +continue  ' stg 4+ @ ' over cfa =      ( tf if stg stored to dictionary )                    dup if-true : stg@ 4+ @+ 4- ;                                    0= if-true : stg@ >body @+ 4- ;                                                                                                                  if-found stg? 1 +continue  : stg? stg@ over scount sdrop 3 pick + ?stg ;                                                                                                      -wl ?stg -wl stg@ -wl stg? or or if-true ;s                                                             -->  ( == f4 == assign/concat stg vari ================== : to-stg ) forth definitions decimal                                                                          if-found to-stg 3 +continue                lload place lload stg@ lload ?stg lload -compile  : !stg stg@ 2 pick ?stg place ;                                 : to-stg [_] ' -compile !stg ; immediate                                                                                                                                lword @ 0= if-true -->                                                              ;s                                                                                                                                                                                                                                                                                                                                                                                                  \ to-stg    ( ccc( a +/-u --         ( re-assign string vari  ) ( == f4 == assign/concat stg variable ===== : +to-stg : c+stg ) forth definitions decimal         if-found +to-stg 3 +continue                          lload +place lload stg? lload -compile  : +!stg stg? +place ;                                           : +to-stg [_] ' -compile +!stg ; immediate                                                                                                                          if-found c+stg 4 +continue                         lload stg? lload c+place lload -compile  : c!stg stg? c+place ;                                          : c+stg [_] -compile c!stg ; immediate                                                                                                                                  lword @ 0= if-true -->                                                              ;s                                                                  \ c+stg     ( ccc( chr +/-size -- ( a/pre-pend multi-byte chr ) \ +to-stg   ( ccc( a +/-u --      ( a/pre-pend string         ) ( == f4 == sendfile ============================= : file>file ) forth definitions               if-found file>file 4 +continue                                                                  : file>file     ( ch1 ch2 ud1 u2 -- cnt|er )                      rot rot here dup 2@ 2>r 2! here 2swap ch-id swap ch-id swap     sp@ sys sendfile >r 5 ndrop r> 2r> here 2! ;                                                                                                                  lword @ 0= if-true -->                                          ;s                                                                                                                                                              \ file>file     ( ch1 ch2 ud1 u2 -- cnt|er )                    \   copy u2 bytes from posn ud1 of file by cannel ch1 to ch2,   \   transfer between any devices or files which support {mmap}, \   ch2 may also be a socket - re syscall 'sendfile'.           \   ret no. of bytes sent or, error code if { $fffff000 er u< } ( == f4 == kbd =================== : kbd?key : kbd-key : esc? ) forth definitions                                                   -l esc? -l kbd?key or -l kbd-key or 0= if-true 3 +continue  if-nfound kbd?key : kbd?key kbd chan ?input 0dup ;                                                                              -l esc? -l kbd-key or 0= found? kbd-key or if-true 2 +continue  : kbd-key                                                         enter begin kbd chan w4f drop entry kbd?key until ;                            -l esc? 0= found? esc? or if-true 2 +continue  : esc? kbd?key drop            ( -- flg )                         bl =if 0 >r begin kbd-key rdrop >rr bl - until r> endif \e = ;                                           -wl esc? if-true ;s                                                             -->  \ esc?      ( -- flg )                                          \   after <bl> wait until other key pressed.                    \   ret tf if <esc> keyboard input, else ff.                    ( == f4 ===================================================== )                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( == doc & lib path strings == : doc :figed :f4x (  unused  )   lword @ 0= if-true --> ( brauchen wir nicht: siehe "fname"... )                                                                 forth definitions decimal                                                                          if-found doc 3 +continue     " /glossary" count pad place                                    libdir count + 1+ count + 1+                                                      count minus pad +place pad count dup stg doc                                                                                                     if-found f4x 1 +continue     libdir count + 1+ count dup stg f4x \ : f4x extension screenfile                                                                                                                                                                                                                                ;s                                                                                              ( == type asciz-string per addr == : zprint =========== : uc? ) forth definitions decimal          0 -wl zprint sdrop                                              0= if-true 2 +continue                                          if-found zprint 1 +continue  : zprint zcount ptype ; ( a -- ( type w. printing chars, only )                                                                                                    0 -wl uc? sdrop                                                 0= if-true 2 +continue                                          if-found uc? 1 +continue     : uc? dup uc-lc < ; ( c -- flg ( upper-case char )                                                 lword @ 0= if-true -->                                          ;s                                                                                                                                                                                                                                                                                           ( == : litr ======================================= : 'xecute )                                                                 if-nfound 'xecute   : 'xecute cfa execute ;                                                             -wl 'xecute if-true ;s                                                                                                 -wl litr 0= if-true 3 +continue  forth definitions vocabulary litr                               litr definitions : ] ] [_] literal [_] !order ;                 forth definitions : literal[ [_] @order [_] [ litr ; immediate                                                                                                                             -->                                                                                                                                                                                                                                                                                                                                  ( ==== string execution ============= : {x} : eval : evaluate ) hidden definitions decimal                                                                                                      if-nfound #x#   0 constant #x#                                                                        if-found {x} 7 +continue  : {x} 0 blk ! enter begin ( -- )       ( string "interpret"er )    -find if                                                         state@ < if cfa , else cfa execute endif                       else here number dpl @ 1+                                        if [_] dliteral else drop [_] literal endif                    endif                                                          entry ?stack in @ #x# < 0= until ;                                                                        -wl {x} if-true ;s                                                             -->                                                                                                                                  ( ==== string execution, cont'd ==================   evaluate ) forth definitions decimal                                                                                                       if-nfound vb (vb) (up) - ucons vb    ( base addr of vari-mem )                                      if-found eval 2 +continue   : eval >input is #x# tib !           ( p u -- .xx. )              #128 (bits) or! 0in! -1 blk ! {x} input> ;                                                              -wl eval if-true ;s                                   if-found evaluate 1 +continue   : evaluate scount eval ;             ( a -- .xx. )                                                    -wl evaluate if-true ;s                                                              -->                                                                                                                                  \ evaluate      ( a -- .xx. )                   forth           \   interpret supplied string                                    --> == local memory words ==================== : locals == <-- \                                                               \ F4 local 'variables' based on unlimited size local memory     \ allocation, by cells addressable w. 'l@' and 'l!' or, by the  \ content of uvari s0 prior to allocation as the local memory   \ base address - re "l0" user-constant in 'local' voc.          \ this locals implementation for simplicity doesn't provide     \ addressing by names but, indexed by cells' positions access.  \ e.g.                                                          \       1 l@ 3 l!                                               \ copies 1st to 3rd local cell.                                 \ local memory can be preserved across forth words.             \ { lload locals } for all extension words related local memory.\ this impl. might not be the most (though fairly) efficient one\ but, was supplied as an example of some hi-level words which  \ could extend #any# forth which provides the "s0" uvari.       ( ======= : :locals : locals; : >loc : loc> : (locals : locals) hidden definitions                lload? palias lload? -compile                                                                                                                                 if-nfound >loc ' |loc palias >loc                               if-nfound loc> : loc> minus |loc ;                                                                                                                                                                                             -wl >loc -wl loc> or if-true ;s                                                             -->                                                                                                                                                                                                                                                                  \ >loc          ( -/+n -- )     de/allocate -/+n local cells    \ loc>          ( +n -- )       de-allocate n local cells       ( == link local memory back ======================== : no-loc ) forth definitions decimal          if-found no-loc 3 +continue                    -l no-loc lword @ 0= and if-true 2 +continue  : no-loc            ( -- ( init dstack from mmap bot )            (pb) @ 32 + dup s0 ! to l0 ;                                                                           -wl no-loc if-true ;s                                                          -->                                                                                                                                     \  (pb) @ 32 + dup s0 ! to l0 ;                                                                                                                                                                                                                                                                                                                                                                                                                                 ( == fetch/store sings by named disp ============ : l@n : l!n ) forth definitions decimal                         lload? kdef?                               kdef? l@0 0= if-true 11 +continue                                        if-found l!n 2 +continue  : l!n not 4* create ( ccc, index -- (X: n -- )                    here 14 allot ' l!0 cfa @ over 14 cmove 5 + c! unsmudge ;                                                                                                           if-found l@n 2 +continue  : l@n not 4* create ( ccc, index -- (X: -- n )                    here  9 allot ' l@0 cfa @ over  9 cmove 6 + c! unsmudge ;                                                                     \ defn:    1 l!n store-to-1st-local     ( -- )                  \ exec:    12345 store-to-1st-local     ( n -- )                \   1st local item, immediately 'below' @s0, at index 0                                          -wl l!n -wl l@n or if-true ;s                                                             -->  ( == fetch/store doubles by named disp ========== l2@n : l2!n ) forth definitions decimal                         lload? kdef?                              kdef? l2@0 0= if-true 11 +continue                                       if-found l2!n 4 +continue  : l2!n  ( ccc, index -- (X: dn -- )                               create not 8* here 20 allot ' l2!0 cfa @ over 20 cmove          over 4+ over 11 + c! 8+ c! unsmudge ;                                                                                                                              if-found l2@n 4 +continue  : l2@n  ( ccc, index -- (X: -- dn )                               create not 8* here 13 allot ' l2@0 cfa @ over 13 cmove          over 4+ over 10 + c! 6 + c! unsmudge ;                                                                                                                                                                                       -wl l2!n -wl l2@n or if-true ;s                                                          -->     ( ==== local variables ================== : :locals : locals; ) forth definitions                                    lload? l!                                                                                                    if-found :locals 1 +continue  : :locals dup |loc l!0 -dup 0= -exit 1 do i l! loop ;                                             if-found locals; 1 +continue  : locals; minus |loc ;                                                                               lword @ 0= if-true -->                     -l :locals -l locals; or if-true ;s                                                                     -->     \ :locals       ( n -- )                                        \   alloc & init top +n local cells from dstack                 \   top local item at index 1, @tos before allocation.          \   locals' count at index 0, e.g. for de-allocation.           \ locals;       ( n -- )                                        \   discard top n cells of local datapace                       ( ==== local variables ============================ : l@ : l! ) forth definitions                                                                                                               if-nfound l@ : l@ depth + pick ;                                if-nfound l! : l! depth + 1- minus pick ;                                                                                                                               lword @ 0= if-true -->                                       -l l@ -l l! or if-true ;s                                                             -->  \                                                               \ l@            ( n --x )                                       \   fetch n-th local, n=0 is 1st                                \ l!            ( x n -- )                                      \   store x to n-th local                                       \   l@, l! don't require the rsp. locals defined in current word\   & may refer to any levels' local memory, in the actual order( ==== local variables ====================== (locals   locals) forth definitions                                                                               if-found (locals 1 +continue    : (locals 1+ dup :locals ; ( n -- )                                                             if-found locals) 1 +continue    : locals)    l@0 locals; ; ( - -- )                                                                                                                                  lword @ 0= if-true -->                -l (locals -l locals) or -l locals or if-true ;s                                                             -->     \ (locals       ( n -- )                                        \   initiate n local cells from dstack                          \ locals)       ( - -- )                                        \   de-alloc latest by '(locals' installed local cells          \   top local item at index 1, @tos before allocation.          \   size by above words stored to/fetched from posn 0.          ( ==== local variables ====================== : s>loc : loc>s ) forth definitions   \ - not tested -                                                                    lword @ 0= if-true -->                             -l s>loc -l loc>s or 0= if-true -->                                                                  : s>loc s0 @ sp@ s0 ! ;                 \ -?-                   : loc>s -1 l@ s0 ! ;                    \ -?-                                                                                                                                           ;s                                                                                                                                      \                                                               \ s>loc         ( .xx. -- p )                    forth          \   push all items from data-stack to local dataspace, ret l0   \ loc>s         ( -- .xx. )                     forth           \   pop all locals of current word to data-stack                ( == channel definition table displacements ======= : chflags ) ( ===== : <rnum> : <cmds> : <cmap> : <cmsz> : <chpt> : <fctl> ) ( ===== : <tyfl> : <chnd> : <mdfl> : <perm> : <fpos> : <fsiz> ) linux definitions decimal -l chflags lword @ 0= if-true drop -->dup -l <chpt> or if-true  if-nfound <chpt>     4 cons+ <chpt>   dup -l <tyfl> or if-true  if-nfound <tyfl>     8 cons+ <tyfl>   dup -l <chnd> or if-true  if-nfound <chnd>    12 cons+ <chnd>   dup -l <mdfl> or if-true  if-nfound <mdfl>    16 cons+ <mdfl>   dup -l <perm> or if-true  if-nfound <perm>    20 cons+ <perm>   dup -l <rnum> or if-true  if-nfound <rnum>    24 cons+ <rnum>   dup -l <fpos> or if-true  if-nfound <fpos>    28 cons+ <fpos>   dup -l <fsiz> or if-true  if-nfound <fsiz>    40 cons+ <fsiz>   dup -l <fctl> or if-true  if-nfound <fctl>    48 cons+ <fctl>   dup -l <cmds> or if-true  if-nfound <cmds>    52 cons+ <cmds>   dup -l <cmap> or if-true  if-nfound <cmap>    56 cons+ <cmap>       -l <cmsz> or if-true  if-nfound <cmsz>    60 cons+ <cmsz> ;s( ==== file pointer == f4 ============== : fpos : feof : fsof ) forth definitions decimal            if-found fpos 2 +continue                                       lload? <fpos>              : fpos >rr cdt <fpos> 2@ 2swap 2over d- drop r> fposre drop ;   if-nfound feof : feof dup flen 0 rot fpos ;                     if-nfound fsof : fsof 0. rot fpos ;                                                                                                                -wl feof -wl fsof -wl fpos or or if-true ;s                                                             -->  \                                                               \ fpos    ( d1 ch -- d2 )                                       \   set file ptr of channel ch to d1, ret previous ptr d2       \ feof      ( ch -- dn )                                        \   fptr to eof, ret previous fptr                              \ fsof      ( ch -- dn )                                        \   fptr to start, ret prev. fptr                               ( == file opr == f4 ======================== : fflush : mkdir ) forth definitions decimal     -l fflush 0= if-true 3 +continue                                     if-found fflush 2 +continue  : fflush ch-id sp@ sys fdatasync if-found 3drop 3drop ;                                    if-nfound 3drop 2drop drop ;                                                                                                        -l mkdir 0= if-true 4 +continue                                      if-found mkdir 3 +continue  : mkdir scount drop                                               &2770 swap sp@ sys mkdir if-found  2sdrop 2sdrop sdrop ;                                 if-nfound 2sdrop 2swap 2drop sdrop ;                                        lword @ 0= if-true -->   \ fflush    ( ch -- )                                           \   store cached data back to file by channel ch; no error code \ mkdir     ( a -- er )                                         \   create directory by counted asciz name at a, ret error code ( == file opr == f4 =============================== : fdelete ) forth definitions decimal                                                                                                                                    -l fdelete 0= if-true 3 +continue                                    if-found fdelete 2 +continue  : fdelete       ( a -- er )                                       scount drop sp@ sys unlink sdrop sdrop ;                                                              -wl fdelete if-true ;s                                                             -->                                                                                                                                                                                                                                                                  \ fdelete       ( a -- er )                                     \   delete file by name as F4 4th-string (counted asciz) at a,  \   ret er = 0 or error code.                                   ( == file opr == f4 ========== : extname : basename : dirname )                                                                                              0 -wl extname or                                                0= if-true 1 +continue             if-nfound extname : extname rscan 1/string ; ( a u c -- a' u' )                              0 -wl basename or                                               0= if-true 2 +continue             lload? extname                                                  if-nfound basename : basename "/ extname ;   ( a u -- a' u' )                                0 -wl dirname or                                                0= if-true 1 +continue             if-nfound dirname  : dirname 2dup "/ rscan sdrop - ;                                                                                     -wl extname -wl dirname or -wl basename or if-true ;s                                                             -->                                                                  ( == file opr == f4 ====================== : xg-chan : ch-eof )                               -l ch-eof 0= if-true 1 +continue  if-nfound ch-eof : ch-eof dup 0< ( 1+ 0=) -exit ch-rnum 0= ;                                             -wl ch-eof if-true ;s                                                                              -l xg-chan 0= found? xg-chan or if-true 2 +continue : xg-chan cdt dup [ 1 cdt 0 cdt - ddup ] literal m>r              swap cdt >rr swap literal cmove r> literal r>m ;                                                      -wl xg-chan if-true ;s                                                             -->                                                                                                                                  \ ch-eof    ( ch -- flg )                                       \   tf if sys-channel ch at eof, file may be mmap-ed and closed \ xg-chan   ( ch1 ch2 -- )                                      \   exchange sys-channels' c1 and c2 definition tables          ( ==== channel name =============================== : ch-name ) hidden definitions decimal                if-found ch-name -->                                                                  0 " place"  l-load 0 " +place" l-load 0 " ?depth" l-load 2drop  0 " <rnum>" l-load 0 " <cmds>" l-load 2drop               drop  0 " <cmsz>" l-load 0 " <cmap>" l-load 2drop                                                                                     : m# @ rot #s rot hold drop ;                                   : "cmap cdt >r                                                    <# 0. ": r <cmsz> m# "@ r <cmap> m# "+ r> <cmds> m# #> ;      : .chfmap tab "cmap type ;                                                                                                 -->  \ .chfmap       ( ch -- )                                       \   display "cmap mmap-ed file pseudo channel name string:      \   '+'disp from file beginning'@'memory address':'mapped size  \   requires access to the /proc files-ystem                    ( ==== channel name ===============================   ch-name ) forth definitions decimal      if-found ch-name 9 +continue                                                     lload? 4drop    : ch-name   ( a u ch -- a u' | x 0 ( buffer{a,u} channel ch   )   3 ?depth base@ >r dup ch-id 4* 0< 0=                            if s" /proc/self/fd/" 4 pick place                               ch-id chmid not and 0 decimal <# #s #> 3 pick +place            over dup scount drop sp@ sys readlink -4 roll 4drop            else rot >r swap >r dup ch-id 2* 0<                              if drop s" -?-" else "cmap endif r> min r place r> scount      endif 2dup + 0 swap c! r> base ! ;                                                     lword @ if-true -l ch-name if-true ;s                                                             -->  \                                                               \ ch-name   ( a u ch -- a u'|0 )                                \   fetch file-name which is represented by the open channel ch ( ==== channel name ========================= : chans : .chan ) hidden definitions decimal   if-found chans if-found .chan -->                                                                  lload? stg     lload? to-stg lload? +to-stg                     lload? ch-name lload? >loc                                      lload? d0max   lload? u.r    lload? ub.r   lload? ud.r          lload? <rnum>  lload? <tyfl> lload? <mdfl>                      lload? <perm>  lload? <fpos> lload? <fsiz> lload? <fctl>                                                                                                                                        if-nfound <ferr> 0 variable <ferr>  ( rstdout error no. )                                                                  -->                                                                                                                                                                                                                                                                  ( ==== channel name =========================   chans   .chan ) hidden definitions decimal   if-found chans if-found .chan -->                                                                  : .mde dup cdt dup <tyfl> @ -10 16 ub.r swap ch-id chmap -        if dup <perm> @ swap <mdfl> @                                   else <fctl> dup 2+ w@ swap w@ endif -8 u.r -9 8 ub.r ;                                                                        : .fsz                                                            cdt dup <fpos> 2@ d0max -11 ud.r <fsiz> 2@ d0max -11 ud.r ;                                                                   forth definitions decimal                                        ( ch -- ( type, mode, perm, er, pos, siz, mapd, mapa, mapsz )  : .chparm dup .mde dup ch-rnum -9 .r .fsz ;                                                                         -->                                                                                                                                         ( ==== channel name =========================   chans   .chan ) hidden definitions decimal   if-found chans if-found .chan -->                                                                  : .chline               ( ch p u -- )                             -dup 0= if drop -9 .r s" -?-"                                   else 2 pick ch-id 2* 0< 0=                                       if rot dup -4 .r dup ch-id -9 over dup 0< 0= swap 2* 0< or       if .r else 16 ub.r endif .chparm endif                        endif tab type ;                                                                                                              s"  ch\t  fd\t0xtype\tmode\t&perm\t erno" #4090 stg .chh        s" \t  fpos\t\tfsiz\t(mmap)\tdevice\n"      +to-stg .chh                                                                        : .chhead .chh count dup >rr >loc l0 e\stg type r> loc> ;                                                               -->                                                                     ( ==== channel name =========================   chans   .chan ) forth definitions decimal          if-found .chan 11 +continue                                                     lload? >loc  : .chan                 ( ch -- )                                  dup 1K >loc l0 1K rot ch-name .chline 1K loc> ;                                                  if-found chans 4 +continue  : chans .chhead chmax 1+ 0                                        do i ch-id dup 0< 0=                                             swap chmid xor dup 0< 0= swap 2* 0< 0= and or                  if i .chan cr endif loop ;                                                                             lword @ 0= if-true -->                                                                 \ .chan     ( ch -- )                           forth           \   display ch channel description                              \ chans     ( -- )                              forth           \   display main data of currently open channels                ( == close user channels ======= : cclose : a-close : m-close )                             forth definitions decimal                                                                           if-nfound cclose        : cclose dup close drop close drop ;    if-nfound a-close       : a-close chmax 6 do i close drop loop ;if-nfound m-close       : m-close a-close a-close ;                                                                                -wl a-close -wl m-close -wl cclose or or if-true ;s                                                                    -->   \ cclose        ( ch -- )                                       \   close channel ch, unmap if ch was {mmap}-ed.                \ a-close       ( -- )                          forth           \   close all user settable file channels, 6..31;               \   un-mmap already closed files' mmap-ed memory.               \ m-close       ( -- )                          forth           \   close and munmap all user settable channels, 6..31          ( == path+file =============================== : pth| : ftest ) forth definitions decimal      -l ftest 0= if-true 3 +continue                                      if-found ftest 2 +continue  : ftest         ( a -- ch|er flg ( whether file accessible    )   r/o new-chan open dup 0< 0= ;                                                                 -l pth| 0= if-true 3 +continue                                       if-found pth| 2 +continue  : pth|          ( a u -- a' u' a1 u2 ( rmg path, segment      )   2dup ": scan swap over 1/string 4 roll 4 roll 4 roll - ;                                              lword @ 0= if-true -->                                  -l pth| -l ftest or if-true ;s                                                             -->  \ pth|          ( a u -- a' u' a1 u1 )                          \   separate 1st segment(a1,u1) of a PATH variable(a,u)         \ ftest         ( a -- ch|er flg )                              \   ret channel and tf if file accessible, else ernum and ff    ( == file-name ========================= : path? : fname : f" ) forth definitions decimal                                                                                                                                 lload? locals)                                                  lload? place                                                    lload? +place                                                   lload? c+place                                                  lload? ftest                                                    lload? pth|                           -l fname -l f" or if-true lload? getenv                         -l fname -l f" or if-true lload? ?depth                         -l fname -l f" or if-true lload? docdir                                                                                                                                                 -->                                                                                                                                     ( path? ) forth definitions decimal if-found path? 9 +continue  : path?         ( a1 u1 a2 u2 a3 u3 -- a1 u1 a2 u2 a4 u4 0|1  )   1K dup >loc l0 swap 2 (locals          ( 1:#loc 2:l0 )          pth| 2 l@ 0 over ! place 2>r           ( a1 u1 a2 u2 a3' u3')   over >rr c@ "/ = r> w@ "/. = or 0= 2r or 0= 0= and              if "/ 1 2 l@ c+place endif     \ 2 l@ #16 b.                    2dup 2 l@ +place 2 l@ ftest            ( a1 u1 a2 u2 ch flg )   if close 2rdrop 2 l@ scount dup 6 pick <                         if 6 pick place 4 pick scount else 0and endif 2>r              endif 2r> rot 0= 1 l@ locals) loc> ;                                                           -l fname -l f" or if-true -->                                                              ;s  \ path?         ( a1 u1 a2 u2 a3 u3 -- a1 u1 a2 u2 a4 u4 0|1 )  \   find file{a2,u2} in, or at 1st segment of, directory{a3,u3} \   for "fname":   ( buf,file,path -- buf,file,path',0        ) \   buf size > 4K! (      ...      -- buf,file,path-to-file,1 ) ( ==== fully qualified file-name from PATH ==========   fname ) forth definitions decimal       if-found fname -->              : -path path? -dup -exit or 0and ;                                                                                              : arpath? 0. -path ;            ( abs path or rel wrt cwd     )                                                                 : libpath? libdir count -path ; ( file in library dir         )                                                                 : docpath?                      ( search docs dir             )   libdir count + 1+ count + 1+ count -path ;                                                            -->                     \ XXXpath?      ( a1 u1 a2 u2 -- a1 u1 a2 u2 a3 u3 flg )        \   search filename(a2,u2) in the rsp. path, use buffer(a1,u1). \   user supplied path if non-empty stg-vari {usrpath} found.                                                                                                                                   ( ==== fully qualified file-name from PATH ==========   fname ) forth definitions decimal       if-found fname -->              : epath?        ( ... a -- ...  ( scan dirs from PATH env vari)   sfind if drop cfa execute count else " PATH" getenv endif 0     enter begin path? entry 0= while dup 0= until                   -dup -dup -exit 0and ;                                                                                                        : envpath? " f4path"  epath? ;  ( scan dirs from PATH env vari) : usrpath? " usrpath" epath? ;  ( user supplied, last path var)                                                                                                         -->                     \ envpath?      ( a1 u1 a2 u2 -- a1 u1 a2 u2 a3 u3 flg )        \   find file-name(a2,u2), ret path+file(a3mu3) in buffer(a1,u1)\   search PATH envirenmental vari or, optionally in {f4path};  \   if {f4path} exists, search won't continue in PATH env-vari. \   ( .. -- a1 u1 a2 u2 xx 0 ) if name not found.               ( ==== fully qualified file-name from PATH ==========   fname ) forth definitions decimal          if-found fname 4 +continue                                                    lload? 4drop   : fname 4 ?depth               ( a1 u1 a2 u2 -- a1 u3 | xx 0 )    arpath? 0= if libpath? 0= if docpath? 0= if usrpath? 0=         if envpath? 0dup endif endif endif endif 2>r 4drop 2r> ;                                                                                                             -wl fname if-true ;s                                                             -->                                                                                                                                     \ fname         ( a1 u1 a2 u2 -- a1 u3 | xx 0 ) forth           \   find file-name{a2,u2} in 'libdir', 'docdir' and PATH,       \   store full path to buffer buf{a1,u1}, ret string{a1,u3}     \   ret 0 @tos if file not found in F4 directories or, PATH.    \   note: buffer a1 should not cross range a2,u2.               ( ==== fully qualified file-name from PATH =============   f" ) forth definitions decimal          if-found f" 8 +continue                                                      lload? -compile : (f")          ( a u -- a1 u1 ( a1=pad )                         10K +sp drop dup 8+ 4/ >rr >loc l0 place                        pad 4K l0 scount fname r> loc> ;                                                                                              : f" [_] s" -compile (f") ; immediate                                                                                                                                                                                                        -wl f" if-true ;s                                                             -->  \ f"         ccc( -- a1 u1 | xx 0 )             forth           \   find file-name ccc in 'libdir', 'docdir' and PATH, usrpath, \   store full path to pad = a1, ret string{a1,u1}              \   ret 0 @tos if file not found in F4 directories or, PATH.    ( == display path to file =========================== : which )     forth definitions decimal if-found which 10 +continue                                                     lload? fname          hidden definitions                                          : [which]         ( a -- )                                        8K +sp drop 2K dup >loc >r                                      >rr count l0 1K 2swap fname dup                                 if rdrop type else 2drop r> print ."  - not found" endif        r> loc> ;                                                                                                                         forth definitions                                           : which name [which] ;                                                                                    -wl fname if-true ;s                                                             -->  \ which         ccc( -- )                                       \   display path+file of by blanks delimited file-name ccc.     ( ==== read mmapped file data ======================= : readm ) forth definitions                                                                                   if-found readm 4 +continue  : readm                                                           over 1- 0< if drop 0. ;s endif                                  >r 2dup over swap r> scan                                       drop over - 2swap 2 pick 1+ /string 2swap ;                                                                                                                           lword @ 0= if-true -->                                             -l readm if-true ;s                                                             -->                                                                  \                                                               \ readm         ( a u c -- a1 u1 a2 u2 )        forth           \   read mmap-ed range {a,u} until next char c, ret string      \   from a till before and, remaining range after char c.       ( ==== read mmapped file data ====================== : readmc ) forth definitions                  if-found readmc 4 +continue                                                                  : readmc    ( a u u1 -- a' u' a2 u2 ( max u1 bytes from {a,u} )   over 1- 0< if drop 0. exit endif                                >r over swap r /string rot r> ;                                                                                                                                       lword @ 0= if-true -->                                            -l readmc if-true ;s                                                             -->                                                                                                                                  \                                                               \ readmc    ( a u u1 -- a' u' a2 u2 )           forth           \       fetch at most u1 bytes from memory range {a,u},         \       ret string{a2,au} and remaining memory range{a',u'}.    ( ==== read mmapped file data ====================== : readml ) forth definitions                                                                               if-found readml 3 +continue                                          lload? readm                                                    lload? <lf>                : readml <lf> readm ;                                                                                                                                                lword @ 0= if-true -->                                        -l readml if-true ;s                                                                 -->                                                                                                                                     \                                                               \ readml        ( a u -- a' u' a2 u2 )          forth           \   fetch next line(a2,u2) from memory(a,u),                    \   leave remaining data range(a',u')                           ( ==== F4 help ============================== : help : gls?  0)     if-found help -wl help if-true ;s                                                                                                   lload? readml                                                   lload? locals)                                                  lload? l@                                                       lload? stg                                                      lload? to-stg                                                   lload? +to-stg                                                  lload? place                                                    lload? c+place                                                  lload? ?depth                                                   lload? fname                                                    lload? w                                                                                                        -->                                                                     ( ==== F4 help ==========================   help   gld   glc 1)                                                                         lload? vp                                                                                                               hidden definitions decimal                                                                                                              if-nfound gls      0. 2constant gls     ( glossary )            if-nfound glc      0   constant glc     ( file chan)                                                                                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                     ( ==== F4 help ============ : "hlp : hlp!   help   gld   glc 2) hidden definitions decimal                                                                                                       lload? ch-name                                                  lload? evaluate                                                 lload? basename                                                 lload? palign+                                                  lload? place                                                    lload? vp                                                                                                                                                                              -->                                                                     \ file names extn to {help}                                     \ names stored to {hlp} wordlist which is not available to the  \ standard {-find} procedure unless explicitely stored to the   \ rsp. system variable(s).                                      ( ==== F4 help ==========================   help   gld   glc 3)                                              if-found "hlp -->  forth definitions decimal           \ file names extn to {help}                                                                 0 variable hlp ' hlp cfa @ forget hlp    wordlist hlp           hidden definitions                                                                                                              : hlp:              ( a -- ( def word from path+file at a )       dup scount basename here count + >rr place                      r> head [ dup ] literal latest pfa cfa !                        vp , here v, [_] s, unsmudge ;         drop                                                                                   : "hlp              ( a -- ( append filename-word to {hlp} wl )   context 2@ hlp current ! 2>r hlp: 2r> context 2! ;                                                                    -->                                                                     ( ==== F4 help =================== : !hlp   help   gld   glc 4)                                   -wl !hlp if-true lload? hlp!                                    -wl !hlp if-true     hlp! ;s                                               if-found hlp! -->                                                                  : :hlp                  ( ch -- ( add file name by channel ch )   1K |loc l0 4K rot ch-name l0 place l0 "hlp -1K |loc ;                                                                         : hlp!                  ( -- ( define current screenfile name )   dr? bchan ch-opn 0= -exit dr? bchan :hlp ;                                                                                    -l help if-true               hlp!     ( sto ref to this file )                                                                                                                         -->                                                                     \ hlp: { name=file, vari@: addr of path+file, here: path+file } ( ==== F4 help ==========================   help   gld   glc 5)                                            if-found -hfile -->  : -hfile        ( a1 -- a2   ( last {hlp} defn before addr a1 )   hlp @ enter begin n<nfa    ( search wordlist until a2 < a1  )   entry dup 0= over w@ $2081 = or                                  if 2drop 0. 0 else 2dup < endif                                0= until swap 0= -exit pfa 4+ ;                                                                                               : hfiles context @ hlp context ! vlist context ! ;                                                                                            -->                                                                                                               \ -hfile        ( a1 -- a2 )                                    \   last lload-file name defn before addr a1.                   \ hfiles                                                        \   display sequence of all files which are available for {help}( ==== F4 help ===============================   help   ghd? 6)                                    if-found -hname 5 +continue                                                                  : -hfind    ( a1 -- a2 )                                          sfind 0dup 0= -exit drop -hfile ;                                                                                             : -hname hlp @ (find) 0dup 0= -exit drop 4+ ; ( a1 -- a2|0 )                                                                                                   -wl hlp! -wl "hlp or if-true ;s                                                             -->                                                                                                                                  \ -hfind    ( a1 -- a2 )                                        \   find filename where the word w. name at a1 was loaded from  \ -hname    ( a1 -- a2 )                                        \   check a1 for valid lload-file, ret ff or addr of path+name. ( ==== F4 help ===============================   help   ghd? 7) hidden definitions decimal                if-found ghd? -->                                                                     : ghd?                                                            [ bl 8 << bl or dup ] literal scan literal scan                 "( scan ascii - scan ") scan sdrop        ( a u f -- ... )      dup 0= -exit begin drop readml 0= until 1 l@ swap over- 1 ;                                                                                                                           -->                                                                                                                                                                                                     \                                                               \ ghd?          ( a u -- a u' 1 | a u 0 )       hidden          \     test whether line(a,u) is a comment heading line,         \     ret tf and count u1 of bytes till next non-comment line   ( ==== F4 help ===============================   help   gls? 8) hidden definitions decimal          if-found gls? 6 +continue                                                    lload? 4drop   : gls? over                                                       if swap 1 l! /string              ( .. -- a' u' ( l1: a1    )    over c@ [ bl 1+ ] literal <      ( locals set up by caller )    0dup if readml ghd? endif        ( find & test comment line)   else 4drop 0. 1 endif ;           ( .. -- 0  0  1           )                            lword @ if-true -l gls? if-true ;s                                                             -->                                                                   \ gls?        ( a u ptr=flg disp -- a1 u1 1 | a' u' 0 | 0 0 1 ) \             ( gls entry a1,u1 tf; rmg mem ff; 0. tf at eof  ) \   glos comment after <nl> with <bl>forthword<bl|tab><bl|tab>  \   followed by each of "(", "-", ")", in sequence and ends     \   before next zero length line - blanks & tabs do count!      ( ==== F4 help =============================   help   readmh 9) hidden definitions decimal                if-found readmh -->                                                     lload? <nl>   : readmh                                                          4 ?depth 1K >loc l0 >r 0. 2 (locals                             r place [ bl 8 << <nl> or ] literal -2 r c+place                begin 2dup r count match gls? until                             rdrop locals) 1K loc> ;                               -->                                                                                                                                                                                                                                                                     \ readmh        ( a u a1 u1 -- a' u' a2 u2 | 0. 0 )             \   scan glossary file for string(a1,u1) entry                  \   ret 0. 0 eof, rmg mem & xx,0 not found, rmg mem & text found\   rmg mem left in place for consecutive search passes         ( ==== F4 help ==============================   help   .lgls 0) hidden definitions decimal               if-found .lgls -->                                                                     : [lgl]         ( -- flg )  ( flg =/= 0  if word @here found )    0 here l-find -dup 0= -exit       ( R: -- ( -- s a a | 0 0 )    dup chmax < 0= >rr if r/o new-chan open endif                   >rr mmapf sover 0< 3 ?error       ( R:c f ( -- s p u | abt )    2 pick 1K * /string 2>rr "\ lword 2+ c! lword count match       -1K and swap 0= if 0and endif     ( R: c f p u ( -- s dsp flg)  2r rot >rr /string drop swap r> 1K / + cr ." scr# " 10 b.       here 1K dr? bchan ch-name type     1 swap b/scr 0 do             dup c/l -trailing dup 4 pick or -cr dup -3 pick type c/l +     loop cr drop 2rdrop r> r>                                       if dup close drop close else unmapf endif drop 1or ;                                                                  -->                                                                     ( ==== F4 help ==============================   help   .lgls 1) hidden definitions decimal               if-found .lgls -->                                                                     : .lgls                                         forth             dr? >r 0                                                        begin drop [lgl] dup 1 dr? - dup dr! r = or until               rdrop -exit dr0c chan ch-id 1+ dr1c chan ch-id 1+ or            >input -1. dr0c chan cdt ! dr1c chan cdt !                      0dup if [lgl] endif -dup 0=                                     if here -hfind dup if using [lgl] dup 0=                        if here sfind if drop w endif endif endif endif input> drop ;                                                         -->                                                                     \ .lgls             ( -- )                      hidden          \   find & display help for word @here if def'd in either one of\   the currently opened screen-files dr0/dr1 or, in <f4x.scr>. ( ==== F4 help ===============================   help   docf 2) hidden definitions decimal              if-found docf -->                                                                       : docf                        ( locals by caller  1:lmem 2:l0 )   2 l@ 1 l@ 2swap fname dup 0= -exit 2drop                        2 l@ r/o new-chan open dup dup                                  mmapf rot close drop dup 0< 3 ?error rot ;                                                                                                                                            -->                                                                                                                                                                                                                                                                                                                                     \ docf          ( p u -- sz addr ch | xx 0 )(L: lmem l0 )       \   open, mmap, close a doc file(p,u), ret mmap ptrs            ( ==== F4 help ===============================   help   mgls 3) hidden definitions decimal                                                                              if-found mgls   -->     : mgls linux                                                      1K dup >loc l0 swap 2 (locals        ( 1:#lmem 2:l0 )           s" glossary" docf 0max dup if to glc 2dup to gls endif          1 l@ locals) loc> ;                                                                                                   -->                                                                                                                                                                                                                                                                                                                                     \ mgls linux    ( -- size addr | xx 0 )                         \   mmap 'glossary' file, ret size,addr & set 2constant "gls" to\   memory range, ready for munmap, re-fetch if already mmap-ed.( ==== F4 help == help on help ====                          4)                                         if-found hh     -->     hidden definitions decimal                                      0. 252 stg hh                                                                                                                   s" \nhelp\t( ccc, -- )\t\t\t(i)\n\tHELP on kernel"    to-stg hh s"  word ccc, from latest 'glossary' file;\n"        +to-stg hh s" \tglossary file expected in 'libdir, 'docdir' "   +to-stg hh     s" or, PATH. re { help help } \n"                +to-stg hh hh count pad e\stg to-stg hh                                                                                            -->                                                                                                                                     \ text for the parameter-less call to "help"                    s" \tfile <f4x.scr> tried if "                       +to-stg hh                     s" glossary search failed.\n"    +to-stg hh ( ==== F4 help == help on help ====                          5)                                         if-found hg     -->     hidden definitions decimal                                      libdir count + 1+ count + 1+ count      dup 0. rot 100 + stg hg                                                                 s" \n\t-?-\n\tgenerate help text w. <make doc> in "   to-stg hg s" source dir\n\tcopy file ./d/glossary to "         +to-stg hg  ( docdir )  +to-stg hg                       s" \n" +to-stg hg hg count pad e\stg to-stg hg                                                                                                                                                            -->                                                                                                                                                                                                                                                                     \ text for "help" if 'glossary' file not found                  ( == F4 help == 6) forth definitions if-found help 7 +continue                                                                  : [help]                                                          mgls swap rot 2dup w@ 1- swap if                                 if count 2dup here place readmh -dup                             if type drop else .lgls endif                                  else 2drop hh count type endif glc close 2drop exit            endif 5 ndrop hg count type ;                                                                                         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( == F4 help == 7) forth definitions                            if-nfound help : help name [help] ;                                                                     lword @ 0= if-true -->  \ help      ( ccc, -- )                         forth           ;s  HELP on kernel word ccc from latest 'glossary' file in          'libdir or 'docdir' or, in the environmental PATH variable.     if not found in glossary tries dr0, then dr1 and, checks        <f4x.scr> and, any additional source files if the word          was found in the current search order, for a rsp. entry.        re gls?, .lgls, !hlp                                        \ asm glossary pattern:                                             "//;"                           empty comment line, plus        "//; name   ( xx -- yy )  "     comment, name, "(" & ")     \ screenfile entries:                                               " : name "                      anywhere in the rsp. scr or     "\ name ( xx -- yy )      "     alternatively, preferred    ( == \e string == : e\type : [etype] : e\print : \e )           forth definitions decimal                        lload? >loc                                    if-found e\print 5 +continue    if-nfound \e    27 constant \e      ( ascii <esc>ape code     )                                                                                                 if-found e\type 1 +continue     : e\type dup 4+ >rr >loc l0 e\stg type r> loc> ;                if-nfound e\print : e\print scount e\type ;                                                                                                                    if-found [etype] 2 +continue     ' [type] palias [ctype]                                         : [etype] dup 4+ >rr >loc l0 e\stg [type] r> loc> ;                                                                              -wl e\type -wl e\print -wl \e -wl [etype] or or or if-true ;s                                                             -->                                                                  ( == escaped string =================================== : .e" ) forth definitions decimal     lload? >loc lload? -compile                                                                                                              if-nfound 3+   lload 3+  hidden definitions                                              if-nfound .e : .e dup 3+ 4/ >rr >loc l0 e\stg type r> loc> ;                                                                    forth definitions                                               if-nfound .e" : .e" [_] s" -compile .e ; immediate                                                                                                                          -wl .e" if-true ;s                                                             -->                                                                                                                                  \ .e    ( a u -- )                                              \   expand escape seq-s and type string(a,u)                    ( ================================================== : lxcon? )                                                                                               -l lxcon? 0= if-true 2 +continue                                                   lload? getenv  if-nfound lxcon? : lxcon? " TERM" getenv s" linux" s= 0= ;                                                                                                               -wl lxcon? if-true ;s                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                  \ lxcon?        ( -- flg )                      root            \   ret tf if F4 running in a Linux console, env-vari TERM=linux( == vt control == : cls : vt : (vt)         forth definitions  lload? <f> lload? place lload >loc vt if-found (vt) 12 +continue                                                                vt definitions              if-found (vt) 4 +continue           : (vt) <builds forth         ( self emitting 'escaped' string )   name count                                                      dup 4+ >rr >loc l0 e\stg here over 4+ allot place r> loc>       does> out @ swap count type out ! ;                                                                                                                                                                                                                                                                                                                                                                                                                                    -l vt -l cls or if-true -->       ( dies ab zeile 14! )\ lload? <f> lload? >loc lload? place if-found (vt) 12 +continue( == vt control == : cls : vt : (vt) ( "lload vt" all vt words) forth definitions                                                                                                               vt definitions                                                  if-nfound cls>eos (vt) cls>eos \e[0J     \ : cls>eos till bot   if-nfound cls>cur (vt) cls>cur \e[1J     \ : cls>cur till curs  if-nfound cls>scr (vt) cls>scr \e[2J\e[H \ : cls>scr cls & home if-nfound cls>eol (vt) cls>eol \e[0K     \ : cls>eol till eol   if-nfound cls>sol (vt) cls>sol \e[1K     \ : cls>sol till curs  if-nfound cls>lin (vt) cls>lin \e[2K     \ : cls>lin clear line                                                                 forth definitions                                               if-nfound cls : cls vt cls>scr 0 out ! ; \ ( -- ) clear screen                                                                                    -wl vt -wl cls -wl (vt) or 0= or if-true -->                                                                  ( == vt ctrl == : palette : rst-palette  ( linux console, only) forth definitions decimal              if-nfound vt lload vdef  vt                      lload? (vt) lload? 4drop lload? lxcon?                                                                  if-nfound \e    27 constant \e      ( ascii <esc>ape code     )                                                                 vt definitions forth             if-found palette 5 +continue   : palette lxcon?    ( r g b colour# -- ( Linux console, only! )   if base@ out @ 2>r                                               >r 0 hex <# # # drop # # drop # # 2drop r> 0 #                  "P hold "] hold \e hold #> type 2r> out ! base ! exit          endif 4drop ;                                                                                                                 if-nfound rst-palette (vt) rst-palette \e]R \ rst kernel setting                                                                     -wl palette -wl rst-palette or 0= -wl vt or if-true -->    ( == vt display attributes ================ : vtgrr : bg : fg ) forth definitions decimal            if-nfound vt lload vdef    if-nfound \e    27 constant \e          ( ascii <esc>ape code )                                                                 vt definitions             if-found fg if-found bg 7 +continue  : vtgrr                   ( n -- ( ecma-48 graphics rendition )   0 base@ out @ 2>r decimal                                       <# "m hold # # "[ hold \e hold #> type 2r> out ! base ! ;                                               -wl vtgrr if-true ;s  #30 cons+ >colour                                               : fg dup (i) ! >colour      vtgrr ;    ( n -- ('ink' colour   ) : bg dup (p) ! >colour 10 + vtgrr ;    ( n -- ('paper' colour )                                                                                                     -wl fg -wl bg or if-true ;s                                                            -->                                                                  ( == vt display attr =========== : colour ( red green blue... ) forth                                if-nfound vt lload vdef    vt definitions forth             if-found white 11 +continue    if-nfound black   0 constant black                              if-nfound red     1 constant red                                if-nfound green   2 constant green                              if-nfound yellow  3 constant yellow                             if-nfound blue    4 constant blue                               if-nfound magenta 5 constant magenta                            if-nfound cyan    6 constant cyan                               if-nfound white   7 constant white                                                                                              found? palette 0= if-true 1 +continue                           #114 #110 #20 yellow palette      ( console 'brown' -> yellow )                                              -l vt if-true -->  \ : black : red : green : yellow : blue : magenta : cyan : white\ == vt ================== : (a) : (v) : [a] : [v] : vt : (vm)  forth                           if-nfound vt    lload vdef      vt definitions decimal                          lload? vtgrr                                                                    if-nfound (a)  (up) @ ddup 4+ to (up)   user (a)   ucons [a]    if-nfound (v)  (up) @ ddup 4+ to (up)   user (v)   ucons [v]                                                                    if-found (vm) 2 +continue                                       : (vm) <builds dup 0> if 1 swap << not endif , 1 swap << , ,      does> @+ (v) and! @+ (v) or! @ dup (a) ! vt vtgrr ;                                                                   -->                                                                                                                                                                                                     \   [a]     latest set vt attrib                                \   [v]     attrib. state bits                                  \ == vt ==================   (a)   (v)   [a]   [v]   vt   (vm)  \                    cmd  or   and                              if-nfound dft         0   0     0   (vm) dft        \ : dft     if-nfound bold        1   1    -1   (vm) bold       \ : bold    if-nfound normal     21   0     1   (vm) normal     \ : normal  if-nfound blink       5   5    -1   (vm) blink      \ : blink   if-nfound no-blink   25   0     5   (vm) no-blink   \ : no-blinkif-nfound reve        7   7    -1   (vm) reve       \ : reve    if-nfound revd       27   0     7   (vm) revd       \ : revd    if-nfound uon        38   8    -1   (vm) uon        \ : uon     if-nfound uoff       39   0     8   (vm) uoff       \ : uoff                                                                    if-nfound rev   : rev if reve exit endif revd ;                 if-nfound <rev> : <rev>  [v] [ 1 7 << ] literal and 0= rev ;                                                 -l vt if-true -->                                                                  ( == set scrolling region ======================= : sr# : csr ) forth                               if-nfound vt lload vdef     editor definitions decimal                                      if-nfound sr# 0. 2constant sr#                                                                                                  vt definitions                      if-found csr 4 +continue    : csr  editor   ( top bot -- ( scrolling region; {0,0} screen )   2dup is sr# base@ >r decimal                                    0 <# "r hold #s drop "; hold #s "[ hold #27 hold #> type        r> base ! ;                                                                                                                                                                -l vt if-true -->                                                              ;s                                                                                                                                                                                                  ( == charsets : g0i : g0v : g0r : g0u : g1i : g1v : g1r : g1u ) lload? (vt) forth                   if-nfound vt lload vdef                        vt     if-found g1u 4 +continue              definitions forth                                               (vt) g0i \e(B   (vt) g0v \e(O   (vt) g0r \e(U   (vt) g0u \e(K   (vt) g1i \e)B   (vt) g1v \e)O   (vt) g1r \e)U   (vt) g1u \e)K   (vt) utf \e%G   (vt) iso \e%@                                                                            lword @ 0= if-true -->                                                                                                                                 \ character set selection, dft si: g0i, so: g1v                 \ si : g0i latin1 : g0v dec vt100 : g0r ibm #437 : g0u user     \ so : g1i        : g1v           : g1r          : g1u          \ utf8-mode on : utf  off : iso                                                                                                                                                                 ( == vt cursor ====== : cur! : vt!state : cup : abscur : cure ) forth                           if-nfound vt    lload vdef      vt                              lload? (vt)                     vt definitions decimal                                          if-nfound curd     (vt) cure     \e[?25h (vt) curd     \e[?25l  if-nfound relcur   (vt) abscur   \e[?6l  (vt) relcur   \e[?6h   if-nfound vt!state (vt) vt@state \e8     (vt) vt!state \e7      if-nfound cur@     (vt) cur!     \e[s    (vt) cur@     \e[u     if-nfound cdn      (vt) cup      \e[A    (vt) cdn      \e[B     if-nfound cur-     (vt) cur+     \e[C    (vt) cur-     \e[D                                                                                                                                                                              lword @ 0= if-true -->                                                                 \ : cure : curd : abscur : relcur : vt@stat : vt!state          \ : cur! : cur@ : cup : cdn : cur+ : cur-                       ( =========================================================== )                                         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( == editor, cursor ctrl ====================== : m+ : m- : m ) editor definitions forth decimal             -l f4 if-true -->                                                                                                                                       -l m -l m+ or -l m- or 0= found? m or if-true 1 +continue  if-nfound m : m r# @ dup rot + 1023 and dup r# ! swap - ; ( n -)-l m+ if-true if-nfound m+ : m+  1 m ;                    ( -- )-l m- if-true if-nfound m- : m+ -1 m ;                    ( -- )                          -wl m -wl m+ or -wl m- or if-true ;s                                                                                                                             -->                                                                                                                                                                                                                                                                                                                                  ( == editor listings == f4 ================== : triad : index ) editor definitions forth decimal                                                                                                               -l triad 0= found? triad or if-true 2 +continue  : triad ( n -- ( display scr-s triplet which includes scr n1 )    dup 3 mod - 3 bounds do i list loop #15 message cr ;                                                    -wl triad if-true ;s                                                                                 -l index 0= found? index or if-true 2 +continue  : index ( n1 n2 -- ( display top lines of scr n1 till n2 )        1+ swap do i -4 .r 0 i .line cr loop ;                                                                  -wl index if-true ;s                                                                                                                             -->                                                                                                                                  ( ========================== : ^ == ) forth definitions decimal                                                                                       found? ^  -l ^ 0= or if-true 1 +continue  : ^ over abs over u^ 2swap 0max 1 and swap +- d+- ;                                                                                                                     lword @ 0= if-true -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \ ^     ( n1 +n2 -- dn )                                        \   ret dn := n1 to the power of n2, valid up to decimal 10^19  ( ================================= ) forth definitions decimal                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( =============================== ) forth definitions decimal                                                              -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( ================================ ) forth definitions decimal                                                          -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( ====================== : enter-do ) forth definitions decimal              lword @ 0= found? enter-do or if-true 6 +continue                                                                  0 : enter-do do [ rot drop sover ] loop ; forget enter-do                                                                       : enter-do compile 2>r [_] enter                                  compile (do) here [ dup ] literal ; immediate drop                                                                                                                   -wl enter-do if-true ;s                                                             -->                                                                                                                                                                                                  \ enter-do  ( limit start -- )(C: -- a flg=5 )                  \   enter into the body of a do..loop                           \   use { .. enter-do .. entry .. loop }                        ( == ?DO .. [ DONE ] .. LOOP =================== : ?do : done )                lword @ 0= -l done -l ?do or 0= or if-true -->                                                 if-found done ;s   if-found  ans   ans definitions decimal                         if-nfound ans forth definitions decimal                                                                                        : ?do       ( C: -- if-sys do'-sys "do -- )                       compile 2dup compile - [_] if [_] do "do ;    immediate                                                                       : done      ( C: if-sys do'-sys "do -- else'-sys "kudu )          "do ?pairs [_] loop [_] else "kudu ;          immediate                                                                                                                               -->                                                                     \ ?do       ( n1 n2 -- )                                        \   loop if n1=/=n2 else continue after {done} or {loop}, rsp.  ( == ?DO .. [ DONE ] .. LOOP =================== : ?do : done )                lword @ 0= -l done -l ?do or 0= or if-true -->                                                                    if-found  ans   ans definitions decimal                         if-nfound ans forth definitions decimal                                                                                        : loop  ( C: do-sys | if-sys do'-sys "do | else'-sys "kudu -- )   dup "do = over "kudu = over or 0=                               if drop [_] loop ;s endif             ( standard do..loop )     if [_] loop else compile 2drop endif [_] endif ;  immediate                                                                                                                                                                                                   \ done...loop                                                   \ code between {done} and {loop} will be executed if the looop  \ parameters were equal                                         ( == Linux/ELF == : elfh )    lword @ 0= -l elfh and if-true -->                                            if-found origin ;s        lload case: lload range: lload associative: lload slist:  \ -wl elf if-true : [>] scr ? blk ? [-->] ; ' [>] is -->                                                                        linux definitions forth decimal                                 if-nfound complex lload vdef                                    elf definitions forth                                                                                                           $8048000         constant origin                                0                constant elf-ehdr   \ elf main header          0                constant elf-shdr   \ section    "             0                constant elf-phdr   \ program    "             0                constant elf-sym    \ symbol     "                                                                         -->                                                                 ( == Linux/ELF == : elfh )    lword @ 0= -l elfh and if-true -->                                                                4                   cons+ elf32-addr    ( data 'types' )        2                   cons+ elf32-half                            4                   cons+ elf32-off                             4                   cons+ elf32-sword                           4                   cons+ elf32-word                            1                   cons+ elf32-char                                                                                            16                  cons+ ei-nident     ( main header identifier                                                                                                                        -->                                                                                                                                                                                                                                                                     ( =Linux/ELF= elf header = )  lword @ 0= -l elfh and if-true -->0 0 cons+ e-ident     ei-nident  \ 00 konventionszahl, version  dup cons+ e-type      elf32-half \ 016 w datentyp               dup cons+ e-machine   elf32-half \ 018 w processor-typ          dup cons+ e-version   elf32-word \ 020 d file version           dup cons+ e-entry     elf32-addr \ 024 d einsprung              dup cons+ e-phoff     elf32-off  \ 028 d fposn programm-header  dup cons+ e-shoff     elf32-off  \ 032 d fposn section-header   dup cons+ e-flags     elf32-word \ 036 d file-specifische cpu   dup cons+ e-ehsize    elf32-half \ 040 w elf-header-gre       dup cons+ e-phentsize elf32-half \ 042 w programm-header-gre  dup cons+ e-phnum     elf32-half \ 044 w anzahl prog-header     dup cons+ e-shentsize elf32-half \ 046 w section-header-gre   dup cons+ e-shnum     elf32-half \ 048 w anzahl section-header  dup cons+ e-shstrndx  elf32-half \ 050 w stringtab indx  (-?-)                          to elf-ehdr          --> \ 52           ( =Linux/ELF= program header) lword @ 0= -l elfh and if-true -->                                                                0              cons+ p-type   \ 00 the type of segment          4 p-type       cons+ p-offset \ 04 offset from BOF to segment   4 p-offset     cons+ p-vaddr  \ 08 virtual address of seg in MEM4 p-vaddr      cons+ p-paddr  \ 12 reserved for the segment's ph4 p-paddr      cons+ p-filesz \ 16 no. of bytes in the FILE imag4 p-filesz     cons+ p-memsz  \ 20 no. of bytes in the MEMORY im4 p-memsz      cons+ p-flags  \ 24 flags relevant to the segment4 p-flags      cons+ p-align  \ 28 segments alignment in memory                   4  p-align to elf-phdr                                                                                -->                                                                                                                                                                                                                                                                     ( =Linux/ELF= section header) lword @ 0= -l elfh and if-true -->                                                                0              cons+ sh-name      \  name of the section        4 sh-name      cons+ sh-type                                    4 sh-type      cons+ sh-flags     \ misc bit flags              4 sh-flags     cons+ sh-addr      \ addr of section             4 sh-addr      cons+ sh-offset    \ byte offs from BOF to 1st by4 sh-offset    cons+ sh-size      \ section size in bytes       4 sh-size      cons+ sh-link      \ other, SHN_UNDEF = 0        4 sh-link      cons+ sh-info      \ extra informations          4 sh-info      cons+ sh-addralign \ address alignment constr    4 sh-addralign cons+ sh-entsize                                                     4   sh-entsize to elf-shdr                                                                              --> \ section headers won't be loaded into memory, for execution.   \ for instance, can be viewed by mmap-ed data                   ( =Linux/ELF= symbol table )  lword @ 0= -l elfh and if-true -->                                                                0          cons+ st-name        \ Symbol name (string tbl index)4 st-name  cons+ st-value       \ Symbol value                  4 st-value cons+ st-size        \ Symbol size                   4 st-size  cons+ st-info        \ 1b Symbol type and binding    1 st-info  cons+ st-other       \ 1b Symbol visibility          1 st-other cons+ st-shndx       \ 2b Section index                            2  st-shndx to elf-sym                                                                                        -->                                                                 \ symbol headers won't be loaded into memory, for execution.    \ for instance, can be viewed by mmap-ed data.                  \ neither, section nor symbol headers, are required to running  \ an executeable program, e.g. may be removed w. 'strip' or,    \ not generated, at all, as by F4 {save"}.                      ( =Linux/ELF= elf-hash )      lword @ 0= -l elfh and if-true -->linux definitions decimal                                                                                                       : elf-hash                                                        0 swap count bounds 1- swap 1-                                  do dup 17 << i c@ + + dup 4/ xor -1 +loop ;                                                                              -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \ elf-hash      ( a -- n )                                      \   hash function from binutils/bfd/elf-strtab.c                ( =Linux/ELF= elf-ehdr spec ) lword @ 0= -l elfh and if-true -->    linux definitions elf                                       0 dup       cons+ ei-mag        elf32-char      ( e-ident )     "FLE pad 1+ ! $7f pad c! pad @ constant elfmag  ( 'magic' )                                                                       dup       cons+ ei-class      elf32-char                      bl 0 slist: elfclass none 32   64   slist;                                                                                        dup       cons+ ei-data       elf32-char                      bl 0 slist: elfdata  none 2lsb 2msb slist;                                                                                        dup       cons+ ei-version    elf32-char                      bl 0 slist: elfversion none current slist;                                  cons+ ei-pad                                                                                                -->                                                                     ( =Linux/ELF= elf-ehdr spec ) lword @ 0= -l elfh and if-true -->    linux definitions                                                                                                           0           constant et-none                    ( e-type )      1           constant et-rel                                     2           constant et-exec                                    3           constant et-dyn                                     4           constant et-core                                    0xfff0      constant et-loproc                                  0xffff      constant et-hiproc                                                                                          -->     : et [ bl 0 ] dup $fff0                                           =if drop 5 else $ffff =if 4 endif endif                         slist: none rel exec dyn core loproc hiproc slist; slist@ ;                                                                                                                                   ( == Linux/ELF ==   elf )     lword @ 0= -l elfh and if-true -->                              if-found pf-r 7 +continue         0   constant em-none        ( e-machine )                                                                                       1   constant pt-load        ( program header, type                                                                              1   constant pf-x           ( program header, flags )           2   constant pf-w                                               4   constant pf-r                                                                                                                                                       if-nfound slist: -->                                            if-found rwx -->        bl 0 slist: rwx --- --x -w- -wx r-- r-x rw- rwx slist;                                                                  -->                                                                                                                                     ( == Linux/ELF ==   elf )     lword @ 0= -l elfh and if-true -->                                              if-found .rwx -->                              lload? ub.r     lload? dumpl       : .m cr dup -11 16 ub.r ;                                       : .u @+ 0 16 db. ;              : .l @+ -11 16 ub.r ;           : .w dup w@ -11 16 ub.r 2+ ;    : .b dup c@ -4 16 ub.r 1+ ;                                                                             if-found rwx 5 +continue                                : x" and -exit -256 and "- or ;                                 : .x x" emit ;                                                  : .rwx .l dup 4- @                                                "/r over pf-r .x "/w over pf-w .x "x swap pf-x .x ;                                                                   -->     : .rwx .l dup 4- @ rwx slist@ print ;                                                                                   -->                                                                     ( == Linux/ELF ==   elf )     lword @ 0= -l elfh and if-true -->                                              if-found elfh -->                                                                 : elfh dup elf-ehdr dumpl   ( elf-header-address -- )             .m ."  e-ident:   " .l .b .b .b .b .u .u                        .m ."  e-type :   " .w     .m ."  e-machine: " .w               .m ."  e-version: " .l     .m ."  e-entry:   " .l               .m ."  e-phoff:   " .l     .m ."  e-shoff:   " .l               .m ."  e-flags:   " .l     .m ."  e-ehsize:  " .w               .m ."  e-phentsize" .w     .m ."  e-phnum:   " .w               .m ."  e-shentsize" .w     .m ."  e-shnum:   " .w               .m ."  e-shstrndx:" .w drop cr ;                                                                                      -->                                                                                                                                                                                                     ( == Linux/ELF ==   elf )     lword @ 0= -l elfh and if-true -->                                              if-found prgh -->                                                                 : .ph e-phentsize w@ over swap dumpl                              .m ."  p-type:    " .l        .m ."  p-offset:  " .l            .m ."  p-vaddr:   " .l        .m ."  p-paddr:   " .l            .m ."  p-filesz:  " .l        .m ."  p-memsz:   " .l            .m ."  p-flags:   " .rwx      .m ."  p-align:   " .l cr ;                                                                     : prgh          ( elf-header-address -- )                         >rr e-phoff @ r +                                               r r> do i e-phnum w@ 0 do j .ph loop leave loop drop ;                                                                                                                                    -->                                                                                                                                 ( == Linux/ELF ==   elf )     lword @ 0= -l elfh and if-true -->                                                                forth definitions                            if-found .prgh ;s  : .elfh elf origin elfh ;       ( main Linux/ELF header data )  : .prgh elf origin prgh ;       ( Linux/ELF program headers  )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( == Linux/ELF =============================== : save : save' ) (    minimal variant of {save'} ca. 2K, saves about 2,5K      )               lword @ 0= -l save -l save' or 0= or if-true -->                                                                  forth definitions linux                                                                                                             lload? fpos  lload? page-size lload? abort" lload? vb           if-nfound complex lload vdef                                    elf definitions forth decimal                                                                                               if-nfound pf-x  1 constant pf-x ( program header, flags )       if-nfound pf-w  2 constant pf-w                                 if-nfound pf-r  4 constant pf-r                                                                                         -->                                                                                                                                     ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                                            if-found p-flags -->      $8048000    constant origin                                     28          cons+   e-phoff                                     40          cons+   e-ehsize                                    42          cons+   e-phentsize                                 44          cons+   e-phnum                                     48          cons+   e-shnum                                      4          cons+   p-offset                                     8          cons+   p-vaddr                                     12          cons+   p-paddr                                     16          cons+   p-filesz                                    20          cons+   p-memsz                                     24          cons+   p-flags                         -->                                                                     ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                                              if-found phnum -->                                                                  : ehsize e-ehsize w@ ;                                          : phsize e-phentsize w@ ;                                       : phnum e-phnum w@ ;                                                                                                                                                                    -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                                 if-found elf-hcopy 4 +continue   : elf-hcopy     ( copy elf header + twice the 1st prg. header )   origin pad over ehsize >rr cmove                                0 origin dup e-phoff @ + pad r> + origin phsize                 2over 2over cmove drop 2dup + drop2 swap cmove drop ;                                                                                                                  if-found elf-head -->  : elf-head                          ( ELF header @pad         )   2 pad e-phnum w! 0 pad 2dup e-shnum ! e-shnum 2- !              pad ehsize pad e-phoff ! ;                                                                                               -->  \ e-shsize zeroed to preventing false display by <objcopy>      \ e-shoff  zeroed to preventing false entry address by <ald>    \          -> ald bug fixed, hp'25.11.02                        ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                                 if-found elf-phead1 5 +continue  : elf-phead1    ( 1st program header, executeable & dictionary)   pad origin ehsize +                                             here origin - over 2dup p-filesz ! p-memsz !                    pf-r pf-x or swap p-flags ! ;                                                                                                                                            if-found .text -->   : .text                     ( orig -- a u )   ( F4 prog source)   dup ehsize over phsize rot                                      phnum * + origin + here over- ;                                                                                         -->                                                                                                                                                                                                   ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                                         if-found elf-phead2 -->                                                                  : elf-phead2                ( 2nd program header, 'vmem' data )   pad origin ehsize + origin phsize +                             here palign+ over 2dup p-vaddr ! p-paddr !                      here palign+ origin - over p-offset !                           vp over 2dup p-filesz ! p-memsz !                               pf-r pf-w or swap p-flags ! ;                                                                                                                                                         -->                                                                     \ e-phoff alignment figure also applies to p-offset!                                                                                                                                            ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                decimal                       if-found .data -->  : .data                     ( a -- a u )   ( F4 data source)      u0 4+ dup@ 2* swap !                                            vb 0 +origin palign- 288 +origin over- cmove                    vb over vp cmove          forth           ( vmem, vocs )        >rr fperm (bbi) 4+ over- r> $a8 + swap cmove ( uvari )          dup voc-link +@ vb -                                            48 +origin dup palign- - rot + !          ( origin voc-link )   dup vb ' root >body pfa cfa - dup minus rot + !    \ vp ;       u0 4+ dup@ 2/ swap ! vp ;                                                                                             -->                                                                                                                                                                                                     ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                                              if-found esave -->  : esave >r  ( ch -- er )                                          elf-hcopy elf-head elf-phead1 elf-phead2                        pad dup ehsize over phsize pad phnum * +                        r -1 fwrite dup 1- 0< if message rdrop exit endif               pad .text r -1 fwrite                                           pad dup dup                                                     e-phoff @ + swap phsize + p-offset @ 0 r fpos                   vp palign+ mmapa -dup 0= abort" mmap failure " ( sz -- sz a )   r> fence @ >r last @ fence !                                    >r dup .data r -1 fwrite drop ( to em 0 ) munmap                r> r> fence ! close 6 ndrop ;                                                                                            -->                                                                  ( == Linux/ELF ======================================   save' )               lword @ 0= -l save -l save' or 0= or if-true -->                                       if-found save 3 +continue  : save                                                            w/r cre &755 new-chan openm                                     dup 1- 0< if message ;s endif elf esave ." done" ;                                                                            forth definitions                   if-found save' 2 +continue  : save'                                                           "' word 0 here count + c! here linux elf save ;                                                                               elf    \  cr .( use either, { " ./t4t" save } ) v save          forth  \  cr .(         or, { save' ./t4t' } )  v save'                \  cr cr                                                                                                                                                                                 ( == Linux/ELF ======================================= : elf! )                            lword @ 0= -l elf! and if-true -->                                                                   forth definitions linux lload? vb                                                       lload? fpos                                                     lload? elfh                                                     lload? page-size                                                lload? abort"                                                                                               lload vdef                                                      elf definitions decimal                                                                                             -->                                                                                                                                     \ auch fingerbung fr'n assembler,                             \ fr F4 alleine wr's entschieden einfacher...                 ( == Linux/ELF == elf! 2)                                                                  lword @ 0= -l elf! and if-true -->                                                                   if-nfound phaddr   : phaddr dup e-phoff @ + ;  ( orig -- n )    if-nfound ehsize   : ehsize e-ehsize w@ ;      ( orig -- n )    if-nfound phsize   : phsize e-phentsize w@ ;   ( orig -- n )    if-nfound phnum    : phnum  e-phnum w@ ;       ( orig -- n )                                                                    if-nfound phead1 : phead1 phaddr ;             ( orig -- a )    if-nfound phead2 : phead2 dup phaddr swap phsize + ; ( o -- a )                                                                 if-nfound <D>      0 +origin palign-   constant <D>                                                                                                                                     -->                                                                                                                                     ( == Linux/ELF == elf! 2)  lword @ 0= -l elf! and if-true -->                                  if-found elf-hcopy 4 +continue   : elf-hcopy     ( copy elf header + twice the 1st prg. header )   origin pad over ehsize >rr cmove                                0 origin phaddr pad r> + origin phsize                          2over 2over cmove drop 2dup + drop2 swap cmove drop ;                                                                                                                if-found elf-head -->    : elf-head                          ( ELF header @pad         )   2 pad e-phnum w!                  ( two program headers     )   0 pad e-shoff !                   ( no section headers      )   0 pad e-shentsize 0 over ! 4+ w!  (  and no string headers  )   pad ehsize pad e-phoff !          ( program header follows  ) ;                                                                                                                        -->                                                                    ( == Linux/ELF == elf! 3)  lword @ 0= -l elf! and if-true -->                                                                                                 if-found elf-phead1 5 +continue   : elf-phead1    ( 1st program header, executeable & dictionary)   pad origin ehsize +                     ( addr of 1st phead )   here origin - over 2dup p-filesz ! p-memsz !  ( program     )   pf-r pf-x or swap p-flags !                   ( executeable ) ;                                                                                                                                                                          if-found .text -->   : .text                     ( orig -- a u )   ( F4 prog source)   dup ehsize over phsize rot phnum * + origin + here over- ;                                                                                                                              -->                                                                                                                                   ( == Linux/ELF == elf! 3)  lword @ 0= -l elf! and if-true -->                                                                                                         if-found elf-phead2 -->   : elf-phead2    ( 2nd program header, 'vmem' data             )   pad origin ehsize + origin phsize +     ( addr of 2nd phead )   here palign+ over 2dup p-vaddr ! p-paddr !                      here palign+ origin - over p-offset !                           vp over 2dup p-filesz ! p-memsz !                               pf-r pf-w or swap p-flags ! ;                                                                                                                                                         -->                                                                                                                                                                                                                                                                                                                                     ( == Linux/ELF == elf! 3)  lword @ 0= -l elf! and if-true -->                                              if-found .data -->   : .data                     ( a -- a u )   ( F4 data source)      u0 4+ dup@ 2* swap !                                            vb 0 +origin palign- #288 +origin over- cmove                   vb over vp cmove                  forth   ( vmem, vocs )        >rr fperm cmo over- r> $a8 + swap cmove   ( uvari )             dup voc-link dup@ vb - +                                        48 +origin dup palign- - rot + !          ( initial voc-link)   dup vb ' root >body pfa cfa - dup minus rot + ! ( base-link )   u0 4+ dup@ 2/ swap ! vp ;                                                                                                                                                               -->                                                                   \ default sizes for dictionary &c                                                                                               ( == Linux/ELF == elf! 3)  lword @ 0= -l elf! and if-true -->                                              if-found esave -->   : eh! elf-hcopy elf-head elf-phead1 elf-phead2 ;                                                                                : esave     ( ch -- er )                                          >r eh! pad dup ehsize over phsize pad phnum * +                 r -1 fwrite dup 1- 0< if message rdrop exit endif               pad .text r -1 fwrite                                           pad phead2 p-offset @ 0 r fpos                                  vp palign+ mmapa -dup 0= abort" mmap failure "                  r> fence @ >r last @ fence !                                    >r dup .data r -1 fwrite drop munmap r> r> fence !              close 6 ndrop ;                                                                                                       -->                                                                                                                                     ( == Linux/ELF == elf! 3)  lword @ 0= -l elf! and if-true -->                                               if-found save -->   : save                                                            w/r cre &755 new-chan openm                                     1 warning !                                                     dup 1- 0< if message ;s endif                                   esave                                                           ." done:" cr pad elfh pad prgh ;                                                                                                                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                   ( == Linux/ELF == elf! 3)  lword @ 0= -l elf! and if-true -->                                                                   forth definitions                   if-found save' 2 +continue                                                                  : save'                                                           "' word 0 here count + c! here linux elf save ;                                                                               \      cr .( use either, { " ./t4t" save } )                    \      cr .(         or, { save' ./t4t' }  )                    \      cr cr                                                                                                              ;s                                                                                                                                    \ save' <spaces>ccc<'> ( -- )                                   \   save the running F4 program as an executeable binary w. the \   name ccc. uvari memory size doubled for the saved program.  ( == debugging ======================== : bpt4 : debug : bpt0 )    lword @ 0= -l debug -l bpt4 or 0= or -l bpt0 or if-true -->  forth hidden definitions forth                    \  lload vdef -l bpt4 found? bpt4 0= or if-true : bpt4 4 tdb ;                -l bpt0 found? bpt0 0= or if-true : bpt0 0 tdb ;                                                                                -l debug 0= found? debug or if-true 2 +continue                 : debug                                                           -find 0= -exit drop dup (gb) ! (see) + (gb) 4+ ! 4 tdb cr ;                                           lword @ 0= if-true -->  \ bpt4          ( -- )                          hidden          \   insert breakpoint, activating the F4 debugger by { 4 tdb }  \ bpt0          ( -- )                          hidden          \   de-activate the F4 debugger by { 0 tdb }                    \ debug     cccc( -- )                          hidden          \   set debugging bounds to include word ccc, activate { 4 tdb }( == debugging ======================================= : int3 )                           lword @ 0= -l int3 0= or if-true -->  linux definitions                                                                                    if-found int3 1 +continue  create int3 $cc c, $ff c, $e3 c, smudge \ as: <int3, jmp *ebx>                                             -wl int3 if-true ;s                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( ======================================= : vw ) if-found hw ;s if-nfound out@ out (up) - ucons out@                            0 variable #vw  ' id. defer [vw]    lload <nl>                  : (vw) 0 out ! ddup id. 32 over c@ #31 and - spaces               c@ #31 and 1+ hash11 base@ >r hex                               0 <# <nl> hold 8 0 do # loop "0x hold #> r> base ! type ;                                                                     : vw last @ 0 #vw ! ( -- ( list through all vocabularies )        enter begin t<nfa swap [vw] 1 #vw +!                            entry -dup 0= until is< [vw] ;                                                                                                : hw ' (vw) is [vw] vw ;    ( hash figures for all words )      \   identical hashes: 1- 0= ; v, u< ; d1- d0= ; h>a dr!                                                                         \ vw        ( -- )                                              \   exec deferred [vw] w. nfa of all currently defined words    ( =================================================== : dumpl )      hidden definitions forth decimal       if-found dumpl -->                                                                   8 constant #dc ( 0 < #dc < 128, configureable items per line )  4 constant #ds ( 0 < #ds <   5, configureable item size      )  1 constant #dl ( #dc #ds * (    bytes per line               )                                                                 : (da)      ( p u -- p' u' ( check & adjust bounds & counters )   128 #1 #dc max min 4 1 #ds max min * to #dl                     2dup #dl 2* 1- + #dl / #dl * swap #ds / #ds * swap ;                                                                          : (ul) 0 swap <# 0 do # # loop #> type space ;     ( one item ) : )ub( 4 (ul) ;                               ( 32bit address ) : (ub) #ds (ul) ;                             ( #ds bytes item)                                                         -->                                                                     ( ===================================================   dumpl )        forth definitions           if-found dumpl 10 +continue                                     lload? 4drop                 : dumpl (da)    ( a u -- )    ( ELF-origin \< a, 0 < a, 0 < u )   over $74 >4th minus u< if 4drop exit endif                      base@ >r hex cr 2swap drop )ub( space                           over #dl bounds do i (ub) #ds +loop cr                          bounds do                                                        cr i )ub( space                                                 #dl 1- 0 do i j + @ (ub) #ds +loop                              #dl i over 2 spaces ptype ?esc -leave                          +loop r> base ! cr ;                                                                                  lword @ 0= if-true -->  \ dumpl         ( a u -- )                                      \   hex memory dump; {#dc} items of bytesize {#ds} per line,    \   dft #dc=8, #ds=4; ranges 0 < #dc < 128, #ds = {1,2,4}.      ( == : :clists: : ================= : vb : vp : #case : case: ) forth definitions decimal                   if-found case: -->                                                                  if-nfound vb (vb) (up) - ucons vb ( base addr of vari-mem     ) if-nfound vp (vp) (up) - ucons vp ( running ptr into vari-mem )                                   -wl vb -wl vp or if-true ;s   if-nfound #case  0 constant #case ( latest runtime case: index)                                           -wl #case if-true ;s                                                             -->                                                                  \ vb        ( -- a )                                            \   ucons, base address of vari-mem                             \ vp        ( -- disp )                                         \   ucons, disp to 1st free address wrt vari-mem                \ #case     ( -- ix )                                           \   cons, while executing a {case:} list, the latest case index.( ======================== : <clist : ?cl ===== : cs! = case: ) hidden definitions forth decimal           if-found case: -->                                        if-found cs! 8 +continue   : cs! 0 >r      ( -- flg|abort-0 ( cpl items list )               enter begin -dup                                                 if [ -find ; drop sdrop ] literal <    ( whether immediate )     if cfa v, else cfa execute endif      ( cpl by cfa if not )    else v, r> 1+ >r endif                 ( or numeric figure )   entry                                                            name sfind if over ' ; - else here number 0max 1 endif         0= until 2drop r> ;                                                                                      -wl cs! if-true ;s                                                             -->   \   cpl sings list to vmem, xec imed words, terminate at ";",   \   ret flg =/= 0 if non-executeable (numeric) items compiled.  \   abort-0 if item neither found nor numeric.                  ( ======================== : <clist : ?cl =========== = case: ) hidden definitions forth decimal            if-found case: -->                                                                                                     if-found <clist 4 +continue                                     lload? vp                    : <clist                             ( cpl items list in vmem )   state@ 0= if <builds vp , endif       ( ? named word header )   vp 0. v, v, cs! over >v ! vp over- 12 - 4/ over >v 4+ ! ;                                              -wl <clist if-true ;s                                                                                                     if-found ?cl    2 +continue  : ?cl       ( disp -- xf va mx ) ( flag, list base, max index )   >v @+ swap @+ dup 0< 3 ?error ;  ( adressing err empty list )                                             -wl ?cl if-true ;s                                                             -->                                                                  ( ================================== : cs@ : ix@ ====== case: )         hidden definitions forth decimal    if-found case: -->                               -wl ix@ found? ix@ and if-true ;s                               -wl cs@ if-true lload ?cl          : ix@       ( ix disp -- value f )                                over to #case ?cl rot >r rot min 0max 4* + @ r> ;                                                         -wl ix@ if-true ;s  : cs@ ix@ -exit -execute ;                 ( ix vdisp -- .xx. )                                             -wl cs@ if-true ;s                                                          -->                                                                     \ cs@       ( ix vdisp -- .xx. | )                              \   {case:} list execution run-time:                            \   xec a case:-list item by index ix wrt list at (disp)vmem;   \   cfa below {cold}-ca won't exec, can be used to deactivating \   a particular item. ret fetched figure if type flag =/= 0.   ( =================================================== = case: ) forth definitions decimal           if-found case: 5 +continue                                                                  : case: <clist                                                    state@ if [_] literal compile cs@ exit endif drop               does>@ cs@ ;                          immediate                                                       lload [cs]  \ xtd {id+}                                         -l :clists: if-true --> \ case:         ccc {words}( -- )(X: ix -- .xx. )               \   compiles a cases list into the currently built definition or\   builds a named case:-list if executed while interpreting.   \   executes the by ix indexed list item if all were found as   \   executeable words, else returns the rsp. numeric value.     \   ix clipped to safe bounds towards either direction.         \   use {#case} to fetching the currently executed {case:} index\   data: dict [vdisp]here, vmem [flag][size][..(cs!)..]vhere   ( == : :clists: : ================= : as@ : a: : associative: ) forth definitions decimal           if-found associative: -->                                                      lload? ?cl   hidden definitions                                              : as@       ( n disp -- index )                                   ?cl 1+ >r sdrop 4- 0. r 0                                       do 2drop 4+ 2dup @ = dup -leave i loop                          swap 0= if drop r endif rdrop sdrop sdrop ;                                                       -wl as@ if-true ;s                                                                  -->                                                                                                                                                                                                                                                                                                                                                                                                     ( ============================================   associative: ) forth definitions decimal    if-found associative: 5 +continue                                                                  : associative: <clist                                             state@ if [_] literal compile as@ ;s endif drop                 does>@ as@ ;                          immediate                                                       lload [as]  \ xtd {id+}                                         -l :clists: if-true -->                                                                 \ data: dict [vdisp]here, vmem [flag][size][..(cs!)..]vhere                                                                     \ associative:  ccc {words}( -- )(X: nn --  ix  )               \   compiles a list into the currently built definition or,     \   builds a named associative:-list if xec'd while interpreting\   returns index ix of item nn found or, top+1 index.          \   executeable words inserted by cfa, numeric values unmodified( == : :clists: : ================================== : range: ) forth definitions decimal                 if-found  range: -->                                                      lload? ?cl                                                                  ' < defer <rg>                  \ dft is signed ranges          ' u< is   <rg>                  \ use unsigned ranges           ' <  is   <rg>                  \ ...or not, initially                                                                          hidden definitions                                              : rg@       ( u disp -- index )                                   ?cl 1+ >r sdrop 4- 0. r 0                                       do 2drop 4+ 2dup @ <rg> dup -leave i loop                       swap 0= if drop r endif rdrop sdrop sdrop ;                                                                           -->     \ ?cl       ( disp -- xf va mx ) ( flag, list base, max index ) \ 0 [ n1 ] 1 [ n2 ] 2 [ n3 ] 3 ; ret 1 if n1 \< xx < n2         ( ==================================================   range: ) forth definitions decimal    if-found range: 5 +continue                                                                        : range: <clist                                                   state@ if [_] literal compile rg@ ;s endif drop                 does>@ rg@ ;                          immediate                                                       lload [rg]  \ xtd {id+}                                         -l :clists: if-true -->                                                                 \ range:        ccc {words}( -- )(X: n --  ix ( r0 \< ix < r1 ) \   compiles a list into the currently built definition or,     \   builds a named range:-list if xec'd while interpreting      \   returns index ix of item nn found or, top+1 index.          \   executeable words inserted by cfa, numeric values unmodified\   comparison by deferred {<rg>}, 'signed less', by default.   \   re-define {<rg>} to {u<} for unsigned ranges.               ( == redefine indexed list item =================== : is-case ) forth definitions decimal        if-found is-case 13 +continue                                                 lload? -compile  lload case:     lload range:    lload associative:  lload [rac] case: xx 0 ; ' xx @ forget xx   range: xx 0 ; ' xx @ forget xx  associative: xx 0 ; ' xx @ forget xx                                                                                            hidden definitions                                              associative: isc #0 #0 #0 ; ' isc >body 8+ !+ !+ !              : (isc) >body swap 2+ 4* + ! ;  ( value index pfa -- )                                                                          forth definitions  ( addr. error if ccc not an indexable list ) : is-case   ( ccc, n1 n2 -- ( item n1 at index n2 to list ccc )   -find 0= 0 ?error drop dup@ isc 3 > 3 ?error [_] literal        -compile (isc) ;                  immediate                                                           -l :clists: if-true --> ( ===================================== : csz : casehead-size ) forth definitions decimal                                                                   if-found casehead-size 2 +continue  vhere case: otto ; vhere forget otto - dup vallot                                    minus constant casehead-size                                                                                                                 -wl casehead-size if-true ;s                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  lload is@                           if-found [rac] 4 +continue  : [rac] over- -exit 4+ nfa id. dup 8- @ ?cl rot dup               do 0 do @+ dup 0 16 db. j if drop                                else [ 7 ": 8 << or ] literal emit 4+ nfa id. 2 spaces endif   loop leave loop drop "]di[ ;                                     -l [cs] found? cs@ and 0= found? [cs] or if-true 2 +continue : [cs] [ ' [id] is@ sdrop -dup ] if-true literal execute          [ ' cs@ cfa ] literal [rac] ;         ' [cs] is [id]             -l [as] found? as@ and 0= found? [as] or if-true 2 +continue : [as] [ ' [id] is@ sdrop -dup ] if-true literal execute          [ ' as@ cfa ] literal [rac] ;         ' [as] is [id]             -l [rg] found? rg@ and 0= found? [rg] or if-true 2 +continue : [rg] [ ' [id] is@ sdrop -dup ] if-true literal execute          [ ' rg@ cfa ] literal [rac] ;         ' [rg] is [id]                 -wl [rac] -wl [cs] or -wl [as] or -wl [rg] or if-true ;s  --> \ [rac]-words extend {id+} names decoder for {see}, {#see} --> ================================================ : slist: )  slist:        ccc { strings }( c f -- )(X: -- a ) (i)              compiles a strings list into the currently built definition     or builds a named {slist:} list if xec'd while interpreting;    expects delimiter code and flag whether to cpl imeds @tos.      execution returns base address of stored strings array.         the procedure stores counted, <nul>-terminated strings. re      {slist@} string by index, {slist#} index by matched string.     1st string in named {slist:} cannot begin with blanks.          slist word header:                                                  [name][lfa][cfa][dodoes][disp]here ...                      strings array in vmem:                                              [arraysize][#stgs][..(en!)..]vhere ...                      per string:                                                         [countbyte][chars][nul-byte]                             NOTE: list termination w. {slist;} requires a trailing blank   ( ========================================= : slist; : slist: )         hidden definitions forth decimal   if-found slist: -->      lload place lload imed lload +place lload vp lload vplace,                                                                  : slist; ;   immediate          (        list terminator      ) 0 constant #ei                  ( : #ei  flag: xec all imeds  ) 1 constant e\sl                 ( : e\sl xpand escaped chars  ) ' .s defer fgs                  ( : fgs  slist forget-hnd     ) : (fgs) over pfa+ @ -dup 0= -exit is vp ;       ' (fgs) is fgs                                                                  : ?en           ( n vdisp -- va' mx | abort-3 if empty list )     vb + 4+ @+ 1- dup 0< 3 ?error ;                                                                                       -->                                                                     ( debug... )                                                    : h? cr here count type source drop in @ + #16 dump ;           ( ===================================================  slist: )         hidden definitions forth decimal   if-found slist: -->                                                                  : ddl           ( c -- c )          ( modify double delimiter )         if-found h? h? ( debug: show fetched string & source )    dup bl = -exit                    ( don't if dlm is <bl>    )   source drop in @ + c@ over- -exit                               here 2dup count + c! dup c@ 1+ swap c!                          dup source drop in @ + 1+ dup zcount 3 roll scan                source rot - 1+ in ! drop over- here +place                     [ smudge last @ pfa cfa , smudge ] ;                                                                                  -->                                                                                                                                     \ ddl           ( c -- c )                                      \   recusively append next to stg @here if double dlm char found( ===================================================  slist: )         hidden definitions forth decimal   if-found slist: -->                                                                  : ee?           ( -- flg )         ( find terminal "slist;" )     here c@ 4 < -dup -exit                                          here count + 4- @ "mune = if -1 exit endif     ( dlm was "; )   here c@ 5 < -dup -exit                                          here count + 5 - @+ "mune = swap c@ "; = and if -1 exit endif   here count s" slist;" match swap 0= if 0and exit endif          5 - 0max in -! -1 ;                                                                                                   -->                                                                                                                                     \ ee?           ( c -- c flg )                                  \   check whether terminator in string @here, ret -1 if found.  \   adjust @in by trailing string length.                       ( ===================================================  slist: )         hidden definitions forth decimal   if-found slist: -->                                                                  : en?           ( c -- flg )       ( 'slist:' string evaluator)   here sfind 0dup 0= -exit                    ( just a string )   imed and 0= if 0and exit endif              ( ordinary word )   dup [ ' \ cfa ] literal = if 1 swap execute exit endif          here w@ 1- 0=       ( next line, end if next after is empty )   if 1 swap cfa execute here w@ 1- 0= if minus endif exit endif   #ei 0= if 0and exit endif                   ( other immed   )   1 swap cfa execute ;                                                                                                  -->     \ analyzing strings @here, ret flg:                             \    0 if supposed to be compiled;                              \    1 if immediate word which was executed, or {\}, <nul>;     \   -1 if stg ends w. the "slist;" list delimiter.              ( ===================================================  slist: )         hidden definitions forth decimal   if-found slist: -->                                                                  : en!           ( c f -- n a |abort-0 ( cpl stg list )            to #ei >r 0 vhere            ( pass imed flag w. #ei to en? )   begin r word ee? 1+          ( -1 by ee? if terminator found)   while r ddl drop en? 0= if drop 1+ here vplace, endif           repeat rdrop scount + 1+ ;   ( ret {vhere} after last stg   )                                                            -->                                                                  \ en!           ( c f -- n a )                                  \   store by char c delimited strings to vmem until "slist;"    \   found or eof; execute immediate forth words if f =/= 0;     \   ret no. of stg-s and address after last compiled string.    \   continue sing string if double dlm <c> =/= <bl> encountered.\   pfa+4:[vdisp]here vmem:[size][stg-count][..(cs!)..]vhere    ( ===================================================  slist: )         forth definitions decimal          if-found slist: -->                                             lload? 4drop         : slist#    ( a va -- n )                   ( index by string )   ?en                                       ( ? valid list )      >rr >r swap scount rot                                          enter begin + 1+ r> 1- >r                                       entry scount 4 ndup s= 0= r 0< or until                         4drop r> r> swap - ;                      ( ret max - count )                                                         -->                                                                                                                                                                                                     \ slist#    ( a va -- n )                                       \   find string at a in {slist:} and ret the rsp. index,        \   ret last index if string not found.                         ( ===================================================  slist: )         forth definitions decimal          if-found slist: -->                                                                  : slist@    ( ix va -- a )                  ( string by index )   ?en rot min 0max                          ( abort if empty  )   enter begin swap scount + 1+ swap                               entry 1- dup 0< until drop ;                                                                                          -->                                                                                                                                                                                                     \ slist@    ( ix va -- a | )            (i)                     \   {slist:} list of strings, ret stg by index - re {en!}, {en@}\   ret 1st string on -ve, last on +ve index overflow.          \   data: dict [vdisp]here, vmem [size][#stgs][..(en!)..]vhere  \   strings by en! in vmem: [count|0][ chars ][0]               ( ===================================================  slist: )         forth definitions decimal          if-found slist: ;s                                                                   : slist:                            hidden                        state@ 0= if <builds vp , endif                                 vp >r                                                           0. v, v, en! vb - r - r vb + ! r vb + 4+ ! r>                   state@ if [_] literal ;s endif drop                             ' fgs last @ pfa [forget]                                       does>@ ;                              immediate                                                        -wl slist: if-true ;s                                                             -->                                                                                                                                                                                                                                                                  ( ========================================= : slist, : :slist ) forth definitions decimal                                                   found? :slist found? slist, or if-true 7 +continue  lload? place lload? vp                                          if-nfound e\sl 0 constant e\sl                                                                                                  : slist,    ( p a -- )                                            vp >r vhere off scount dup 2+ vallot vhere 4- off               e\sl if dup -rot r >v e\stg rot over- minus vallot endif        r >v place vp r> - over >v 1 over 4+ +! +! ;                                                           -wl slist, if-true ;s                                                             -->  \ slist,    ( p a -- )                                          \   store string at a to vmem pointed to by disp at             \   slist-header in vmem at disp p wrt vmem base;               \   expand bash-style escapes if cons {e\sl} =/= 0.             ( ========================================== : slist : slist" ) forth definitions decimal       if-found :slist 7 +continue              found? slist found? slist" and if-true 6 +continue                                                                     if-nfound slist, lload slist,                                   if-nfound slist  : slist [_] string slist, ;    immediate       if-nfound slist" : slist" [_] " slist, ;        immediate                                                                                                   -wl slist -wl slist" or if-true ;s                                                             -->                                                                  \ slist ( c ccc, p -- p )               (i)                     \   append by chr c delimited string ccc to {slist:} or {:slist}\   list of strings definition pointed to by ptr p into vmem.   \ slist"  ( ccc, p -- p )               (i)                     \   as {slist} but, with double quote '"' unmodifiable delimiter( ========================================= : slist; : :slist ) forth definitions decimal                   \ re slist:                                                                         if-found  :slist 3 +continue                                    : :slist    ( ccc, -- p )                                         state@ 0= if <builds vp , endif vp >r 0. v, v, r>               state@ if dup [_] literal endif 4 csp +! does>@ ;  immediate                                                                                                                          -->                                                                                                                                                                                                                                                                     \ :slist    ( ccc, -- p )               (i)                     \   executing: set up a named strings list header               \   compiling:  - don't use while compiling (yet) -             ( ========================================= : slist; : :slist ) forth definitions       if-found ;slist lword @ 0= if-true -->                                              if-found ;slist ;s                                                                                          if-found fgs 2 +continue                if-nfound fgs ' .s defer fgs          \ : fgs slist forget-hnd  : (fgs) over pfa+ @ -dup 0= -exit is vp ;    ' (fgs) is fgs                                                                     : ;slist 0 wv, drop ' fgs last @ pfa [forget] ; immediate                                                                                                                                                                               lword @ 0= if-true -->                                                                  \ ;slist    ( p -- )                                            \   terminate {:slist} type list of strings,                    \   install forget handler                                      ( ======================================== : vt-voc ========= ) forth definitions                                                                                                               -wl vt-voc if-true if-nfound vt     lload vdef  ;s                                                                                                                      lword @ 0= if-true -->                                                                                                                                                                                                                                          lword @ 0= if-true -->                                          ;s                                                                                                                                                                                                                                                                                                                                                      ( ==== : edinsb : scrixb : cargsb : xargsb : bitflags : bits? )                              -l f4 found? quadb or if-true -->   0 constant winchb \ : winchb set after reception of SIGWINCH    1 constant edinsb \ "expect" editting insert/~overwrite mode    2 constant scrixb \ set if xec as script for implicite 'bye'    3 constant cargsb \ un-evaluated commandline args exist         4 constant xargsb \ set if executeable cmd-line args passed.    5 constant lcdepb \ : lcdepb letter case independent {-find} &c 6 constant incfib \ : incfib whether input from {chain}ed file  7 constant evalxb \ : evalxb whether input by {evaluate}        8 constant edlnfb \ : edlnfb line editting w. default text     17 constant ranumb \ : ranumb                                   19 constant floatb \ : floatb persistent 'ranum' numeric input  20 constant quadb  \ : quadb persistent 'quad'  numeric input                                            -wl bits? if-true -->  \ (bits)    uvari, bit-flags                                    ( == ucons ====================== : bits? )  -l f4 if-true -->  hidden definitions forth                     if-found bits? ;s  : -e -dup 0= -exit emit ;      if-nfound floatb lload bitflags  definitions                                                     : bits? (bits) >r 0 hidden  \ display uvari {(bits)} settings     winchb r bit if -e ."  SIGWINCH"   ", endif                     edinsb r bit if -e ."  ins"        ", endif                     scrixb r bit if -e ."  script"     ", endif                     cargsb r bit if -e ."  args"       ", endif                     xargsb r bit if -e ."  xargs"      ", endif                     lcdepb r bit if -e ."  case indep" ", endif                     incfib r bit if -e ."  chain"      ", endif                     evalxb r bit if -e ."  evaluate"   ", endif                     floatb r bit if -e ."  fp input"   ", endif                     quadb r> bit if -e ."  quad int."  0  endif drop ;                                                                            ( == { lload f4 } end ============================= : usrpath ) forth definitions                                                                           if-found usrpath 1 +continue        s" /lib:/usr/lib:/usr/local/lib" #4096 stg usrpath                                                                                                                                                                                                      ;s                                                                                                                                                                                                                                                                                                                                      \ usrpath ( -- a )                                              \   by {fname} searched last and, yet undefined stg variable    \   {f4path} if non-empty, searched _instead_ of PATH vari,         usrpath                                                     ( ================================== : .t' : t' : ti0 : tick0 )                                lword @ 0= if-true 12 +continue                                        if-found ti0 3 +continue  : ti0       ( -- dn )                                             1. 0. sp@ 4- dup 8- sp@                                         tick 2>r sys nanosleep tick 2>r 4drop 4drop 2r> 2r> d- ;                                                                      if-nfound tc0   0. 2constant tc0                                if-nfound tick0 ' tc0 defer tick0                                                                   if-found !tick 1 +continue  : !tick is< tick0 tc0 ti0 d+ 2 tc0 d0= - 0 d/ 2dup to tc0 ;                                       ' !tick is tick0      -->     \ ti0       ( -- dn )                   (s)                     \   cpu timing figure, no. of clock pulses per second           \ tick0     ( -- dn )                   (d)                     \   double cons which returns {ti0}; 1st time xec initiates ti0.( ==================================   .t'   t'   ti0   tick0 )                                lword @ 0= if-true 12 +continue                                        if-found t' 5 +continue   100000 =: [ti]                                                  ' @csp defer t0                                                 : t' -find 0= -exit !csp drop cfa dup tick 2>r                    do [ti] 0 do j execute t0 loop leave loop tick 2r> d- ;                                                                       lload? evaluate                                                 : .t' t' tick0 " f." evaluate ;                                                                                                 blk @ b/scr / dup 1- list list                                                                                                                                                                                                                                                                                                  ( ed, ans-4th ================== : f4e : f4ed : figed : f4ans )                                                   lload? lfile"                                                                 -l f4e   if-true    lload? f4ed  edit   ;s                      -l f4ed  if-true if-nfound f4e   lfile" f4e.scr"   f4e   ;s     -l figed if-true if-nfound figed lfile" figed.scr" figed ;s                                                                     -l f4ans if-true if-nfound f4ans lfile" f4ans.scr" f4ans ;s                                                                                                                                                                                                                                                                                                                                     \ figed -> f4e   ( -- ) fig-forth screen-file line editor       \ f4e   -> f4ed  ( -- ) F8 screen-file full screen editor       \ f4ans ( -- ) extend F4 to (some) ANS-4th compliance           ( : f.p. : f4f : f4z                                          )                                                  lload? lfile"                                                                  0 -wl f.p.     found? df      0= and or                         -l f4f or if-true if-nfound f4f   lfile" f4f.scr"   f4f   ;s                                                                    -wl f.p.                                                        -l f4z or if-true if-nfound f4z   lfile" f4z.scr"   f4z   ;s                                                                                                                                    \ f4f  ( -- ) rational numbers arithmetics                      \ f4z  ( -- ) complex extension to rational numbers arithmetics                                                                                                                                                                                                                                                                 ( : f4p : printing : f4m : memory : arrays                     )                                                 lload? lfile"                                                                  0 -wl printing found? printer 0= and or                         -l f4p or if-true if-nfound f4p   lfile" f4p.scr"   f4p   ;s                                                                    0 -wl arrays  found? array   0= and or                            -wl memory  found? heapmem 0= and or                          -l f4m or if-true if-nfound f4m   lfile" f4m.scr"   f4m   ;s                                                                                                                                                                                                                                                                                                                                    \ f4m  ( -- ) host system memory de/allocation & access         \ f4p  ( -- ) printer control, simultaneous stdout output       ( == buchhaltung ==================== : bms : bh : f4bh : f4b )                                                                  lload? f4      \ common words                                   lload? f4m     \ heapmem & array                                lload? f4f     \ f.p. arithmetics                               lload? f4p     \ printer control                                lload? f4ed    \ editor                                        -wl bms if-true if-nfound bhm lfile" bms.scr" bms ;s  \ : bms                                                                   if-nfound f4b lfile" f4b.scr" f4b \ buchhaltung                                                                                                                                                                                                                                                                                 \ bh   ( -- )                                                   \   lload programm zur kontokorrent-buchhaltung                 ( 8kanal spannungsmessung, LTC1090 : ADC, conrad-bausatz 979797)                                                                512           constant b        ( skalierungsfaktor D,out     ) 0             constant vout     ( dezimale darstellung D,out  ) 5             constant ref      ( referenzspannung [V]        ) $3fc          constant serport  ( erste port-addresse         )                                                                 : portbit   ( n1 -- n2 ( n1: bit-flag n2: bit-wert            )   serport pc@ $fe and serport pc!           ( lo DTR & RTS    )   if serport pc@ $fd and serport pc! endif  ( D,in            )   serport pc@ 1 or serport pc! serport 1+ pc@ 16 and 0> ;                                                                                                                               -->                                                                                                                                                                                                     ( 8kanal spannungsmessung, LTC1090 : ADC, conrad-bausatz 979797)                                                                : D,in 1- 0max $07 and 1+ %111101110000 or ;    ( n1 -- n2 )                                                                    : V,read    ( n1 -- n2 ( n1: channel# n2: read tension figure )   D,in 1 >loc 512 0                                               -1 11 do l0 i bit abs portbit over * loop   ( mul accu          leave loop                                                      1 loc> ;                                                                                                                      \ D,in  ( n1 -- n2 )                                            \   kanalnummer n1 in bits 0 bis 3 der steueradresse n2                                                                                                                                                                                                                                                                         \ : BNF Parser                        (c) 1988 B. J. Rodriguez  0 constant success                                              : <bnf success                                        ( -- )      if in @ r>>r here >r >r exit endif rdrop ;                    : bnf> r> success                                        ( -- )   if 2rdrop else r> dp ! r> in ! endif >r ;                     : | success if rdrop 2rdrop exit endif                   ( -- )   r> r> r> 2dup >r >r in ! dp ! 1 to success >r ;               : bnf: : smudge compile <bnf ;  immediate            ( -- sys ) : ;bnf [_] bnf> [_] ; smudge ;  immediate            ( sys -- ) : @token source in @ /string drop c@ ;                 ( -- n ) : +token 0= -exit 1 in +! ;                            ( f -- ) : =token success                                       ( n -- )   if @token = dup success ! +token exit endif drop ;            : token <builds c, DOES> c@ =token ;          ( n -- (X: a -- )                                                                 \ : Mini-OOF                                          12apr98py : method <builds over v, swap 4+ swap           ( m v -- m' v )   does>@ over @ + @ execute ;                 ( ... o -- ... )  : var <builds over v, +                    ( m v size -- m v' )   does>@ + ;                                     ( o -- addr )  : class dup 2@ ;                ( class -- class methods vars ) : end-class                           ( class methods vars -- )   <builds here >r v, dup v,                                       8 =if else 8 do ' noop v, 4 +loop endif                         4+ dup 4+ r> rot @ 8 /string move ;                           : defines [_] ' 4+ >body @ + ! ;                ( xt class -- ) : new here over @ allot swap over ! ;            ( class -- o ) : :: [_] ' 4+ >body @ + @ , ;               ( class "name" -- ) 4 variable object 8 v,                                                                                                                                                                          ( == test +continue == : +cotest )  20 variable n cr 0 . blk ?                                                cr 1 . blk ?           cr  2 . blk ? n @ -1 n +! 10 < if-true 4 +continue              cr  3 . blk ? 1 .                                               cr  4 . blk ? 2 . n @ . ." -3: " -4 n +! -3 +continue           cr  5 . blk ? 3 .                                               cr  6 . blk ? 4 .                                               cr  7 . blk ? 5 .                                               cr  8 . blk ? 6 .                                               cr  9 . blk ? 7 .       cr ."  -ende- " scr @ list ;s           cr 10 . blk ?                                                                                                                                                                                                                                                                                                                                                                              ( == \e-string test == : stgbuftest                           )                                       lload +to-stg lload stg                                                                   0. 4K stg buf                                                   s" ene mene muh, eia weia weck..."         1024 stg muh         s" probIER"                                dup  stg probier     s" \e[7mhuhu\55hallo\54\40tateh!\e[27m\n" 1024 stg vt          s" \n\t1\62\-3 - "                    minus +to-stg vt                                                                          cr .( test "match" w. 'muh'=") muh print .( " and " eia" => ")  muh count 2dup " eia" count match rot rot 2drop type                                                     .( ") cr               muh count 2dup " meia" count match rot rot 2drop type     .( ") s"   base" over #10 swap c! dup stg be       cr ( test 'help' )                                                                                                                                 ( == upper/lower case chars conversion == : cc : chartest     ) forth definitions decimal   lword @ 0= -l cc 0= or if-true -->                      lload? e\print         if-found cc ;s       0 constant [cc]     \ testing multi-byte chars                  : <cc> do i #127 = i $9b = or                                      if #12 spaces                                                   else i [cc] 8 << or ddup 3 over base@ < + .r emit space dup      uc-lc dup rot - if " \e[7m:\e[27m" e\print else space endif     dup 3 i base@ < + .r emit 2 spaces                             endif i 8 mod 7 = -cr                                          loop cr ;                                                     : cc            ( -- ( test upper/lower case chars conversion )   cr ." upper/lower case convertible chars, by <uc-lc>:" cr       8 0 <cc> 26 16 <cc> 32 28 <cc> 256 32 <cc> ;                                                                                                                                                  ( == test 'lload'ing defn not in index line ==  'ein-versuch' ) decimal                                                                                                                         : ein-versuch                                                     xy swap [ latest count 31 and sdrop ] literal                   + 1+ swap at-xy                                                 ." einer definition ohne indexzeile" cr ;   ( spielt... )                                                                       cr ein-versuch                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( == test pow2? ===================================== : t2pow )                lword @ 0= -l t2pow 0= or if-true ;s                                                                             1 cons+ p2x                                                     : t2pow                                                           #32 0 do 1 i << p2x dup . pow2? . cr loop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( ==== loop parameters =========================== : looptest ) forget /i\                                                      : /i\ 4* 2* rp@ + 8+ ; : /ll /i\ 4+ @ ; : /ni /i\ @ ;           : /t                                                              2 1 do                                                           3 2 do                                                           4 3 do                                                           0 do dup "# emit . ." i:" i . ."  :n: " dup dup ni . /ni .                                    ."  :l: " dup dup ll . /ll .      i 2 > -leave cr loop                                           leave loop                                                     leave loop                                                     leave loop drop ;                                                                                                             : /tt 4. do i 22 /t cr loop ;          /tt                                                                                      ( == examples/test =============================== : slistest ) forth definitions                                                              lword @ 0= -l slistest 0= or if-true ;s done...                 lload slist: lload debug                                                                                         if-nfound bell : bell bel ; immediate                                                                                           if-nfound pp hex ", 1 slist: pp HERE, bell,Bell,end,,At,slist;  if-nfound oo hex ", 1 slist: oo here, BELL,BELL,End,,at,slist;  debug ddl ' slist: (gb) 4+ ! cr                                                                                                 : tt dup 2+ 0< 0= if dup . [ bl 0 ] slist:  here bel  ballodenna  muh! oder-duh slist; slist@ print else . endif cr bel ;                                                                       debug slist@ cr 0 tt cr 1 tt cr 2 tt cr 3 tt cr 4 tt cr 5 tt cr                                                                 ( == examples/test ============================== : :slistest ) forth definitions                                lload? :slist                                                                  : ?slist swap 0 do i i . over slist@ print cr loop >v @+ . ? ;                                                                  :slist aa slist" Otto " slist" hat'n " slist - "Bauch". - ;slist                                                                                                                                " balla bella" aa slist# aa ?slist cr                                                                                                                                                                                                                                                                                                                                                           \ ?slist    ( maxindex listptr -- )                             \   { " irgendwas" slistname slist# slistname ?slist }          ( == examples/test ================================ : fghtest ) lload dumpl    lword @ 0= -l fghtest 0= or if-true ;s done...   : bbb bel .s depth 2 < -exit over id. dup nfa id. cr ;                                                                          : bim  bel ." -BIM- " ;                                         : bimf ." FBIMF " bbb ; ' bimf defer bimh forget: bimh bim      : bam  bel ." -BAM- " ;                                         : bamf ." FBAMF " bbb ; ' bamf defer bamh ' bamh ' bam [forget]                                                                 hex ." bim: " ' bim nfa . ' bimf . ' bimh . cr                      ." bam: " ' bam nfa . ' bamf . ' bamh . cr                  \ { forget bim } triggers execution of                          \     1) {bamf} by {bamh} w. ( bim-nfa bam-nfa bamh-pfa -- .. ) \     2) {bimf} by {bimh} w. ( bim-nfa bim-nfa bimh-pfa -- .. ) \   (fl)@->.      .--> previously def'd other handlers link addr\ codemem: `-> [ prevlink ][ word-nfa ][ hnd-pfa ]              ( == examples/test =============================== : casetest )                lword @ 0= -l casetest 0= or if-true ;s                         lload case: lload debug                                                                                          if-nfound bell : bell bel ; immediate                           case: pp 0 HERE bell vlist .s bel ;                             \        0   1         2    3  4                                                                                                               debug ?cl (gb) 4+ @ debug cs@ (gb) 4+ !                                                                          sp>  0 pp .s    sp> 1 pp .s     sp>  2 pp .s    sp> 3 pp .s     sp>  4 pp .s    sp> 5 pp .s     sp> -2 pp .s                    sp> 66 pp .s  cr sp>                                                                                                                                                                                                                                            ( == examples/test ============================= : assoctest )                 lword @ 0= -l assoctest 0= or if-true ;s                        lload associative: lload debug                                                                                   if-nfound bell : bell bel ; immediate                           associative: emma here bell 1 #2 3 #4 5 #6 7 #8 9 bel #11 ;     \                  '   -/-  '  2 '  4 5  6 7  8 9 '    11                      debug ?cl (gb) @ debug as@ (gb) !                                                                                hex 1 emma . 2 emma . 3 emma . 4 emma . cr                                                                                                                                                                                                                                                                                                                                                                                                                      ( == examples/test ============================== : rangetest )                lword @ 0= -l rangetest 0= or if-true ;s                        lload range: lload debug                                                                                         range: ina $10 $20 $30 ;                                        \         0   1   2   3                                                        debug rg@                                                                                      ' < is <rg>       hex -1 ina .  0 ina .  1 ina . .(  0 0 0 ) cr                        9 ina . 10 ina . 11 ina . .(  0 1 1 ) cr                       19 ina . 20 ina . 21 ina . .(  1 2 2 ) cr                       29 ina . 30 ina . 31 ina . .(  2 3 3 ) cr ' u< is <rg>      hex -1 ina .  0 ina .  1 ina . .(  3 0 0 ) cr                        9 ina . 10 ina . 11 ina . .(  0 1 1 ) cr                       19 ina . 20 ina . 21 ina . .(  1 2 2 ) cr                       29 ina . 30 ina . 31 ina . .(  2 3 3 ) cr                   ( == examples/test ================================= : katest )                          lword @ 0= -l katest 0= or if-true ;s  marker katest                                                   (asci) (up) - ucons [ai]                                        : [k>c] >r 2dup - [ai] r> >> #255 and < ;                       : k>c  0  0 [k>c] -exit drop   \ -- ch 0                                    1  8 [k>c] -exit drop   \ -- ch 1                               0 16 [k>c] -exit drop   \ -- ch 0                               1 24 [k>c] sdrop ;      \ -- ch 1                   : k>a dup dup uc-lc =/= ;                                                                                                                                                                                                                                                                                                                                                                                                                                       ( == examples/test ================================= : nitest ) ( check fetching indexed loop count and indexed loop limit    )                                                                 lload marker marker nitest lload ddup                           : t 4* 2* rp@ + 8+ ; : /ll t 4+ @ ; : /ni t @ ;                 : t                                                               2 1 do                                                           3 2 do                                                           4 3 do                                                           0 do dup ." #" . ." i:" i . ."  :ni: " ddup ni . /ni .                                      ."  :ll: " ddup ll . /ll .          i 2 > -leave cr loop                                           leave loop leave loop leave loop drop ;                                                                                     : tt 5. do i i 4* t cr loop ; cr tt                                                                                              ;s ( == examples/test ========================== : forthword )                                                                     nee, natrlich nicht!                                           das 'forthword' steht fr irgendein forth-wort, zu dem          sich mit {help} die betr. erklrung anzeigen lt...                                                                            auch { help help } liefert was, nmlich den hinweis,            wie die betr. texte anzuordnen sind, damit sie mit              {help} gelesen werden knnen.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ( == examples/test =============================== : linktest )                                                                                                                                 lload >link                                                     4 vhere 3 and - vallot                                          sp> 0 variable z vp debug -lk here (gb) 4+ !                    vp 8 vallot z >link vp 8 vallot z >link vp 8 vallot z >link     vp 8 vallot z >link vp 8 vallot z >link vp 8 vallot z >link                                                                     : ?lk enter begin >v dup 16 b. entry @ dup 16 b. -dup 0= until ;                                                                z ?lk                                                                                                                           \ sp> z @ >v  @ >v @ >v @ >v @ z link> drop                                                                                                                                                     ( == examples/test =============================== : hashtest ) forth definitions                                 lload? debug                                                                  : h11    ( a u -- n )                                             >r 0 swap                                 \ n a [ u             enter begin                                                      c@+ rot 4 << + dup 0xf0000000 and        \ n a -- a n'          -dup if >rr #24 >> xor r> not and endif swap                   entry r> 1- >rr 0< until rdrop drop ;                                                                                         debug h11                                                       s" _start" 2dup h11 . hash11 .                                                                                                                                                                                                                                                                                                  ( == examples/test =============================== : heaptest )  lload? array   lload? debug                                     lload? heapmem                                                                                                                  0. 2constant du vp $10 align to vp                             400K -vallot vhere $80 to du du 8* -1 fill                      2  4 array kkk  10  20 dim kkk 0 0 kkk .                        2 10 array xxx 100 200 dim xxx 0 0 xxx .                                                                                           5K heapmem mm ' mm nfa pfa+ constant pp                      #240K heapmem nn ' nn nfa pfa+ constant qq                      debug -lk see heapmem +  (gb) 4+ ! hex                                          heap?                                           mm 4th-heap .   heap?                                           nn 4th-heap .   heap?                                                                                                           ( == examples/test ============================ : recursetest ) lload? mem? lload? +stk forget rc \ test recursion & ds de/alloc0 constant rd                                                   : rc 2dup 2dup d1- sdrop 0< 0= if d1- recurse endif d+          if-found  rd rd -exit depth to rd ;     : ?rd rd 12. to rd .r ; if-nfound rd                      ;     : ?rd ;                 (pb) 4+ @ base@ hex mem? base ! 2M +sp drop                     cr 1000000 ddup 1+ u* d2/ -20 d.r s->d rc 12 d.r   ?rd          cr  100000 ddup 1+ u* d2/ -20 d.r s->d rc 12 d.r   ?rd          cr   10000 ddup 1+ u* d2/ -20 d.r s->d rc 12 d.r   ?rd          cr    1000 ddup 1+ u* d2/ -20 d.r s->d rc 12 d.r   ?rd          cr     100 ddup 1+ u* d2/ -20 d.r s->d rc 12 d.r   ?rd          cr      10 ddup 1+ u* d2/ -20 d.r s->d rc 12 d.r   ?rd          cr       2 ddup 1+ u* d2/ -20 d.r s->d rc 12 d.r   ?rd cr        base@ swap hex mem? (pb) 4+ @ - +stk 2drop mem? base ! \ d .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   