================= < F4 real numbers extension > ================                                                                        'ranum' for F4 : f4f -at- lxhp . in-berlin . de                    Copyright 2003 h-peter recktenwald Berlin                     non-commercial "QT-Lizenz 1.0" applies, plus:            patentrechtliche verwertung ohne einschraenkung vorbehalten.                                                                                        Tu 2003-06-17 11:11                                             Sa 2003-07-12 10:47                                             We 2004-01-06 15:04   modified+extended                                                                                                                                   requires the f4 kernel compiled with assembly flag "_rx_" =/= 0,i.e. w. doubles, locals, and provisional words for 'ranum'.     depends on the value of +1 for the 'true' flag, two-s complementrepresentation of -ve integers and, little endian data order.   --> ====== < = : ranum = F4 real numbers' extension > ====== <--                                                                 The 'float' word set provides the basic arithmetic, logical,    type conversion & numerical output routines necessary for       handling real numbers (i.e. rational numbers including improper fractions).                                                                                                                     Basic routines derived from FSL #46 'vulgar.fth' (re f4 docs):     Vulgar Maths Words. Version FSL1.1  23rd April 1996             by Gordon Charlton: gordon -at- charlton.demon.co.uk                                                                         Throughout the suite "real number" is referred to by the name   'ranum' and, 'rn' or 'f' in the stack diagram.                                                                                 [ 'vulgar fraction' ist ein 'gewoehnlicher bruch', 'vulgar' fuer  sich heiszt dasselbe wie im deutschen, drum der name 'ranum' ]--> ============= < F4 real numbers extension > ============ <--                                                                 A 'ranum' is implemented as the quotient of two double          integers on data stack in the order                                           @nos:numerator @tos:denominator.                                                                                  The numerator and denominator are always (almost) prime.                                                                        The numerator is evaluated as a signed integer, and the         denominator as a non-negative (unsigned 63 bit) integer.                                                                        Numbers too large to be represented are indicated by the        denominator {0.} which will propagate through a program.                                                                                                                                                                                           : r1 r2 --> 6 load ;s ======= < F4 real numbers extension > ============ <--                                                                 Zero is represented by ( 0. 1. ).                               Numbers which cannot be represented exactly are rounded by a    mediant rounding scheme.                                                                                                        On the subject of accuracy and precision is is worth noting     that rational representations are capable of maintaining total  accuracy with simple fractions, such as one third, which can't  precisely be represented in a binary 'floating point' scheme.   arithmetic using a rational representation & mediant rounding   is not subject to cumulative rounding errors, as it "tends to   make the intermediate rounding errors cancel out..."            (Knuth, Seminumerical algorithms, 4.5.1 Fractions, pg 315).                                                                                                                        : r2        (  ERROR MESSAGES  ) -->                                        EMPTY STACK                                                     DICTIONARY FULL                                                 HAS INCORRECT ADDRESS MODE                                      ISN'T UNIQUE                                                                                                                    DISC RANGE ?                                                    FULL STACK                                                      DISC ERROR !                                                                                                                                                                                                                                                                                                                                                                                                                                                    F4 real/rational numbers extension            hp - JULY 12, 2003(  ERROR MESSAGES  ) -->                                        COMPILATION ONLY, USE IN DEFINITION                             EXECUTION ONLY                                                  CONDITIONALS NOT PAIRED                                         DEFINITION NOT FINISHED                                         IN PROTECTED DICTIONARY                                         USE ONLY WHEN LOADING                                           OFF CURRENT EDITING SCREEN                                      DECLARE VOCABULARY                                                                                                                                                                                                                                                                                                                                                                                                                                              F4 real/rational numbers extension            hp - JULY 12, 2003( =============== < F4 real numbers extension > ============== )if-found hlp! hlp!                   ( def filename for {help} )forth definitions decimal     \ : --> blk ? [-->] ; immediate                                                                   \ convenience:                                                  xlload !hlp xlload? f" xlload? help if-nfound save' xlload elf!                                                                 \ required:                                                     xlload  locals  xlload? palias  xlload? >move< xlload  :clists: xlload? string  xlload? l@n     xlload? vb     xlload? [f]      xlload? is@     xlload  ud.     xlload? q+     xlload? enter-do xlload? @order  xlload? dpl@    xlload? floatb                  --> \ debugging:                                                xlload? q.      xlload? uq.     xlload? ud.                     xlload? m.      xlload? .       xlload? debug  xlload? w                                                                        ( =============== < F4 real numbers extension > ============== )lload? -0           if-found hlp! hlp!                                                                                          -0  1-      constant max-int                                     0 -0      2constant -0.                                        -0  1+      constant min-int                                    -0. 1. d-  2constant max-2int                                   -0. 1. d+  2constant min-2int                                   : norm# -0. 0. ;                                                                                                        -->     \ max-int   ( -- n )        maximal sing integer                \ min-int   ( -- n )        minimal sing integer                \ -0        ( -- n )        sing sign bit mask                  \ max-2int  ( -- d )        maximal double integer              \ min-2int  ( -- d )        minimal double integer              \ -0.       ( -- d )        double sign bit mask                ( =============== < F4 real numbers extension > ============== )                                                                if-nfound -rot   : -rot rot rot ;             ( 1 2 3 -- 3 1 2 )                                                                \ doubles:                                                      if-nfound 2rot   : 2rot 2>r 2swap 2r> 2swap ; ( 1 2 3 -- 2 3 1 )if-nfound 2-rot  : 2rot 2swap 2>r 2swap 2r> ; ( 1 2 3 -- 3 1 2  if-nfound d1+    : d1+ 1 m+ ;                 ( d -- d' )       if-nfound d1-    : d1- -1 m+ ;                                                                                                  \ quad integers:                                                if-nfound qm+    : qm+ s->d s->d s->d q+ ;    ( q n -- q' )     if-nfound q1+    : q1+ 1 qm+ ;                ( q -- q' )       if-nfound q1-    : q1- -1 qm+ ;               ( q -- q' )       if-nfound q-     : q- qminus q+ ;             ( q1 q2 -- q )                                                              -->   ( =============== < F4 real numbers extension > ============== )                                                                \ quad logic:                                                   if-nfound q<     : q< q- 2sdrop 0< sdrop ;  ( q1 q2 -- flg )    if-nfound q>     : q> 4swap q< ;            ( q1 q2 -- flg )    if-nfound q0=    : q0= or or d0= ;          ( q -- flg )        if-nfound q0<    : q0< 0< 2sdrop sdrop ;    ( q -- flg )        if-nfound q0>    : q0> q1- q0< 0= ;         ( q -- flg )                                                                        \ octuple dstack:                                               if-nfound 8drop  : 8drop 8 ndrop ;          ( q -- )            if-nfound 8dup   : 8dup 8 ndup ;            ( q -- q q )        if-nfound 8swap  : 8swap 8 nswap ;          ( 1 2 -- 2 1 )      \ if-nfound 8over  : 8over 3 4pick 3 4pick ;  ( 1 2 -- 1 2 1 )  \ if-nfound 8sover : 8sover 8swap 8over ;     ( 1 2 -- 2 1 2 )                                                            -->   ( =============== < F4 real numbers extension > ============== )forth definitions                                                                                                               if-nfound float vocabulary float immediate 2nd-voc float forth                                                                  vocabulary fp immediate     \ : fp words, persistent ranum input1 floatb << ' fp >body pfa 4+ or!   \ set vflag for lit compiler                                                                                                                        -->                                                                                                                                                                                                     \ float ( -- )                                                  \   vocabulary operations on floating point real real numbers   \ fp    ( -- )                                                  \   un-praefixed synonymous ranum words, voc not in search chain( =============== < F4 real numbers extension > ============== )                                                                : fpvoc? floatb context@ l>pfa 4+ bit ;                         : -flt floatb (bits) bit ranumb (bits) bit or 0= ;                                                                              ' noop constant 'inter       \ : inter previous [inter] xec vec.: >inter ' [inter] >body @ is 'inter ;                          : inter> 'inter is [inter] ; \ restore [inter] xec vec.                                                                 -->                                                                     \ fpvoc?    ( -- f )                                            \   tf if fp flag set in context vocabulary definition block    \ -flt      ( -- f )                                            \   false if persistent or single ranum flgs set in uvari (bits)\ >inter    ( -- )                                              \   save current [inter] xec vector, before ranum or quad input ( =============== < F4 real numbers extension > ============== )float definitions decimal                                       12      constant #prec  \ fp format max fractional digits, {f#} ",      constant #dp    \ fp format fraction marker by {f.}     0 0=    constant ftrunc \ fp format, suppress trailing zeroes   12      constant #round \ max. f.p. digits for rounding                                 \ by: round>, roundf, f0~, f~, fround5  4       constant #frac  \ 'n/d' display format max digits, {v.j}16      constant rnsiz  \ bytes' size of a 'ranum'              32      constant rdsiz  \ bytes' size of a double 'ranum'       16      cons*   rnbytes \ : rnbytes bytes size of a 'ranum'     32      cons*   rdbytes \ : rdbytes size of double 'ranum'      ' 4*    palias  rncells \ : rncells per ranum                   ' 8*    palias  rdcells \ cells per double ranum, complex                                                               -->     \ : #prec : #dp : #round : #frac : ftrunc : rnsiz : rdcells     ( =============== < F4 real numbers extension > ============== )                                                                associative: n] 00 32 ;         ( : n] string terminating char) "- n] constant no-n]            ( : no-n]  [qnum] termination ) : ?n dup c@ bl > ;              (   tf if more chars follow   )                                                                 associative: "dp ", ". "- "+ "/ ; ( : "dp "+ "- "/  other mark) : ?dp dup c@ "dp [ 0 "dp ] literal < ;  ( tf if dp mark found )                                                                 associative: "exp "f "p "n "µ "m 00 "k "M "G "T "P "% ;         -0 "exp   constant no-exp       ( : no-exp : "exp mutiplier   ) no-exp 1- constant vh-exp       ( : vh-exp "%" multiplier idx )                                                         -->     \ "exp      ( char -- n )                                       \   exponential marker by char corresponding to @base figure:   \   "2:binary, "8:octal "e,"a:decimal "g:sedecimal (etc...)     ( =============== < F4 real numbers extension > ============== )                                                                if-found  16*   ' 16* palias floats             1 +continue                     : floats 4 << ;                                                 rdsiz cons* dfloats                             if-found  16+   ' 16+ palias rnsiz+             1 +continue                      rnsiz cons+ rnsiz+                                              rdsiz cons+ rdsiz+                             if-found  16-   ' 16- palias rnsiz-             1 +continue                rnsiz minus cons+ rnsiz-                                                                                     -->     \ floats  ( n -- n' ( mul by size in bytes of a 'ranum' item   )\ dfloats ( n -- n' ( mul by size in bytes of a double 'ranum' )\ rnsiz+  ( n -- n' ( add size in bytes of a 'ranum' item      )\ rdsiz+  ( n -- n' ( add size in bytes of a double 'ranum'    )\ rnsiz-  ( n -- n' ( subtract size in bytes of a 'ranum' item )( =============== < F4 real numbers extension > ============== )                                                                if-found  4dup           ' 4dup palias fdup     1 +continue                              : fdup 4 ndup ;                        ' 8dup  prim?    if-true ' 8dup palias f2dup    1 +continue                              : f2dup 8 ndup ;                                                                                       if-found  4drop          ' 4drop palias fdrop   1 +continue                              : fdrop 4 ndrop ;                      ' 8drop prim?    if-true ' 8drop palias f2drop  1 +continue                              : f2drop 8 ndrop ;                                                                             -->     \ fdup   ( f -- f f )                                           \ f2dup  ( f1 f2 -- f1 f2 )                                     \ fdrop  ( f -- )                                               \ f2drop ( f f -- )                                             ( =============== < F4 real numbers extension > ============== )              found? 4pick found? 4roll and if-true 6 +continue                                   context 2@ hidden definitions if-nfound 3+ 3 cons+ 3+                                         : frp dup abs 4* 3+ swap +- dup ; context 2!                                                                                    if-nfound 4pick : fpick frp do 4. do j pick loop leave loop ;   if-nfound 4roll : froll frp do 4. do j roll loop leave loop ;                                                                   if-found  4pick ' 4pick palias fpick                            if-found  4roll ' 4roll palias froll                                                                                                                                                    -->                                                                     \ fpick ( fn .x. fm +n|-n -- fn .x. fm | fm .x. )               \ froll ( fn .fx. fm +n|-n -- .fx. fm fn | fm fn .fx. )         ( =============== < F4 real numbers extension > ============== )                                                                if-found  4over ' 4over palias fover    1 +continue                             : fover 1 fpick ;                                                                                               if-found  4sover ' 4sover palias fsover   ( TUCKATUCK - ?? nee, if-nfound 4sover : fsover fswap fover ;   ( nich bonni's ranch!                                                                 if-found  4sdrop ' 4sdrop palias fsdrop                         if-nfound 4sdrop : fsdrop fswap fdrop ;                                                                                 -->                                                                                                                                     \ fover  ( f1 f2 -- f1 f2 f1 )                                  \ fsover ( f1 f2 -- f2 f1 f2 )                                  \ fsdrop ( f1 f2 -- f2 )                                        ( =============== < F4 real numbers extension > ============== )                                                                if-found  4rot  ' 4rot palias frot      1 +continue                             : frot 2 froll ;                                                                                                if-found  4-rot ' 4-rot palias -frot    1 +continue                             : -frot -2 froll ;                                                                                              if-found  4swap ' 4swap palias fswap                            if-nfound 4swap : fswap 4 nswap ;                                                                                       -->                                                                                                                                     \ frot  ( f1 f2 f3 -- f2 f3 f1 )                                \ -frot ( f1 f2 f3 -- f3 f1 f2 )                                \ fswap ( f1 f2 -- f2 f1 )                                      ( =============== < F4 real numbers extension > ============== )if-found  4>r   : f>rr compile 4dup compile 4>r ;   1 +continue     : f>rr compile 2>rr compile 2over compile 2>r ;   immediate if-found  4>r   ' 4>r palias f>r        1 +continue                 : f>r compile 2>r compile 2>r ;                   immediate if-found  4r>   ' 4r> palias fr>        1 +continue                 : fr> compile 2r> compile 2r> ;                   immediate if-found  4r    ' 4r palias fr          2 +continue             : fr compile 2r> compile 2r compile 2over compile 2>r ;                                                               immediate : frdrop 4 [_] literal -compile nrdrop ;              immediate                                                           -->   \ f>rr  ( rn -- rn ) (R: --- rn )                               \ f>r   ( rn -- ) (R: -- rn )                                   \ fr>   ( -- rn ) (R: rn -- )                                   \ fr    ( -- rn ) (R: rn -- rn )                                ( =============== < F4 real numbers extension > ============== )                                                                : f! rnsiz s>m ;    : 4! #16 s>m ;                              : f@ rnsiz m>s ;    : 4@ #16 m>s ;                                                                                              : f2! rdsiz s>m ;                                               : f2@ rdsiz m>s ;                                                                                                                                                                       -->                                                                     \ 4!    ( f p -- )      store a quad item                       \ 4@    ( p -- f )      fetch a quad item                       \ f!    ( f p -- )      store a ranum item                      \ f@    ( p -- f )      fetch a ranum item                      \ f2!   ( df p -- )     store double ranum                      \ f2@   ( p -- df )     fetch double ranum                      ( =============== < F4 real numbers extension > ============== )if-nfound s0@      s0 (up) - ucons s0@                          : fl@  rnbytes s0@ swap-  f@ ;                                  : fl!  rnbytes s0@ swap-  f! ;                                  : fl2@ rdbytes s0@ swap- f2@ ;                                  : fl2! rdbytes s0@ swap- f2! ;                                                                                                                                                          -->                                                                     \ fl@   ( n -- rn )     fetch local ranum rn by index n.        \ fl!   ( rn n -- )     store local ranum rn by index n.        \ fl2@  ( n -- rd )     fetch local double ranum rd by index n. \ fl2!  ( rd n -- )     store local double ranum rn by index n.                                                                 sp> -1 forth 20 >loc "llun 0 l! 1 1 l! 2 2 l! 3 3 l! 4 4 l! 5 5 l! 6 6 l! 7 7 l! 8 8 l! 5 fl@ l0 60 dumpl s0 @ #16 b. 20 loc>   ( =============== < F4 real numbers extension > ============== )context 2@ hidden definitions                                                                                                   : flit r> dup float rnsiz+ >r f@ ;                                                                                              : [flit]        ( a ca -- a' flg ( extension to {id+}, debugger)  [ ' [id] is@ sdrop -dup ] if-true literal execute               ' flit cfa over- -exit                                          4+ nfa id. dup f@ 2swap 0 d.r "/ emit ud. rnsiz + "]di[ ;                                                                     ' [flit] is [id]                                                                                                                context 2!                                              -->                                                                                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : fdepth depth 4/ ;  \ : fdepth depth [ 1 rncells ] literal / ;                                                                 : fvariable                  ( ccc, dz dn -- ) ( C: -- a )        0 variable rnsiz 4- vallot vhere rnsiz- f! ;                                                                                  : fconstant                  ( ccc, dz dn -- ) ( X: -- dz dn )    vp >r fvariable r> , does>v f@ ;                                                                                              : fliteral state@ 0= -exit   ( dz dn -- )      ( X: -- dz dn )    compile flit here rnsiz allot f! 0 cmc ! ;        immediate                                                                                                                           -->                                                                                                                                     ( =============== < F4 real numbers extension > ============== )  xlload? q. xlload? uq.        @order hidden definitions                                                                       : 2flit r> dup rdsiz+ >r f2@ ;                                                                                                  : [2flit]       ( a ca -- a' flg ( extension to {id+}, debugger)  [ ' [id] is@ sdrop -dup ] if-true literal execute               ' 2flit cfa over- -exit 4+ nfa id.                              dup f2@ 4swap q. "/ emit uq. rdsiz+ "]di[ ;                                                                                   ' [2flit] is [id]                                                                                                                                               !order         -->                                                                                                                                                                                                              ( =============== < F4 real numbers extension > ============== )                                                                : f2depth depth 8/ ; \ : f2depth depth [ 2 rncells ] literal / ;                                                                : 2fvariable                  ( ccc, dz dn -- ) ( C: -- a )       vp 0 variable rnsiz rnsiz+ 4- vallot >v f2! ;                                                                                 : 2fconstant                  ( ccc, dz dn -- ) ( X: -- dz dn )   vp >r 2fvariable r> , does>v f2@ ;                                                                                            : 2fliteral state@ 0= -exit   ( dz dn -- )      ( X: -- dz dn )   compile 2flit here rnsiz rnsiz+ allot f2! 0 cmc ! ; immediate                                                                                                                         -->                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : f,   here rnsiz allot f! ;        \ cpl into dictionary       : 2f,  here [ rnsiz 2* ] literal allot f2! ;                                                                                    : fv,  vp rnsiz vallot >v f! ;      \ cpl into vmem             : 2fv, vp [ rnsiz 2* ] literal vallot >v f2! ;                                                                                  max-2int 1.   fconstant   max-df    \ : max-df max. double ranum-1. max-2int  fconstant   max-quad  \ : max-quad integer                                                                                                                                -->     \ f,    ( rn -- )               2f,  ( rd -- )                  \   cpl sing/double ranum to current top of dictionary.         \ fv,   ( rn -- )               2fv, ( rd -- )                  \   cpl sing/double ranum to current top of variables memory.   ( =============== < F4 real numbers extension > ============== )@order hidden definitions                                                                                                       : (qnum)        ( q a -- q' a' )                                  enter begin 2-rot base@ uqsm* drop            \ flag arith:      2rot swap >r s->q q+ r> dpl@ 0< 0= dpl +!    \ '0=' tf = 1     entry 1+ dup c@ base@ digit 0= until drop ;                                                                                   : [^*] rot >r swap umq^ uq* 4drop r> ;      ( q dpl# rx -- q' )                                                                                                                         -->                                                                                                                                     \ (quad)    ( q a -- q' a' )                    hidden          \   accumulate numeric string(a,u) value to quad q until invalid\   char found, ret address of the invalid char.                ( =============== < F4 real numbers extension > ============== )                                                                : [qe]          ( qn a -- qn' a' )                                dup c@ base@ h>a xor -$21 and if dup c@ "e - -exit endif        dup 1+ c@ "- = >rr +                       \ '='  : tf = +1     1+ ?n 0= if rdrop exit endif 1-                                 0. rot (number) sdrop swap                                      r> if dpl@ 1- 0< 2* 1- + dpl +! exit endif \ '0<' : tf = +1     dup 0< 0= + dpl@ 0< - base@ [^*] ;         \ '0=' : tf = +1                                                           -->                                                                     \ [qe]  ( qn a -- qn' a' )                      hidden          \   radix exponent mark is the hypothetical digit corresponding \   to @base or decimal E (e); evaluates tolerant of no digit   \   following after the marker char, possibly followed by a "-" \   minus sign. exponent defaults to zero if not given.         ( =============== < F4 real numbers extension > ============== )                                                                : [qm]      ( qn a -- qn' a' )                                    ?n 0= -exit dup c@ "exp no-exp < 0= -exit                       c@+ "exp vh-exp                                                 =if -1 dpl@ 0< - else 0 "exp - 3 * endif   \ '0<' : tf = +1     dup 0< if 1- dpl -! exit endif #10 [^*] ;                                                                             -->                                                                                                                                                                                                                                                                     \ [qm]  ( qn a -- qn' a' )                      hidden          \   reads trailing char as multiplier by exp()10, re {"exp}:    \     f:-15 p:-12 n:-9 µ:-6 m:-3 %:-2 k:3 M:6 G:9 T:12 P:15     \   -ve exp. added to @dpl and no other modification            ( =============== < F4 real numbers extension > ============== )                                                                : [qnum] ( a -- q f )                                             a>b >rr base@ >r c->s base ! >r 0. 0. r> -1 dpl ! (qnum)        enter begin 0 dpl ! (qnum) entry ?dp 0= until                   [qe] [qm] r> base ! c@ n] no-n] < -4 roll r> q+- 4 roll 0= ;                                                                                                              !order      -->                                                                     \ [qnum] ( a -- q f )                           hidden          \   convert numeric string to quad and ff; f=/=0 on failure.    \   max quad: decimal +/-170141183460469231731687303715884105727\   re {[qm]} for trailing multiplier chars.                    \   re {[qe]} for trailing @base radix based exponentation.     \   a multiplier char may also follow after exponentation.      \   e.g. { quad $22g2M  quad #870400e4 q- q0= } returns 'true'  ( =============== < F4 real numbers extension > ============== )                                                                : >quad ( a -- q tf | a ff )                                      dup a>b base@ >r base ! [qnum] r> base !                        if 4drop 0 exit endif dpl@ 0max dpl ! 1 5 roll drop ;                                                                                                                                 -->                                                                                                                                                                                                                                                                                                                                                                                                     \ >quad   ( a -- q tf | a' ff )                                 \   convert string at a to quad q and true flag; on failure,    \   ret address a' of string at 1st invalid char and false flag ( =============== < F4 real numbers extension > ============== )                                       @order forth definitions : {;}                                                             [ 1 ranumb << 1 quadb << or not ] literal (bits) and! [;] ;                                          ' {;} is ;      !order   : >ch rot dup 2swap scan drop swap - ;                                                                                  -->     \  if is< [inter] is< [number] endif [;] ; immediate ' {;} is ; \ ;                                                             \   re-vectored <semis> to preventing errors due to erroneously \   un-used {quad} or {df} input modifiers - which can be very  \   difficult to find.                                          \ >ch   ( a n1 ch -- n2 )                                       \   search string at addr of length n1 for character ch. If it  \   is present then n2 is the position of the first occurence of\   of ch in the string, 0 for 1st char, else n2 := n1.         ( =============== < F4 real numbers extension > ============== )                                                                : foverflow                 ( rn -- -1|0|1 )                      d0= swap +- sdrop ;                                                                                                           : fovf? fdup foverflow ;    ( rn -- rn flg )                                                                                                                                            -->                                                                                                                                                                                                                                                                     \ foverflow ( rn -- flg )                                       \   flg := sgn(rn|1), if overflow indicator, else 0.            \ fovf?     ( rn -- rn flg )                                    \   push ovf flag, leave ranum on stack.                        ( =============== < F4 real numbers extension > ============== )                                                                : reduce ( rn -- rn )                                             fovf? -exit                                                     fdup dgcd 2dup 1. d= if 2drop exit endif                        2>rr ud/mod 2sdrop 2swap 2r> d/ 2swap ;                                                                                       : dfreduce                                                        ?q0= -exit                                                      8dup qgcd 4dup q1- q0= if 4drop exit endif                      4>r 4r uq/ 4swap 4r> q/ 4swap ;                                                                                       -->                                                                     \ reduce    ( rn -- rn )                                        \   normalises sing ranum by reduction (div num & den by gcd)   \   f{ double-integer  numerator denominator }                  ( =============== < F4 real numbers extension > ============== )                                                                : q>d?    ( q -- +d flg )                                         or over 0< or ;                                                                                                       -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ q>d?    ( q -- +d flg )                                       \   truncates quad q to non-negative double +d and leaves flag  \   flg =/= 0 if the conversion failed.                         ( =============== < F4 real numbers extension > ============== )\ locals: prev.numerator denominator numerator prev.denominator                                 ( : pnum! : p.den!            ) 1 l2@n p.num    1 l2!n p.num!   ( : p.num previous numerator  ) 2 l2@n den      2 l2!n den!     ( : den : den! nenner dn      ) 3 l2@n num      3 l2!n num!     ( : num : num! zähler dz      ) 4 l2@n p.den    4 l2!n p.den!   ( : p.den previous denominator)                                                                 : (setloc 0.  0.  1.  1. 0 9 (locals ;                                                                                          : next! ( +f -- )                                                 den p.den! den! num p.num! num! ;                                                                                      -->    \ next! ( +f -- )                                               \   make the new approximation the current approximation, and   \   the current approximation the previous approxinmation.      ( =============== < F4 real numbers extension > ============== )                                                                : >num? ( uq -- +d flg )                                          num uqd* or >r p.num 0. q+ q>d? r> or ;                                                                                       : >den? ( uq -- +d flg )                                          den uqd* or >r p.den 0. q+ q>d? r> or ;                                                                               -->                                                                     \ num>?  ( uq -- +d flg )                                       \ den>?  ( uq -- +d flg )                                       \ the next approximation to the num ud is the current one       \ multiplied by uq, which is the next num in cont'd fraction of \ the ranum being approximated, plus the previous approximation \ tf if next approximation cannot be represented as a non-      \ negative double (ie, approximation is as good as it can get). ( =============== < F4 real numbers extension > ============== )                                                                : (fnormal)  ( rd -- rd' )                                        enter begin 4over ?q0= 0= if q/mod endif                         4dup >num? if next! 2drop exit endif                            2-rot >den? if next! exit endif                                 next! 4swap                                                    entry ?q0= until ;                                                                                                    -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : fnormal ( rd -- rn )        ( rd: qn/qz -> rn: dn/dz )          4swap >rr qabs 4swap                                            (setloc (fnormal) 4drop 4drop p.num r> d+- p.den locals) ;                                                                                                                            -->     \ fnormal ( rd -- rn )                                          \ return the normalised ranum which most closely approximates   \ the signed double ranum passed to it. Returns 1. 0. if the    \ double ranum was too large and positive to be represented or  \ -1. 0. if too large and negative. Numbers too small to be     \ represented are rounded to zero (0. 1.).                      \ Works by generating approximations from successive numbers in \ the continued fraction expansion of df, until no more numbers \ are available, or overflow occurs.                            ( =============== < F4 real numbers extension > ============== )                                                                : snum>? ( ud1 ud2 -- ud3 flg )                                   2>r num ud* p.num d+ 2r> 2over du< ;                                                                                          : sden>? ( ud1 ud2 -- ud3 flg )                                   2>r den ud* p.den d+ 2r> 2over du< ;                                                                                  -->                                                                     \ snum>? ( ud1 ud2 -- ud3 flg )                                 \ sden>? ( ud1 ud2 -- ud3 flg )                                 \   the next approximation to the num ud3, is the current       \   approximation multiplied by ud1, which is the next number   \   in the continued fraction of the ranum being approximated,  \   plus the previous approximation. flag is true if the next   \   approximation is greater than ud2. - locals ref re {normal} ( =============== < F4 real numbers extension > ============== )                                                                : (fround)  ( rn -- dx dx )                                       2>r enter begin                                                  2over 2dup or if d/mod endif                                    2dup  2r snum>? if next! 2rdrop exit endif                      2swap 2r sden>? if next! 2rdrop exit endif                      next! 2swap                                                    entry 2dup d0= until 2rdrop ;                                                                                                                                                         -->                                                                                                                                                                                                                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : fround ( rn +dn -- rn' )                                        2>r fovf? if 2rdrop exit endif                                  (setloc  pick2 dup 1 l! 0< if nos-dminus endif 2r>              (fround) 4drop p.num 1 l@ d+- p.den locals) ;                                                                                                                                         -->                                                                                                                                                                                                                                                                     \ fround ( rn +dn -- rn' )                                      \   returns an approximation to the ranum rn such that neither  \   the numerator nor the denominator exceeds the +ve double dn \   or, the signed ovf indicator if conversion was not possible.( =============== < F4 real numbers extension > ============== )                                                                : round>    ( -- ud )                                             base@ #round 1+ u^ -1 m+ ;                                                                                                    : roundf    ( rn -- rn' )                                         reduce round> fround ;                                                                                                -->                                                                                                                                                                                                                                                                     \ round>    ( -- ud )                                           \  approximation limit for {fround} etc.                        \ roundf    ( rn -- rn' )                                       \   round to 1 + the number of fractional digits set w. #round. ( =============== < F4 real numbers extension > ============== )                                                                : df->f ( rd -- rn )                                              norm# ?uqcmp 0> >r 4rot >rr qabs ?uqcmp 0<                      r> swap >r q+- 4swap 4drop 4swap                                2r> and if 2drop 2sdrop reduce exit endif fnormal ;                                                                           : f->df 2swap d->q 2rot 0. ;                                                                                                                                                            -->                                                                     \ df->f ( rd -- rn )                                            \   returns the ranum that most closely approximates the        \   unnormalised double ranum rd.                               \ f->df ( rn -- rd )                                            \   extend sing to double size ranum.                           ( =============== < F4 real numbers extension > ============== )                                                                : f->d ( rn -- dn )                                               df/mod 2swap 2drop ;                                                                                                          : f->s ( rn -- n )                                                2dup d0= >r f->d r> if 1+ swap endif drop ;                                                                           -->                                                                                                                                     \ f->d ( rn -- dn )                                             \   return the floored signed integral component of ranum rn    \   as a double integer. ovf returns the rsp, signed maximum.   \ f->s ( rn -- n )                                              \   return the floored signed integral component of ranum rn    \   as a single integer. ovf returns the rsp, signed maximum.   ( =============== < F4 real numbers extension > ============== )                                                                1. 2constant d->f                                                                                                               : s->f  ( n -- rn ) s->d d->f ;                                 : ss->f ( n1 n2 -- rn ) swap s->d rot 0 ;                       : f>floor f->d d->f ;                                                                                                                                                                   -->     \ s->f      ( n -- rn )                                         \ d->f      ( d -- rn )                                         \   promote sing/double integer to ranum equivalent rn.         \ ss->f     ( n1 n2 -- rn )                                     \   convert pair of sings (signed n1 / unsigned n2) to ranum.   \ f>floor   ( rn -- rn' )                                       \   leave the floored integer part of a ranum.                  ( =============== < F4 real numbers extension > ============== )                                                                : f0= d1- q0= ;                         ( rn -- flg )           : ?f0= fdup f0= ;                       ( rn -- rn flg )                                                                        : f0~ fdup f0= if fdrop 1 exit endif roundf f0= ;                                                                               : f0=/= d1- 2or or ;                    ( rn -- flg )                                                                   -->     \ f0=   ( rn -- flg )                                           \   flag is true if ranum is exactly zero.                      \ f0=/=                                                             ret tf if rn is not exactly zero                            \ f0~   ( rn -- f )                                             \   ret tf if rn is zero within the range determined by the     \   rounding figure of at most #round fractional zero digits.   ( =============== < F4 real numbers extension > ============== )                                                                : fsgn 2swap dsgn 2swap or -exit -0 or ; ( f -- -1|0|1,-0 ovf )                                                                 : f0< 2drop 0< sdrop ;                  ( f -- flg )                                                                            : fabs 2swap dabs 2swap ;               ( f -- f' )                                                                                                                                     -->                                                                     \ fsgn ( f -- -1|0|1, -0 ovf )                                  \   signum of a ranum, ORed w. -0 (m.s.bit set) if ovf indicator\ fabs ( rn -- |rn| )                                           \   return absolute value of ranum argument.                    \ f0<  ( rn -- flg )                                            \   tf if ranum rn is negative.                                 ( =============== < F4 real numbers extension > ============== )                                                                : frac      ( rn -- rn' )                                         2dup d0= -exit 2swap 2over df/mod 2drop 2swap ;                                                                               : fint      ( rn -- rn' )                                         2dup d0= -exit f->d d->f ;                                                                                                    : fsplit    ( rn -- rn1 rn2 )                                     fdup 2dup or if f->d d->f fswap endif frac ;                                                                          -->     \ frac  ( rn -- rn' )                                           \   fractional component of ranum f                             \ fsplit    ( f -- f1 f2 )                                      \   return floored integral component of ranum f as ranum f1    \   and the fractional component as non-negative ranum f2.      ( =============== < F4 real numbers extension > ============== )                                                                : f+m                                   ( rn1 rn2 -- dzs dns )    2rot 4dup umd* 4>r 2rot md* 4swap md* q+ 4r> dfreduce ;                                                                       : f+ f+m df->f ;                        ( z1 n1 z2 n2 -- rn )                                                                   : f+! >rr f@ f+ r> f! ;                                                                                                                                                                 -->     \ f+    ( rn1 rn2 -- rn )                                       \   add two floats using naive algorithm, generating double     \   length result, then round to single.                        \ f+!    ( rn a -- )                                            \   add rn to ranum item at address a.                                                                                          ( =============== < F4 real numbers extension > ============== )                                                                : f1+ 2>rr >rr d+ dup 0< r> 0< 0= and 0=        ( rn -- rn' )     if 2r> exit endif 2r d- 2r> [ 1. 1. ] fliteral f+ ;                                                                           : f1- 2>rr >rr d- dup 0> r> 0> 0= and           ( rn -- rn' )     if 2r d+ 2r> [ 1. 1. ] fliteral f+ exit endif 2r> ;                                                                                                                                   -->                                                                                                                                                                                                     \ f1+   ( rn -- rn' )                                           \   increment ranum by one.                                     \ f1-   ( rn -- rn' )                                           \   decrement ranum by one.                                     ( =============== < F4 real numbers extension > ============== )                                                                if-found  nos-dminus ' nos-dminus palias fminus                 if-nfound nos-dminus : nos-dminus qminus 2not ;                 if-nfound fminus     : fminus -compile nos-dminus ;  immediate                                                                  if-found  nos-qminus ' nos-qminus palias dfminus                if-nfound nos-qminus : nos-qminus 4swap qminus 4swap ;          if-nfound dfminus    : dfminus -compile nos-qminus ;  immediate                                                                                                                         -->                                                                     \ fminus  ( rn -- rn' )                                         \   negate ranum.                                               \ dfminus ( rd -- rn' )                                         \   negate double ranum.                                        ( =============== < F4 real numbers extension > ============== )                                                                : f- fminus f+ ;                        ( f1 f2 -- f )                                                                          : f+-  0< 0= -exit fminus  ;                ( rn n -- rn' )     : df+- 0< 0= -exit dfminus ;                ( rd n -- rd' )                                                                                                                             -->                                                                                                                                                                                                                                                                     \ f-    ( rn1 rn2 -- rn )                                       \   subtract ranum v2 from ranum v1 giving ranum result.        \ f+-    ( rn n -- rn' )                                        \   apply sign of sing n to ranum.                              ( =============== < F4 real numbers extension > ============== )                                                                : fint? pick2 >r fsplit r> 0< s->f q- q0= ;                                                    \ fsplit fover f0< s->f f- f0~ ; : fsimplify ( rn +dn -- rn' )                                     2>r fsplit 2r> fround f+ ;                                                                                            -->                                                                     \ fint? ( rn -- rn f )                                          \   push true flag if signed rn is integral.                    \ fsimplify ( rn +dn -- rn' )                                   \   returns an approximation to the ranum rn such that neither  \   the numerator or the denominator of the fractional component\   of rn exceeds the positive integer dn.                      \ z.B. zahnradpaar fuer drehzahlverhaeltnis 1:0,529127 bei      \   je max 300 zaehnen: { df 0,529127 300. fsimplify d. d. }    ( =============== < F4 real numbers extension > ============== )                                                                : f= 2rot d= >r d= r> and ;             ( rn rn -- flg )                                                                        : f~ f- f0~ ;                           ( rn1 rn2 -- f )                                                                                                                                -->                                                                                                                                                                                                                                                                     \ f=    ( rn rn -- flg )                                        \   tf if the two ranum arguments are exactly equal.            \ f~    ( rn rn -- flg )                                        \   ret tf if the two ranums are equal within a range determined\   by the rounding figure of at most #round fractional digits. ( =============== < F4 real numbers extension > ============== )                                                                : f< 2-rot md* 4swap md* 4swap q< ;     ( f1 f2 -- flg )                                                                        : f> fswap f< ;                         ( f1 f2 -- flg )                                                                                                                                -->                                                                                                                                                                                                     \ f< ( f1 f2 -- flg )                                           \   tf if ranum f1 less than ranum f2.                          \   ff if either argument is the overflow condition.            \ f> ( f1 f2 -- flg )                                           \   f is TRUE if ranum v1 is greater than ranum v2.             \   ff if either argument is the overflow condition.            ( =============== < F4 real numbers extension > ============== )                                                                : fm^2                                  ( f1 -- df2 )             2dup umd* 2rot 2dup md* 4swap ;                                                                                               : fm^3                                  ( f1 -- df2 )             pick2 >r fabs 2dup 2dup umd* 2rot uqd* 2>r                      3 2roll 2dup 2dup umd* 2rot uqd* 2r> 2or d0= 0=                 if 4>r 4drop [ 0. 0. ] fliteral 4r> endif 4swap r> df+- ;                                                                     : f^2 fm^2 df->f ;                      ( f1 -- f2 )            : f^3 fm^3 df->f ;                      ( f1 -- f2 )                                                                    -->     \ f^2   ( rn1 -- rn2 )                                          \ f^3   ( rn1 -- rn2 )                                          \   ranum rn raised to the power of two, three                  ( =============== < F4 real numbers extension > ============== )                                                                : f*m 2rot umd* 4swap md* 4swap ;       ( f1 f2 -- df )         : f* f*m df->f ;                        ( f1 f2 -- f3  )                                                                        : 1/f pick2 d+- 2swap dabs ;            ( f1 -- f2 )                                                                                                                                    -->                                                                                                                                                                                                                                                                     \ f*    ( rn1 rn2 -- rn )                                       \   multiply two ranums                                         \ 1/f   ( f -- f' )                                             \   the reciprocal of a ranum.                                  ( =============== < F4 real numbers extension > ============== )                                                                : fm/ 3 2roll md*                       ( f1 f2 -- df )           4swap >rr dabs umd* r> df+- ;                                 : f/ fm/ df->f ;                        ( f1 f2 -- f )                                                                          : /fm 2-rot md* 4swap                   ( f1 f2 -- df )           2swap >rr dabs 2swap umd* r> df+- ;                           : /f /fm df->f ;                        ( f1 f2 -- f )                                                                  -->                                                                                                                                     \ f/ ( f1 f2 -- r )                                             \   divide ranum f1 by ranum f2.                                \ /f     ( f1 f2 -- r )                                         \   divide ranum f2 by ranum f1 (f/ w. oprs in reversed order). ( =============== < F4 real numbers extension > ============== )                                                                : ff/mod                                                          fdup frot fdup f0< s->f f+ fsplit -frot /f ;                                                                                  : fz/mod fdup f0< >r fabs fswap fdup f0< >r fabs ( [sg,d sg,d )   fsplit                              r r> r> xor ;                                                                                                                                     -->                                                                     \ fz/mod ( f1 f2 -- f3 f4 )                                     \   integral, rounded towards zero quotient f4 and remainder f3 \   of division f1 by f2                                        \ ff/mod ( f1 f2 -- f3 f4 )                                     \   integral, floored quotient f4 and remainder f3              \   of division f1 by f2                                        ( =============== < F4 real numbers extension > ============== )                                                                : f2/                                                             dup ddup + xor 0< pick4 1 and 0= or   \ den -> ovf or even num  if 2swap d2/ 2swap exit endif d2* ;   \ ovf is zero result                                                                    : f2*                                                             over 1 and 0= pick3 ddup + xor 0< or  \ even den or num -> ovf  if d2/ exit endif 2swap d2* 2swap ;   \ ovf into ovf indicator                                                        -->                                                                                                                                     \ f2/   ( rn -- rn' )                                           \   signed divide rn by two, round near zero.                   \ f2*   ( rn -- rn' )                                           \   signed multiply rn by two                                   ( =============== < F4 real numbers extension > ============== )                                  context 2@ hidden definitions : ff-                                                             -frot fover fabs fover fabs f+ f2/                              -frot f- fabs -frot f* fabs f< ;                              : ff+ -frot f- fabs f> ;                                        : ff= fdrop f= ;                                                                                  context 2!                    : f~~ fdup fsgn 2+ case: f2drop ff- ff= ff+ ; ;                                                                         -->                                                                                                                                     \ f~~       ( r1 r2 r3 -- flg )           ans-4th 12.6.2.1640   \   tf if r1 is in range r2 +/- +r3 or, with r4 = |-r3|, if     \   (r1-r2)*r4 < r2 < (r1+r2)*r4, i.e. r1-r2 < r2/r4 < r1+r2    \   [hopefully correctly copied from dpans94' queer description]( =============== < F4 real numbers extension, doubles > ===== )                                                                : df2/                                                            dup ddup + xor 0< 8 pick 1 and 0= or                            if 4swap q2/ 4swap exit endif q2* dfreduce ;                                                                                  : df2*                                                            pick4 ddup + xor 0< pick4 1 and 0= or                           if q2/ exit endif 4swap q2* 4swap dfreduce ;                                                                          -->                                                                                                                                     \ df2/   ( drn -- drn' )                                        \   signed divide double size ranum by two, round near zero.    \ df2*   ( drn -- drn' )                                        \   signed multiply double size ranum by two                    ( =============== < F4 real numbers extension, doubles > ===== )                                                                : df*                                                             4rot uq* 8swap q* 4rot 8drop 8dup qgcd                          q1- ?q0= if 4drop 4swap exit endif                              q1+ 4>r 4r q/ 4swap 4r> q/ dfreduce ;                                                                                         : 1/df pick4 q+- 4swap qabs ;                                   : df/ 1/df df* ;                                                                                                                : df1- 4>r 4r q- 4r> ;                                                                                                          : df= df->f 4-rot df->f f~ ;                                                                                            -->     : df0= 4over q0= if q0= 0= >r q0= r> and exit endif               [ df 00 f->df ] 2fliteral df= ;                               ( =========== < F4 real numbers extension, {d,}fsqrt > ======= )                                                                : dfsqrt ( df -- df' )                                            qslb >r 4swap qslb r> min >rr                                   4<< qsqrt ( q+-) drop  4swap r> 4<< qsqrt drop dfreduce ;                                                                     : fsqrt  ( rn -- rn' ) f->df dfsqrt df->f ;                                                                                                                                             -->                                                                                                                                                                                                     \ dfsqrt ( +dr -- dr' )                                         \   square root of a double |ranum|                             \ fsqrt ( +dr -- dr' )                                          \   square root of ranum |dr|                                   ( =============== < F4 real numbers extension > ============== )                                                                : mxo fovf? >r 4over foverflow r> or 0dup 0= -exit                2drop 0> 2* 1- 2sdrop 2swap 0> 2* 1- sdrop rot drop ;                                                                         : fmax  ( rn1 rn2 -- rn3 )                                        mxo if max s->f exit endif 8dup f< if 4swap endif 4drop ;                                                                     : fmin  ( rn1 rn2 -- rn3 )                                        mxo if min s->f exit endif 8dup f> if 4swap endif 4drop ;                                                             -->                                                                     \ fmax ( rn1 rn2 -- rn3 )                                       \   returns the larger of the two ranum arguments.              \ fmin ( rn1 rn2 -- rn3 )                                       \   returns the smaller of the two ranum arguments.             ( =============== < F4 real numbers extension > ============== )                                                                : set-fplaces 1 max 63 min to #prec ;   ( n -- )                12 set-fplaces                                                                                                                  : set-ftrunc 0=/= to ftrunc ;           ( flg -- )              1 set-ftrunc                                                                                                            -->                                                                     \ set-fplaces   ( n -- )                                        \   n is the maximal number of digits to be displayed after     \   the decimal point in words that display ranum numbers in    \   floating point format. clipped to min 1 and max 63 digits.  \ set-ftrunc    ( flg -- )                                      \   if non-zero suppress trailing zeroes in fractional part     \   of floating point display format                            ( =============== < F4 real numbers extension > ============== )                                                                : set-digits ( n -- ) 1 max 63 min to #frac ;                   7 set-digits                                                                                                                    : digits>    ( -- du )                                            base@ #frac u^ -1 m+ ;                                                                                                -->                                                                     \ set-digits ( n -- )                                           \   n is the maximal number of digits to be displayed in the    \   numerator or denominator of a ranum number, when displayed  \   in fractional format.                                       \ digits>   ( -- du )                                           \   du is the largest representable number with the current base\   which consists of no more than "#frac" number of digits.    ( =============== < F4 real numbers extension > ============== )                                                                : (quad)    ( a -- q 0 bse | a 1 bse )                            base@ >r a>b >rr c->s base ! >quad                              if r> q+- 0 else rdrop 1 endif r> ;                                                                                           : [ranum] ( a -- rn 0 | a 1 )                                     (quad) swap if base ! 1 exit endif                              base@ swap base ! dpl@ umq^ df->f -2 dpl ! 0 ;                                                                                : [quad] (quad) base ! ;                                                                                                -->                                                                                                                                     \ [ranum] ( a -- rn 0 | a 1 )                                   \   convert numeric string at addr a to ranum rn & ff on success( =========================================== : quad : df ) --> \ quad  ( -- )                      (i)                         \   next numeric input will be read as a quad integer.          \ df    ( -- )                      (i)                         \   next numeric input will be read as a rational/real number;  \   reverts to dft mode immediately after next input which was  \   not found as a forth word, regardless of conversion success.\   intercepts the interpreter at deferred [inter] which by {df}\   is redirected to [xinter] until a numeric string encountered\   use{ ... df ... 123,456 ... 123,456 } where 1st is a 'ranum'\   the remaining chars count after last #dp char goes into dpl.\   thus, { df 1.234.567,89 f. } equals { df 1234567,89 }.      \   re {flt} for persistent ranum input mode; revert w. {int}.  \   re [qnum], [qe], [qm] for exponentation and multiplier flags\   max-df ('ranum'): decimal +/- 9223372036854775807           \   max-quad: decimal +/-170141183460469231731687303715884105727( =============== < F4 real numbers extension > ============== )                                                                : [iranum] fpvoc? 0= -flt and -exit -dup -exit                    [ 1 ranumb << not ] literal (bits) and!                         here [ranum] if drop exit endif [_] fliteral ' noop $c1 1 ;   ' [iranum] =: 'inter                                                                                                            : [iquad] quadb (bits) bit 0= -exit -dup -exit                    [ 1 quadb << not ] literal (bits) and!  \  'inter is [inter]    here [quad] if drop exit endif [_] fliteral ' noop $c1 1 ;                                                            -->                                                                     \ [iranum]  ( pfa flg 1 | 0 -- pfa flg 1 )                      \   intercept interpreter to fetching a ranum; re <inter>       \ [iquad]   ( pfa flg 1 | 0 -- pfa flg 1 )                      \   intercept the interpreter to fetching a quad integer.       ( =============== < F4 real numbers extension > ============== )@order root definitions                                         : df >inter ' [iranum] is [inter]                                 [ 1 ranumb << ] literal (bits) or! ;      immediate           : quad >inter ' [iquad] is [inter]                                [ 1 quadb << ] literal (bits) or! ;       immediate                                                                           : flt [_] df 1 floatb << (bits) or! ;       immediate           : int -flt -exit                                                  ( 'inter is [inter] ) 1 floatb << not (bits) and! ; immediate !order                                                                                                                  -->     \ flt   ( -- )                                  (i)             \   set persistent floating point numeric input mode            \ int   ( -- )                                  (i)             \   revert from persistent floating point numeric input mode    ( =============== < F4 real numbers extension > ============== )                                                                : s->df s->q quad 01 ;                                                                                                          : fround5 fsplit base@ #round u^ d->f                             fsover f* df 0,5 f+ f>floor fswap f/ f+ ;                                                                             -->     \ s->df     ( n -- rd )                                         \   convert sing integer to double ranum equivalent rd.         \ fround5   ( rn -- rn` )                                       \   round ranum to #round fractional digits,                    \   add 1 to last digit if next would be base@/2 or greater.    \                                                               \            floor(frac(rn)*base@^#round+1/2)                   \     rn' := -------------------------------- * floor(rn)       \                     base@^#round                              ( =============== < F4 real numbers extension > ============== )                                                                : -zeroes ( a u -- a u' )                                         2dup #dp scan sdrop 0= -exit                                    2dup "0 rskip swap c@ #dp = - - 1+ ;                                                                                                                                                  -->                                                                                                                                                                                                     \ -zeroes ( a u1 -- a u2 )                                      \   if no char #dp (dft: comma or dot) in string(a,u1) ret a,u1;\   strip all but one trailing "0" chars which follow after the \   fraction marker char ('decimal point', supplied w. constant \   #dp) off string(a,u1) if any such chars present and ret the \   remaining count u2; ret u1 if no fraction marker found.     ( =============== < F4 real numbers extension > ============== )                                                                : #f         ( +dn dz -- 0 0 )                                    2dup 2-rot ud/mod 2-rot                                         #prec 0 do 2over base@ 0 2swap ud*/mod drop h>a hold loop       hld@ dup pad over- >move< 4drop #dp hold #s ;                                                                                                                                         -->                                                                                                                                                                                                                                                                     \ #f    ( +rn -- 0 0 )                                          \   append the positive ranum +v to the numeric output string   \   as a floating point number. I.e, the integral component,    \   followed by char #dp, followed by #prec fractional digits   ( =============== < F4 real numbers extension > ============== )                                                                : <#f#> ( rn -- a u )                                             fovf? if fdrop s" <Overflow>" exit endif                        2>r dup -rot dabs 2r> <# #f sign #> ;                                                                                                                                                 -->                                                                                                                                                                                                                                                                                                                                                                                                     \ <#f#> ( f -- a u )                                            \   Returns a string representing the ranum f at address a      \   in floating point display format                            ( =============== < F4 real numbers extension > ============== )                                                                : f.j   ( rn n1 n2 -- )                                           >r >r <#f#> ftrunc if -zeroes endif                             2dup #dp >ch r> over - spaces                                   over 2swap type                                                 2dup = if 2drop r> 1+ else - 1+ r> + endif spaces ;                                                                                                                                   -->                                                                                                                                                                                                     \ f.j   ( f n1 n2 -- )                                          \   display ranum in a field of min n1 places till #dp char and \   min n2 places after w.o. trailing fractional zeroes.        \   field count of -1 disables the rsp. padding.                ( =============== < F4 real numbers extension > ============== )                                                                : #v    ( +rn -- 0 0 )                                            fdup f0= if "0 hold fdrop 0. exit endif                         2sover d/mod 2over d0=                                          if 2-rot 4drop 0.                                               else 2rot #s 2drop "/ hold 2swap #s endif                       2swap 2dup or if bl hold #s endif 2drop ;                                                                             -->     \ #v ( +rn -- 0 0 )                                             \   append positive ranum +f to numeric output string:          \   if +rn is zero append "0".                                  \   If +rn has an integral component append that number.        \   If +rn has a fractional component append num"/"den.         \   If +rn is an improper fraction separate integer from        \          fractional part by a blank space                     ( =============== < F4 real numbers extension > ============== )                                                                : <#v#> ( rn -- a u )                                             fovf? if fdrop s" <Overflow>" exit endif                        2>r dup -rot dabs 2r> <# #v sign #> ;                                                                                                                                                 -->                                                                                                                                                                                                                                                                                                                                                                                                     \ <#v#> ( rn -- a u )                                           \   Returns a string representing the ranum f at address a      \   in fractional display format.                               ( =============== < F4 real numbers extension > ============== )                                                                : v.j           ( v n1 n2 -- )                                    >r >r digits> fsimplify <#v#>          ( rs] n1 n2 --           2dup "/ scan sdrop if                  ( fraction exists         2dup bl >ch 2dup >r =                 ( rs] n1 n2 fs --         if 2r> >r ( 1+) spaces                ( rs] n1 fs --             type 2r> - spaces                                              else 2r> dup >r - spaces              ( integer and fraction     sover type 2r> + ( 1+) swap - spaces                          endif exit endif                       ( no fraction            r> over - spaces type r> ( 1+ ) spaces ;              -->                                                                     \ v.j           ( v n1 n2 -- )                                  \   display ranum in fractional format, right justified integer \   in n1 chars field, left justified fraction in n2 chars field( =============== < F4 real numbers extension > ============== )                                                                : f.r ftrunc >r #prec >r >r 0 to ftrunc #round to #prec           <#f#> r> over- spaces type r> is #prec r> is ftrunc ;                                                                         : f. 0. f.j space ;                                                                                                             : v. -1 -1 v.j space ;                                                                                                  -->     \ f.r   ( rn n -- )                                             \   display ranum in floating point format w. #round trailing   \   fractional digits right justified in a field of n columns.  \ f.    ( rn -- )                                               \   display ranum in floating point format w.o. justification.  \ v.    ( rn -- )                                               \   display ranum in fractional format w.o. justification.      decimal ( ======= < F4 real numbers extension > ============== )                                                                 299800000  0         1          0           fconstant c                                df 0,577215664901532 fconstant euler-c   69         0         50         0 ( e-23)   fconstant k         8859       0        -1530494976 232830      fconstant epsilon0  1257       0         1000000000 0           fconstant µ0 ( my0) 801        0         1495269376 217081053   fconstant el                                                 ( elektroneladung )    981        0         100        0           fconstant g                                                                                                                        -->                                                                                                                                                                                                             : c : euler-c : k : epsilon0 : µ0 : el : g                      decimal ( ======= < F4 real numbers extension > ============== )  df 3,14159265358979323846264338327 fconstant pi     \ : pi    -892423759 1572646668 1293368824 1001177964 fconstant pi/2        pi fdup f*                         fconstant pi^2   \ : pi^2    pi f2*                             fconstant 2pi    \ : 2pi     2pi df 03 f/                       fconstant 2/3pi  \ : 2/3pi   pi/2 f2/                           fconstant pi/4   \ : pi/4    pi df 180 f/                       fconstant pi/180 \ : pi/180                                                                -276391955  68787128  -1566856919 1058675046 fconstant 1/sq6*2pi-1350029697 2828166     1704180538 7254529   fconstant sq6/2pi            1.                  29.            fconstant u2/u1                                                            -->     ( error deviation of fractions & multiples of pi < 10^-27      )( dreigliedrige phasenkette: f0 = cons / RC  (1:R-C, 2:C-R )    ( : sq6/2pi : 1/sq6*2pi : u2/u1 : pi/2                         )decimal ( ======= < F4 real numbers extension > ============== )                                                                 3862497387 632         3567587328 232         fconstant e       1688173685 9           100000000  0           fconstant e^6    -2098207245 2531623    -276898234  114         fconstant e^10    188143747.             625000000.             fconstant lg(2)  -1372284635 225        -1768994503 325         fconstant ln(2)   844883955  2816697     213569948  1223276     fconstant ln(10)  682432654  432        -1793223829 305         fconstant 2^(1/2)-1813845603 185         615572639  107         fconstant 3^(1/2)-1593222911 889193778 0.                                                    1723559992  386171951  0.         2fconstant ln(10d)                                                        -->                                                                     : e : e^6 : e^10                                                : lg(2) : ln(2) : ln(10) : ln(10d) : 2^(1/2) : 3^(1/2)          decimal ( ======= < F4 real numbers extension > ============== )                                                                df  00            fconstant  0e0                                df  01            fconstant  1e0                                df -01            fconstant -1e0                                                                                                df 7532,50        fconstant meile ( landmeile, preuszische [m]) df 25,4           fconstant inch  ( zoll, englische       [mm]) df 36 inch f*     fconstant yard  ( yard                  [mm]) df 63,360 inch f* fconstant mile  ( kurze m., englische    [m])                                                                                                                         -->                                                                                                                                     : meile : inch : yard : mile                                                                                                    decimal ( ======= < F4 real numbers extension > ============== ) -->     0 constant fac21+       here to fac21+                 ( 21) 0 2 -989364938 -1195114496                    , , , ,     ( 22) 0 60 -291192141 -522715136                    , , , ,     ( 23) 0 1401 1892515369 862453760                   , , , ,     ( 24) 0 33634 -1824271396 -775946240                , , , ,     ( 25) 0 840864 1637855376 2076180480                , , , ,     ( 26) 0 21862473 -365433172 -1853882368             , , , ,     ( 27) 0 590286795 -1276761037 1484783616            , , , ,     ( 28) 3 -651838905 -1389570659 -1375731712          , , , ,     ( 29) 111 -1723459042 -1642843428 -1241513984       , , , ,     ( 30) 3347 -164163690 -2040662563 1409286144        , , , ,     ( 31) 103786 -794107078 1163969997 738197504        , , , ,     ( 32) 3321178 358377288 -1407665755 -2147483648     , , , ,     ( 33) 109598876 -1058451362 791670357 -2147483648   , , , ,                                                             -->     ( =============== < F4 real numbers extension > ============== )context 2@ hidden definitions decimal                                                                                           : f>inf                             ( rn -- dn ( +/- infinity )   2sdrop sdrop 0< if $fff00000 else $7ff00000 endif or rdrop ;                                                                  : f>i0 >r fdrop -0. r> and 1. rdrop ;   ( rn -- dn ( +/- zero )                                                                 : f<i1                                  ( rn -- rn' exp ( n<1 )   1+ >r enter begin r> 1- >r f2* entry fdup du< 0= until r> ;   : f>i1                                 ( rn -- rn' exp ( n>/1 )   >r enter begin r> 1+ >r f2/ entry fdup du> 0= until f2* r> ;                                                                  : n/f d2* 2over ud/mod ;                ( while normalizing.. )                                                         -->                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : f>imnt                                                          frac 2swap 2over ud/mod 2drop 0. 2-rot                          52 0 do n/f drop 1 and 0 3 2roll d2* d+ 2-rot loop ;                                                                          : f>irnd                                                          n/f over >r 6 ndrop r> 0dup                                     if d1+ dup $fff00000 = 0dup if d2/ -1 endif endif ;                                                                           : f>inrm                                                          $3fe -4 roll fdup [ 1. 1. ] fliteral f~ 0=                      if fdup du< 5 roll swap if f<i1 else f>i1 endif endif ;                                                                                                                               -->                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : iinf      ( di -- rn & exit | di ) ( sort out +/- inf & NAN )   dup $7ff0000 dup rot and xor -exit     ( neither oo nor nan )   0< if min-2int else max-2int endif                              rot if 1. else 0. endif rdrop ;                                                                                               : izero 2dup 2* d0= 0= -exit 1. rdrop ;         ( zero & exit )                                                                 context 2!                                              -->                                                                                                                                                                                                                                                                                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : f>ieee    ( rn-- dn ( convert ranum to ieee-754 double float )  2dup d0= if f>inf endif                   ( +/-oo & exit        pick2 s->d >r 0< if nos-dminus endif      ( -- [ sg             2over d2* d0= if r> f>i0 endif            ( +/- 0 & exit        f>inrm r> #11 << or >r f>imnt f>irnd r> + 20 << or ;                                                                  -->                                                                     \ f>ieee    ( rn-- dn )                                         \   convert sing ranum to ieee-754 "double praecision normalized\   binary floating point data" format:    [S|exp|fraction]     \     sign bit of fraction, -ve if set. ----'  |       |        \     11 bit exponent, 'biased' by hex 3ff ----'       |        \     52 bit 'fraction', i.e normalized mantissa w. ---'        \                implicit leading 1, in range (1,2)             ( =============== < F4 real numbers extension > ============== )                                                                : ieee>f    ( dn -- rn )                                          iinf izero                                                      >rr dup 2* $7fe00000 - s->d #21 a2>> drop ( l4:ecx & exp sgn)   -rot $000fffff and $100000 +           ( mant.  ( -- es dmnt)   r> d+- 0 $100000                                                4 roll dup 0< if 1. rot minus 2^ else 2^ 1. endif f* ;                                                                                                                                -->                                                                                                                                                                                                                                                                     \ ieee>f    ( dn -- rn )                                        \   convert ieee-754 double float to ranum format               ( ============== < F4 real numbers, doubles > ======= ) decimal  \  -!-  auxilary defn's only! not exact w.o. {fnormal}  -!-    : df. df->f f. ;                                                                                                                ' 8drop prim?    if-true ' 8drop palias dfdrop                  ' 8drop prim? 0= if-true : dfdrop 4drop 4drop ;                                          : df2drop 16 ndrop ;                                                                                   ' 8dup  prim?    if-true ' 8dup palias dfdup                    ' 8dup  prim? 0= if-true : dfdup 8 ndup ;                                                : df2dup 16 ndup ;                                                                                     ' 8swap prim?    if-true ' 8swap palias dfswap                  ' 8swap prim? 0= if-true : dfswap 8 nswap ;                                                                             -->                                                                     ( ============== < F4 real numbers, doubles > ======= ) decimal                                                                 : dfpick 2* s->d 2* 1+ + >rr 4pick r> 4pick ;                   : dfroll 2* s->d 2* 1+ + >rr 4roll r> 4roll ;                                                                                   : dfover 1 dfpick ;                                             : dfsover dfswap dfover ;                                       : dfrot 2 dfroll ;                                                                                                                                                                      -->                                                                                                                                                                                                                                                                                                                                                                                                     ( ============== < F4 real numbers, doubles > ======= ) decimal                                 context 2@ hidden definitions   : [s] emit dup . bs [ "] bl 8 << or ] literal emit -1 swap ;                                               forth definitions    if-nfound 2or  : 2or rot or -rot or swap ;                                                                                      : .sf fdepth  "[s [s] enter-do i fpick f. entry -1 +loop cr ;   : .df f2depth "[d [s] enter-do i dfpick df. entry -1 +loop cr ;                                                                                                 context 2!              -->     \ 2or   ( d1 d2 -- d3 )                                         \   binary OR two doubles                                       \ .sf   ( -- )                                                  \   displays stack content in single fp format                  \ .df   ( -- )                                                  \   displays stack content in double fp format                  ( ============== < F4 real numbers, doubles > ======= ) decimal                                                                 : dfnormal df->f f->df ;                                                                                                        : df+ 4rot 8dup uq* 4drop 4>r                                     4rot q* 8swap q* o+ 4drop 4r> dfnormal ;                                                             if-nfound fac21+ -->     : dffactorial dup 34 < minus and dup 21 - 0<                      if factorial 0. else 21 - 16* fac21+ + 4@ endif quad 01 ;                                                                                                                             -->     \ dfnormal  ( rd -- rd' )                                       \   approximate rd to num & den fitting in range of a sing ranum\ df+       ( rd1 rd2 -- rd )                                   \   add two double ranums, sum num/den approximated to figures  \   within the range of a single precision ranum                \ =============== < F4 real numbers extension > ======== : ln(f)                                context 2@ hidden definitions   : 1/(df+1)  ( rd -- rd' )                                         4sover q+ s->d 0= -exit nos-qminus qminus ; \ signed...                                                                       : >ln(ovf)  ( rd -- rd' )                                         ?q0= >r 4over q1- q0< r> or 0= -exit 4drop quad 00 rdrop ;                                    context 2!              -->                                                                     \ ln(df)    ( rd -- rn' )                                       \   calculate logarithmus naturalis of a double ranum, ret sing.\                  _oo_       2                                 \      ln x = (x-1)|  | -------------, 0<x<oo                   \                   n=1 x^(1/(2^n))+1                           \ ln(f)     ( rn -- rn' )                                       \   ret logarithmus naturalis of a ranum                        ( =============== < F4 real numbers extension > ============== )                                                                : ln(df)    ( rd -- rn ( calculate logarithmus naturalis )        >ln(ovf)                               \ ? ret signed ovf       dfdup df1-                             \ x x1                   enter begin dfsover 1/(df+1)           \ x x1 -- x1 x 1/x1+1     df2* dfnormal df* dfnormal            \ x2 = 2/(x1+1)*x        entry dfswap dfdup dfsqrt dfsover df=  \ x1 x2 sq(x2)--x1 sq f  until dfdrop ;                         \ -- x1=rn                                                                             : ln(f) f->df ln(df) df->f ;                                                                                                    : lg(f) f->df ln(df) ln(10d) df* df->f ;                                                                                -->                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                context 2@ hidden definitions   #21 =: #ee  ( max. no. of iterations in summation loop, sings)                                                                  : ?df0= dfdup q0= >r q0= r> or ;     ( rd -- rd f (ovf or zero)                                                                 : e^i   ( rn sg -- rn' ( e raised to +/- integral exponent )      >r fsdrop f->s -1 df 01 2rot enter-do e f* entry loop           r> 0< 0= -exit 1/f ;                                                                                                          : e6r fdup 6 s->f f> 0= -exit                                     -1 >r begin r> 1+ >r df 6 f- fdup f0< until df 06 f+ r> ;                                                                     : e6m -1 enter-do e^6 f* entry loop ;                                                           context 2!              -->                                                                     ( =============== < F4 real numbers extension > ============== )                                context 2@ hidden definitions   : e^d   ( +rn -- +rn' )                             ( OK )        [ df 01 fdup ] fliteral fliteral #ee 1                          do                                 \ f1 sum(n-1) f(n-1)          fdup f0= if leave                                               else                                                             2 fpick i s->f                   \ f1 sum(n-1) f(n-1) f1 (n)    f/    f*                         \ f1 sum(n-1) f(n)             f2dup f+                         \ f1 sum(n-1) f(n)   sum(n)    fovf? >r fdup f0= r> or          \ done on ovf or zero          if fdrop leave else -1 fpick endif \ f1 sum(n) f(n)            endif                                                          loop frot f2drop ;                                                                            context 2!              -->                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : e^f       ( rn -- rn' ( raise e to the power of a ranum     )   pick2 >r fabs                                                   fdup fsplit f0= if r> e^i exit endif fdrop   ( integral exp )   0 >r df 6 fover f< if e6r rdrop >r endif     ( reduce by 6e )   e^d r> e6m                                   ( exp, rst *6e )   r> 0< 0= -exit 1/f ;                         ( +- exp       )                                                         -->                                                                     \ e^f       ( rn -- rn' )                                       \   raise e to the power of a ranum                             \   tested in range  -43,6 < qr < 43,6                          \              -- x^n          x^n   x^(n-1)   x          x     \        e^x = >  ---, x >= 0; --- = ------- * -; done if - == 0\              --  n!           n!    (n-1)!   n          n     ( =============== < F4 real numbers extension > ============== )                                                                : f^ fswap fabs ln(f) f* e^f ;                                                                                                  : ffactorial                                                      fint? if f->s factorial d->f exit endif 2drop 0. ;                                                                                                                                    -->                                                                                                                                                                                                     \ f^        ( rn1 rn2 -- rn )                                   \   raise rn1 to the power of rn2. ambiguous result if rn1 < 0. \ ffactorial ( rn -- rn' )                                      \   ret rn! if rn +ve and integral in range 0 \< rn < 21;       \   ret 0 if rn > 20, ret ovf if rn < 0 or not integral.        ( ============== < F4 real numbers extension > =============== )                                context 2@ hidden definitions 0 : [fx] [ ' [id] is@ sdrop -dup ] if-true literal execute          ' noop [ drop here ] cfa over- -exit c>pfa nfa id.              ddup @ 16 b. +@ 16 b. 4+ "]di[ ;                                                                                              : fx 2drop sdrop -rot 2drop xor 0< sdrop ; \ sgn(r1) XOR sgn(r2)                                                                : (next) r> fr fr> fr f+ fr> fr fswap f>r fover f>r               fdup frot f- -frot f- f+ f0<   \ minus fx   \ tf if equal sgns  if 4+ [ 3 rncells ] literal nrdrop else +@ endif >r ;             ' (next) swap 4- !      ' [fx] is [id]                                                                              -->     \ R( -- limit step start )                                      : (next) r> fr> fr f+ fr> fover fr f- fr fx                       if f2drop 4+ frdrop else f>r f>r +@ endif >r ;                ( ============== < F4 real numbers extension > =============== )                                                                : (for)         ( limit -- R( -- limit step start )               r> -4 roll f>r df 01 f>r df 00 f>r >r ;                                                                                       : (start) r> -4 roll frdrop f>r >r ;                                                                                            : (step)  r> -4 roll fr> frdrop fswap f>r f>r >r ;                                          context 2!                          : @start rp@             4+             f@ cswap ; \  = index   : @step  rp@ [ 1 rnbytes 4+ ] literal + f@ cswap ;              : @limit rp@ [ 2 rnbytes 4+ ] literal + f@ cswap ;                                                                      -->     : (step) r> -4 roll fr> frdrop fswap                              pick2 0< if fswap fr> fswap f>r fswap endif f>r f>r >r ;                                                                      ( ============== < F4 real numbers extension > =============== )                                                                : for compile (for) here "for ;                       immediate : next  "for ?pairs compile (next) here - , ;         immediate : step  "for ?pairs compile (step)  drop here "for ;  immediate : start "for ?pairs compile (start) drop here "for ;  immediate                                                                                                                         -->     \ for   ( rn -- (R: -- rn,limit rn,step rn,start )              \   begin for..next loop with supplied limit, default to step=1 \   and start=0; read running index := start' with { fr }.      \ next  ( -- (R: limit step index | -- )                        \   terminate for..next loop if sgnn(index-limit) =/= sgn(limit)\ step  ( rn -- (R: limit step' start )                         \ start ( rn -- (R: limit step start' )                         \   replace for..next loop defaults for step or start, rsp.     --> ============= < F4 real numbers extension > ============== )--> ===== Winkelfunktionen, Winkel in Vielfachen von pi ====== )                                                                         --       x^2n          x^2n    x^(2(n-1))      x^2      cos x = > (-1)^n -----; m(n) = ----- = ---------- * ---------           --       (2n)!         (2n!)    (2(n-1))!   2n*(2n-1)         n=1..33                                                  -                                                              -         x^(2(n-1))                     x^2                     v(n-1) = ---------- ; m(n) = v(n-1) * ---------                          (2(n-1))!                    2n*(2n-1)                 -                                                              - sin(x) = cos(x-pi/2)                                           -                                                              - tg(x)  = sin(x)/cos(x)                                         ----------------------------------------------------------------( == cos{f} ==== < F4 real numbers extension > =============== )                                                                : cos(f)    ( rn1 -- rn2 rn3 rn4 )                                fabs 2pi f/ frac 2pi f* f^2 df 001 df 001 #ee 1 do              fdup f0= 0= if                        \ leave on overflow        2 fpick i 2* dup 1- u* d->f f/ f*    \ @tos: xn^2/(2n*2(n-1))   f2dup i 1and if fminus endif f+      \ -1^n * r(v) + S          fdup f0~ 0= if                                                   frot fdrop fswap                    \ replace S(n-1) w. S(n)  [ 2rot ] loop                                                    else fdrop [ 2swap ] endif           \ drop S(n)               2rdrop endif fdrop fsdrop ;                                                                                           -->     \ cos(f)    ( rn1 -- rn2 )                                      \   auf den bereich [0,2pi) abgbildeter cosinus rn2 des in      \   vielfachen von pi ('rad') angegebenen winkels rn1           ( == cos{f} ==== < F4 real numbers extension > =============== )                                                                : sin(f) pi/2 f- cos(f) ;                                       : sincos(f) fdup sin(f) fswap cos(f) ;                                                                                          : tg(f)  sincos(f) f/ ;                                                                                                 -->                                                                                                                                                                                                     \ sin(f)    ( rn1 -- rn2 )                                      \   sin(x) = cos(x-pi/2)                                        \ sincos(f) ( rn1 -- rn2 rn3 )                                  \   ret rn2 sinus and rn3 cosinus of angle rn in radians        \ tg(f)     ( rn1 -- rn2 )                                      \   tg(x)  = sin(x)/cos(x)                                      --> ============= < F4 real numbers extension > ============== )          pi   --            m^n       x-1                       atg x = --- + >  (-1)^(n+1) ----, m = ---; x=0,x>0; (Huette I)           4    --            2n-1      x+1                      ----------------------------------------------------------------                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( == atg{f} ==== < F4 real numbers extension > =============== )                                                                : atg(f) ?f0= -exit pick2 >r              \ atg(0) = 0            fabs fdup f1- ?f0=                                              if f2drop pi/4 else                     \ atg(1) = pi/4          fswap f1+ f/ fdup f^2                  \ m m^2                  fswap fdup pi/4 f+ fswap 2 >r          \ n=1: m^2 m+pi/4 s      begin                                  \ n=2... ( m2 mp s -      2 fpick f* f2dup                      \ (m2 mpi s m2            i 2* 1- i 1and 0= if minus endif s->f \ nn: -1^(n+1)*(2n-1)     f/ f+ fdup 3 fpick f= 0=              \ (m2 mpi s+m2/nn f       if -1 fpick r> 1+ 255 and >rr 0=      \ (m2 mp+s sn            [ 2swap ] until else fdrop endif                                fdrop fsdrop rdrop                                             endif r> f+- ;                                                                                                        -->     ( == asin{f} === < F4 real numbers extension > =============== )                                                                context 2@ hidden definitions                                   : dsq1 fdup f^2 minus f1+ fsqrt ;   context 2!                                                                                  : asin(f) dsq1 f/ atg(f) ;          ( rn1 -- rn2 )              : acos(f) dsq1 /f atg(f) ;          ( rn1 -- rn2 )                                                                                                                                      -->                                                                                                                                                                                                     \ asin(f)   ( rn1 -- rn2 )                                      \   asin x = atg x/sqrt(1-x^2).                                 \ acos(f)   ( rn1 -- rn2 )                                      \   acos x = atg sqrt(1-x^2)/x.                                 ( == atg2{f} ==== < F4 real numbers extension > ============== )                                                                : atg2(f)  /f atg(f) ;              ( x y -- rn )               : atan2(f) f/ atg(f) ;              ( y x -- rn )                                                                               : deg>rad pi/180 f* ;                                           : rad>deg pi/180 f/ ;                                                                                                                                                                   -->     \ atg2(f)   ( rn1 rn2 -- rn3 )                                  \   atg an rn2 = abszisse, rn1 = ordinate; (rn1,rn2) = (x,y)    \ atan2(f)  ( rn2 rn1 -- rn3 )                                  \   complements {sincos(f)}, atg an (rn2,rn1 ) = (y,x)          \ deg>rad   ( rn1 -- rn2 )                                      \ rad>deg   ( rn1 -- rn2 )                                      \   winkelmasz-umrechnung grad nach radiant und umgekehrt.      --> ============= < F4 real numbers extension > ============== )               1            1                                    sinh/cosh x = - ( e^x -/+ --- )                                               2           e^x                                  ---------------------------------------------------------------- arcosh = ln(x-sqrt(x^2-1)); |x| > 1                            ---------------------------------------------------------------- arsinh = artanh(x/sqrt(x^2+1))                                 ----------------------------------------------------------------            1      1+x                                           artanh x = - ln ( --- ), |x| < 1                                           2      1-x                                          ----------------------------------------------------------------                                                                                                                                                                                                --> ============= < F4 real numbers extension > ============== )          e^x - e^(-x)   e^2x-1                                  tanh x = ------------ = ------                                           e^x + e^(-x)   e^2x+1                                 ----------------------------------------------------------------            1  _oo_ (1+1/n)^x                                    gamma(x) = -  |  | ---------   \/ x =/= -n, n=0,1,2,...                    x   n=1   1+x/n                                     ----------------------------------------------------------------                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        decimal warning @ warning off                                                                           forth definitions                                               : fp-ini fp ' [iranum] is [inter] ;                                                                                             root definitions        \ forcedly compile {fp} word, next      : [fp] ' fp hidden [fv] ;               immediate                                                                                                                                       -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   fp definitions                                                                    ' 4dup   palias dup     ' 8dup palias 2dup                      ' 4swap  palias swap    : 2swap 8 nswap ;                       ' 4drop  palias drop    : 2drop 8 ndrop ;                       ' 4over  palias over    : 2over -compile dfover ; immediate     ' 4sover palias sover   : 2sover -compile dfsover ; immediate   ' 4sdrop palias sdrop   : 2sdrop dfswap dfdrop ;                                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ' 4pick  palias pick    : 2pick -compile dfpick ; immediate     ' 4roll  palias roll    : 2roll -compile dfroll ; immediate                                                                     ' 4rot   palias rot     : 2rot  -compile dfrot ;  immediate     ' 4-rot  palias -rot    : 2-rot -2 dfroll ;                                                                                     : >r  -compile f>r ;                immediate forth             : r   -compile fr ;                 immediate forth             : r>  -compile fr> ;                immediate                   : >rr [_] f>rr ;                    immediate forth                                                                     -->                                                                                                                                                                                                                                                                                                                                     : !  -compile f! ;                  immediate                   : +! -compile f+! ;                 immediate                   : @  -compile f@ ;                  immediate                                                                                   : lit -compile flit ;               immediate                   : literal [_] fliteral ;            immediate                                                                                   : constant fconstant ;                                          : variable fvariable ;                                                                                                  -->                                                                                                                                                                                                                                                                                                                                                                                                     : 2! -compile f2! ;                 immediate                                                                                   : 2@ -compile f2@ ;                 immediate                                                                                   : 2lit -compile 2flit ;             immediate                   : 2literal [_] 2fliteral ;          immediate                                                                                   : 2constant 2fconstant ;                                        : 2variable 2fvariable ;                                                                                                -->                                                                                                                                                                                                                                                                                                                                                                                                     : overflow -compile foverflow ;     immediate                   : ovf? -compile fovf? ;             immediate                                                                                   : normal -compile fnormal ;         immediate                   : dnormal -compile dfnormal ;       immediate                   : round -compile fround ;           immediate                                                                                   : split -compile fsplit ;           immediate                   : simplify -compile fsimplify ;     immediate                                                                                                                                           -->                                                                                                                                     \   fint  name 'int' passt nicht, bereits besetzt               \   fint? entfällt, sinnlos; siehe -flt u. fpvoc?                                                                               : 0= -compile f0= ;                 immediate                   : 0~ -compile f0~ ;                 immediate                   : 0< -compile f0< ;                 immediate                                                                                   : sgn -compile fsgn ;               immediate                   : abs -compile fabs ;               immediate                   : +-  -compile f+- ;                immediate                   : minus -compile fminus ;           immediate                                                                                   : ~ -compile f~ ;                   immediate                   : = -compile f= ;                   immediate                   : < -compile f< ;                   immediate                   : > -compile f> ;                   immediate                                                                           -->                                                                                                                                     : + -compile f+ ;                   immediate                   : - -compile f- ;                   immediate                   : 1+ -compile f1+ ;                 immediate                   : 1- -compile f1- ;                 immediate                                                                                   : * -compile f* ;                   immediate                   : 2* -compile f2* ;                 immediate                   : ^2 -compile f^2 ;                 immediate                                                                                   : / -compile f/ ;                   immediate                   : 1/ -compile 1/f ;                 immediate                   : 2/ -compile f2/ ;                 immediate                                                                                                                                           -->                                                                                                                                     : d+ -compile df+ ;                 immediate                   : dminus -compile dfminus ;         immediate                   : d= -compile df= ;                 immediate                                                                                   : d* -compile df* ;                 immediate                   : d/ -compile df/ ;                 immediate                   : d1/ -compile 1/df ;               immediate                                                                                   : sqrt       -compile fsqrt ;       immediate                   : dsqrt      -compile dfsqrt ;      immediate                   : factorial  -compile ffactorial ;  immediate                                                     if-nfound dffactorial -->     : dfactorial dffactorial ;          immediate                                                                           -->                                                                                                                                     : max -compile fmax ;               immediate                   : min -compile fmin ;               immediate                                                                                   : ln -compile ln(f) ;               immediate                   : lg -compile lg(f) ;               immediate                   : ^ -compile f^ ;                   immediate                                                                                   : >places -compile set-fplaces ;    immediate                   : >trunc -compile set-ftrunc ;      immediate                                                                                   : . -compile f. ;                   immediate                   : d. -compile df. ;                 immediate                                                                           -->                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                                : cos    -compile cos(f)    ;       immediate                   : sin    -compile sin(f)    ;       immediate                   : sincos -compile sincos(f) ;       immediate                   : tg     -compile tg(f) ;           immediate                   : atg    -compile atg(f) ;          immediate                   : asin   -compile asin(f) ;         immediate                   : acos   -compile acos(f) ;         immediate                   : atg2   -compile atg2(f) ;         immediate                   : atan2  -compile atan2(f) ;        immediate                                                                                             fp fp-ini forth                     warning !                                                                 -->                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( =============== < F4 real numbers extension > ============== )                                                                if-found ch-name 2 +continue                                        : fh 4 1 do b/scr 2 do cr i j (line) type loop loop ;           fh cr float vlist cr                        ;s                                                                      -->                                                                     : ~pi df 02 fdup int fsqrt 1/f f>rr                               enter begin fover f>r f1+ f2/ fsqrt                             entry fsover f/ fsover fr> f= until fdrop ;                                                                                   \ ~pi=3,1415926535897932|4011 => error \< 10^-16                \ error of supplied fcons {pi} \< 10^-29                                                                                        : fpi df 01 df 00 begin     \ genauer, aber extrem langsam        f>rr fover f+ fswap 2. d+ fminus fswap fdup fr> f~ until ;    ( =============== < F4 real numbers extension > ============== )                                                                                                                        ;S                                                                      cr #8 spaces                                                    .( 'ranum' extn loaded; re scr 1..3 and comments in file)       cr #8 spaces                                                                 pad 1K dr? bchan ch-name type                      cr #8 spaces                                                    .( { fp-ini } initiates persistent ranum mode in fp vocabulary) cr #8 spaces                                                    .( load complex numbers 'ranum' extension from file <f4z.scr> ) cr                                                                                                                      -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     