================== < F4 hi-level substitutes > =================                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( ======== < F4 hi-level substitutes - not tested > ========= )        : load-f4c 6 b/scr * 1+ blk ! 0 in ! ; load-f4c ;s                                                                                             Sa 2002-09-14 14:31                                             Th 2002-09-19 07:34                                             Su 2004-02-01 21:53                                                                                                            f4a@lxhp.in-berlin.de                                                                                               requires F4 0-2-0+14 or any more recent version                                                                                                                                                                                                                                                                                                                                                                                                        ================== < F4 hi-level substitutes > =================                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (  ERROR MESSAGES  ) -->                                        EMPTY STACK                                                     DICTIONARY FULL                                                 HAS INCORRECT ADDRESS MODE                                      ISN'T UNIQUE                                                                                                                    DISC RANGE ?                                                    FULL STACK                                                      DISC ERROR !                                                                                                                                                                                                                                                                                                                                                                                                                                                    F4                                                   SEP 2, 2002(  ERROR MESSAGES  ) -->                                        COMPILATION ONLY, USE IN DEFINITION                             EXECUTION ONLY                                                  CONDITIONALS NOT PAIRED                                         DEFINITION NOT FINISHED                                         IN PROTECTED DICTIONARY                                         USE ONLY WHEN LOADING                                           OFF CURRENT EDITING SCREEN                                      DECLARE VOCABULARY                                                                                                                                                                                                                                                                                                                                                                                                                                              F4                                                   SEP 2, 2002( == system : true : cells : chars : little-endian : 1K : 1k )  forget load-f4c                  forth definitions decimal                                                                      : cells [ here 0  , here - dup allot abs ] literal * ;          : chars [ here 0 c, here - dup allot abs ] literal * ;          1 constant true                                                                                                                 : e? 1 here ! here c@ 1 = ; e? forget e?                        : little-endian [ dup ] literal ; drop ( -- flg, tf:little-e )                                                                  lc-depend ( F4 [number] evaluates the affices case-dependently) 1000     constant 1k ( 10^3 )                                   1000000  constant 1m ( 10^6 )                                   1024     constant 1K ( 2^10 )                                   1K dup * constant 1M ( 2^20 (  etc, for G, T, P, E, % (10^-2 )                                                                  ( == system ============= : recurse : -compile : -exit : exit )                                                                 root definitions decimal       ( -compile copied from f4x.scr ) : -compile cfa state@ if , 0 cmc ! exit endif execute ;         : -compile [_] ' compile -compile 0 cmc ! ;     immediate                                                                       forth definitions decimal   cmo @ -1 cmo ! ( 'optimizer' off )                                                                   : recurse last @ pfa cfa , 1 cmc +! ; immediate                                                                                : -exit if r> drop endif ;                                      : -exit state @ if compile endif -exit ;        immediate                                                                       : exit r> drop ;                                                : exit state @ if compile endif exit ;          immediate                                   cmo !       ( -?- )                 ( == system =============================== : [fgt] : forget: ) hidden definitions                                                         if-nfound (fl) (up) @ 4 (up) +! user (fl)  0 (fl) !  forth definitions                                                                            ' 0 defer xx ' xx cfa @ forget xx                                                                  : [fgt]      ( a1 a2 -- )       ( a1:handler-pfa, a2:word-pfa )   over cfa @ [ dup ] literal ?pairs     ( not a deferred word )   here (fl) @ dup if over- endif , (fl) ! nfa , , ;      drop                                                                   : forget: [_] ' [_] ' state@ if compile endif [fgt] ; immediate                                                                 \ forget:       hhh www( -- )                                   \   assign deferred forget handler hhh to forth word www        \   initial field: { here (fl) ! 0 , ' word nfa , ' handler , } \   next: { here (fl) @ over - , (fl) ! ' word nfa , ' handler ,( : 2+ : 2- : 2* : 2/ : 4+ : 4- : 4* : 4/ : 8+ : 8- : 8* : 8/ )     lload? cons+    lload? cons*                                                                                                 2 cons+ 2+      3 cons+ 3+      4 cons+ 4+      8 cons+ 8+     -2 cons+ 2-                     -4 cons+ 4-     -8 cons+ 8-      2 cons* 2*                      4 cons* 4*      8 cons* 8*                                     : 4/ 2/ 2/ ;    : 8/ 2/ 4/ ;                                                                                                                                    \ : 2+ 2 + ;      : 2- 2 - ;                                    \ : 2* dup + ;    : 2/ 0 2 u/mod swap drop ;                    \ : 4+ 4 + ;      : 4- 4 - ;                                    \ : 4* 2* 2* ;    : 4/ 2/ 2/ ;                                  \ : 8+ 8 + ;      : 8- 8 - ;                                    \ : 8* 4* 2* ;    : 8/ 2/ 4/ ;                                                                                                  ( == arith-1 ================ : 0max : 0and : 1or : sgn : abs )                                                                 : 0max 0 max ;                   ( : 0max dup 0< abs 1- and ; )                                  ( : 0max dup 0< 1- and ; (fig) : 0and drop 0 ;                                                 : 1or  drop 1 ;                                                                                                                 : sgn s->d swap minus s->d minus or ;                                                                                           : abs s->d +- ;                                                                                                                 : within over- >r - r> u< ;     ( x1 x2 x3 -- flg (A4 6.2.2440) \ in verquastem dpans94-sprech stehen dazu viele worte, so auch:\ flg  = (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 < n3|u3)) \ oder = (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 < n3|u3))  \ zu deutsch: tf wenn x1 im intervall [x2,x3) liegt; x2\<x1<x3. ( == arith-2 ==================== : << : >> : lshift : rshift )                                                                 : | -1 256 0 do dup + dup dup + 0= if i 1+ leave endif loop ;     | forget | constant max-bit  constant -0                            -0 not constant max-int                       ( max int )                                                                 : shm?      ( n -- n flg ( tf if n < 0 or n mod bits/cell = 0 )   over 0= over 0< or over [ max-bit 1+ ] literal mod 0= or ;                                                                    : <<  shm if drop exit endif 1+ 0 do dup + loop ; ( shift left) : >>  shm if drop exit endif 0 do 2/ loop ;   ( log. shf right) : a>> shm if drop exit endif 0 do 2 / looop ; ( signed shf rgt)                            ( { a>> } is not an F4 kernel word ) : rshift >> ;   : lshift << ;                                                                                                   ( "-0" just a name for the integer w. only the sign bit set... )( == arith-3 ==================================== : factorial )                                                                 0 constant fac0 here to fac0                         0 0   , ,    0 1   , ,    0 1 , ,  0 2 , ,   0 6 , ,  0 24 , ,  0 120 , ,    0 720 , , 0 5040 , ,  0 40320 , , 0 362880 , , 0 3628800 , ,    0 39916800               , ,   0 479001600               , ,    6227020800.         swap , ,           87178291200. swap , ,    1307674368000.      swap , ,        20922789888000. swap , ,    355687428096000.    swap , ,      6402373705728000. swap , ,    121645100408832000. swap , ,   2432902008176640000. swap , ,                                                                                           ( ret 0. if out of range             ) : factorial    ( +n -- d ( double factorial d of sing n, n<21 )   1+ dup 22 u< ( abs) minus and 8 * fac0 + 2@ ;                                                                                                                                                 ( == arith-4 =================================== : gcd : dgcd )                                                                 : gcd ( n n -- n)                                                 abs swap abs enter begin sover mod entry -dup 0= until ;                                                                      : dgcd ( d d -- d )                                               dabs swap dabs                                                  enter begin 2swap 2over dmod entry ?d0= until 2drop ;                                                                                                                                                                                                         \ gcd   ( n1 n2 -- n3 )                                         \ dgcd  ( d1 d2 -- d3 )                                         \   ret greatest common denominator of abs value of two         \   signed integers. If either number is zero, return           \   the value of the other number.                              ( == arith-5 : ?d0= : dsgn : d< : d= : du< : d0= : d+- : dabs )                                                                 : dsgn                                                            2dup or 0= if or exit endif 0< swap drop 2* 1- minus ;                                                                        : d< d- sdrop 0< ;                                              : d0= or 0= ;                                                   : ?d0= 2dup d0= ;                                               : d= d- d0= ;                                                                                                                   : du< rot 2dup xor if swap 2swap endif 2drop u< ;                                                                               : d+- 0< if dminus endif ;      \ : d+- 0< 0= -exit dminus ;                                                                    : dabs dup d+- ;                                                                                                                ( == arith-6 ==================== : m+ : u+ : q+ : umd* : md* ) ( with: roll, nswap - can be emulated w. roll )                                                                                 : u+ 0 d+ ;                 ( ud u -- ud' )                     : m+ s->d d+ ;              ( d n -- d' )                                                                                       : q+    ( q1 q2 -- q )      ( add two quads                   )   3 roll 0 8 roll u+                                              4 roll 0 8 roll u+ rot u+                                       4 roll 0 8 roll u+ rot u+                                       4 roll 6 roll + + ;                                                                                                           : umd*   ( ud1 ud2 -- uq )  ( mul doubles, leave quad product )   2over 2over swap drop udm* 0 4 nswap drop udm* 0 -3 roll q+ ;                                                                                                                                 ( == arith-7 ====================== : =/= : 0=/= : -0= : ?q0= )                                                                                                                                 : ?q0= 4dup or or or 0= ;                                                                                                       : =/=  = 0= ;                                                                                                                   : 0=/= 0= 0= ;                                                                                                                  : -0= dup minus = ;                                                                                                                                                                                                                                                                                                                                                                                                                                             ( == arith-8 ======================================= : df/mod )                                                                 : df/mod                                                          pick2 over xor 0<             ( if signs of arguments differ    if 2>r 2r@ d/mod 2over or     ( divide, examine remainder        if d1- 2swap 2r@ d+ 2swap    ( adjust results if rem =/= zero   endif 2rdrop exit            ( discard saved den               endif /mod ;                  ( equal signs, divide 'normally'                                                                                                                                : pick2 rot dup >r rot rot r> ; : pick2 2 pick ;                : 2rdrop 2r> 2drop ;                                                                                                                                                                            \ df/mod   ( num den -- rmdf qotf )                             \   floored division by 'round near zero' method                ( == uvari : base@ : state@ : blk@ : 0in! : l0 : #tib : >body ) forth definitions decimal                                                                                                       : base@ base @ ;                                                : state@ state @ ;                                              : blk@ blk @ ;                                                  : 0in! 0 in ! ;                                                 : l0 s0 @ ;                                                                                                                     : #tib 0 tib @ begin dup c@ while 1 1 d+ repeat drop ;                                                                          : >body @ >v ;                                                                                                                                                                                                                                                                                                                  ( == loop, rstack sing == : rdrop : >rr : r>>r : r+ : ll : ni )                                                                 here ' task cfa @ , ] 8* rp@ + 8+ 2@ ;s [                       : ll [ dup , ] sdrop ;      ( nicht 'standard', aber wirklich ) : ni [ dup , ]  drop ;      drop                                                                                                : rdrop compile r> compile drop ;           immediate                                                                           : >rr compile dup compile >r ;              immediate                                                                           : r>>r compile r> compile swap compile >r ; immediate                                                                           : r+ r> r r> 4+ >r @ swap >r ;                                                                                                                                                                                                                                  ( == rstack double ========= : 2>rr : 2rdrop : 2>r : 2r : 2r> ) forth definitions decimal                                                                                                       : 2>r compile >r compile >r ;               immediate           : 2r> compile r> compile r> ;               immediate                                                                           : 2r compile 2r> compile 2dup compile 2>r ; immediate                                                                           : 2>rr compile 2dup compile 2>r ;           immediate                                                                           : 2rdrop compile 2r> compile 2drop ;        immediate                                                                                                                                                                                                                                                                                                                                           ( =ds= : sdrop : sdup : ddup : sover : dropd : over- : bounds )                                      forth definitions decimal                                                                  : sdrop swap drop ;     ( ans-4th 'NIP' )                       : sdup  swap dup ;                                              : ddup  dup dup ;                                               : sover swap over ;     ( ans-4th 'TUCK' )                      : dropd drop dup ;                                                                                                              : over- over - ;                                                                                                                : bounds over + swap ;                                                                                                                                                                                                                                                                                                          ( == dstack == : pick2 : sroll : spick ( pick 'standard' mode ) forth definitions decimal                   ( for f4 extension)                                                                 : roll 1- dup 0< if drop exit endif                               dup begin rot >r 1- dup 0< until drop                           begin r> rot rot 1- dup 0< until drop ;                                                                                       : pick 1- dup 0< if drop exit endif                               dup begin rot >r 1- dup 0< until drop over swap                 begin r> rot rot 1- dup 0< until drop ;                                                                                       : pick2 2over swap drop ;         ( 0 1 2 3 4 -- 0 1 2 3 4 2 )  : pick3 2over drop ;              ( 0 1 2 3 4 -- 0 1 2 3 4 1 )  : pick4 4 pick ;                  ( 0 1 2 3 4 -- 0 1 2 3 4 0 )  \ : pick2 >r over r> swap ; \ : pick2 2 pick ;                                                                                  ( ================ : roll : pick ( 'backwards' w. -ve indices ) forth definitions decimal           lload sroll lload spick                                                                     : roll dup 0<                                                     if minus dup dup do 0 do j roll loop leave loop ;s endif        roll ;                                                                                                                        : pick dup 0<                                                     if swap >r dup >r abs roll drop r> r> swap roll ;s endif        pick ;              ( ^-any vers)        ( ^-F4-variant)                                                                                                                                                                                                                                                                                                                                                                                                      ( == dstack ================== : -rot : >swap< : rotd : drop2 ) forth definitions decimal                                                                                                       : -rot swap >r swap r> ;        : rot >r swap r> swap ;                                                                         ( : -rot rot rot ;                                            ) ( : -rot -2 roll ;                : rot 2 roll ;              )                                                                 \ : >swap< swap 2swap swap ;  ( 1 2 3 4 -- 4 3 2 1 )            : cswap  swap 2swap swap ;  ( 1 2 3 4 -- 4 3 2 1 )                                                                              : drop2 rot drop ;          ( 2 3 4 -- 3 4 )                    \ f4x.scr \  : rotd  rot drop ;                                                                                                                                                                                                                                 ( == dstack ============== : ?depth : -sp : +sp : ndrop : sp> )                                      forth definitions decimal                                                                  : ?depth depth 1- over min ?pairs ;                                                                                             : -sp sp@ s0 @ < dup 0= -exit sp! -1 ;  ( 'SP!' fig-4th word! ) : +sp 0 ;   ( memory allocation test, no standard aequivalent )                                                                 : ndrop dup 0< if minus 0 do 0 loop exit endif                    depth 1- min 0max -dup 0= -exit                                 2 /mod -dup if 0 do 2drop loop endif 0= -exit drop ;          \ oder einfach nur:               0 do drop loop ;                                                                              : sp> depth ndrop ;                                                                                                                                                                             ( == dstack == : 2over : 2drop : 2dup : 2swap : 2pick : 2roll ) forth definitions decimal                                                                                                       : 2drop drop drop ;                                             : 2dup over over ;                                                                                  ( : rot >r swap r> swap ; ) : 2swap rot >r rot r> ;                                         : 2over >r >r 2dup r> r> 2swap ;                                                                                                : 2roll 2* s->d 2* 1+ + >r r roll r> roll ;                     : 2pick 2* s->d 2* 1+ + >r r pick r> pick ;                     ( 'factoring' won't pay: slow and, 4 cells minimal word header)                                                                                                                                                                                                                                                                 ( == dstack ==================== : ndup : 2rot : 2-rot : 4dup )                                                                 : ndup dup 1- 0< if drop exit endif                               dup 1- dup do 0 do j pick loop leave loop ;                                                                                   : nswap dup 1- 0< if drop exit endif                              dup 2* 1- dup do 0 do j roll loop leave loop ;                                                                                : 4dup 4 ndup ;         : 3dup 3 ndup ;                         \ : 4dup 2over 2over ;    : 3dup >r 2dup r rot rot r> ;                                                                         : 2rot 2 2roll ;        : 2-rot -2 2roll ;                                                                                                                                                      \ nwap      ( x[n] y[n] n -- y[n] x[n] )                        \   swap blocks of n cells                                      ( == check local memory availabiliy =============== : use-loc ) forth definitions decimal                                                                                                       : use-loc 8+ +sp drop ;         ( n -- )                                                                                        \ won't be required if {l0} ref used from {|loc} de/allocation                                                                                                                                                                                                                                                                  \                                                               \ use-loc       ( n -- )                        forth           \   assure non-relocating availabiliy of n local cells. blocks  \   of local work-space relocation prevented by trial allocation\   of expected size. locals base ptr may change w. allocation  \   beyond size of stack section less minimal dstack margin.    ( == memory, doubles, half ==== : 2@ : 2! : +@ : @+ : w@ : w! ) forth definitions decimal                                                                                                       : 2@ dup @ swap 4+ @ ;                                          : 2! dup >r 4+ ! r> ! ;                                                                                                         : +@ dup @ + ;                                                  : @+ 4+ dup 4- @ ;                                                                                                              : w@ dup 1+ c@ 256 * swap c@ or ;                               : w! >r 0 256 u/mod r 1+ c! r> c! ;                                                                                             \ simple but, segfault e.g. at the end of a mmap-ped range:     \  : w@ @ [ hex ] 0ffff [ decimal ] and ;                                                                                                                                                       ( == mem ====== : off : c@+ : c!+ : or! : xor! : and! : bswap )                                                                 : or! dup @ rot or swap ! ;                                     : xor! dup @ rot xor swap ! ;                                   : and! dup @ rot and swap ! ;                                                                                                   : off 0 swap ! ;                                                                                                                : c@+ 1+ dup 1- c@ ;                                            : c!+ dup 1+ rot rot c! ;                                                                                                       : (b) swap 8 >> dup 255 and ;                                   : bswap dup 255 and 24 << (b) 16 << (b) 8 << (b) or or or or ;                                                                                                                                                                                                  ( == mem ====== : !! : c!! : -! )                                                                                               : !! over @ over @ swap rot ! swap ! ;                                                                                          : c!! over c@ over c@ swap rot c! swap c! ;                                                                                     : >swap< swap 2swap swap ;                                                                                                                                                                                                                                      \ !!    ( a1 a2 -- )                                            \   exchange cells in memory at a1 and a2                       \ c!!   ( a1 a2 -- )                                            \   exchange character sized memory content at a1 and a2        \ >swap< ( n1 n2 n3 n4 -- n4 n3 n2 n1 )                         \   revert order of top 4 sings on dstack                       ( == memory ======================================== : >move< )                                                                 if-nfound 7+    7 cons+ 7+                                                                                                      : >move<    ( a1 a2 u -- )                                        dup 1- 0< if 2drop drop exit endif                              dup 7+ 4/ >rr |loc                                              >r swap r bounds l0 r + -rot                                    do i @ bswap over ! 4- 4 +loop drop                             l0 4+ swap r> cmove r> minus |loc ;                                                                                                                                                                                                                                                                                           \ >move<    ( a1 a2 +n -- )                                     \   non-overwriting copy n bytes from a1 to a2 in reversed order( == loading ================================  : --> : \ : \\ ) hidden definitions                                                                                                              : [\]     forth                                                   blk@ if c/l in @ over mod - else 0in! -1 endif in +! ;        : [\\] blk@ if b/scr blk@ over mod - blk +! ;s endif [\] ;      : [-->]                                                           ?loading b/scr blk @ over mod - blk +! 1 scr +! 0 in ! ;                                                                      forth definitions                                               ' [\]   defer   \                               immediate       ' [\\]  defer  \\                               immediate       ' [-->] defer -->                               immediate                                                                                                                               -->                                                                     ( : source : if-true : ?? : dr? : bchan : if-found : if-nfound )forth definitions                                               if-found source 1 +continue                                     : source blk@ 1- 0< if tib @ #tib exit endif prev @ c/l ;                                                                       : dr? offset @ dup + 0< ;   ( drive no. )                       : bchan 1 and 7 + c@ ;      ( block-file specific i/o channel )                                                                 root definitions forth decimal                                  : if-true -exit [_] \ ;                           immediate     : found? -find dup 0= if ;s endif 2drop ;         immediate     : if-found  [_] found?    [_] if-true ;           immediate     : if-nfound [_] found? 0= [_] if-true ;           immediate                                                                     : ?? forth b/scr /mod "S emit . "B emit . "C emit . ;                                                                   -->     ( == loading ============= : l-load : lload : xlload : lload? )                                                                 : l-load       ( a1 a2 -- flg )                                   l-find -dup 0= -exit dup chmax <                                if 0 bchan - if dr1 else dr0 endif else using endif load ;                                                                    : lload        ( ccc, -- ( load ccc from current screenfile )     0 name l-load drop ;                                                                                                          : xlload       ( ccc, -- ( forcedly, lload from <f4x.scr> )       ?exec [ libdir count + 1+ ] literal name l-load drop ;                                                                        : lload?       ( ccc, -- ( {lload} if word ccc not found )        0 -find if 4drop exit here l-load drop ;                                                                                                                                                      ( == cpl =============== : 2constant : 2variable : defer : is ) forth definitions                                                                                                               : 2variable <builds (vp) @ , v, v, does> >body ;                                                                                                                \ non-alterable substitutes:    : 2constant <builds swap , , does> dup @ swap 4+ @ ;                                                                            : defer <builds cfa dup , , does> @ execute ;                   : is state@ if compile endif cfa [compile] ' ! ;    immediate                                                                                                                                                                                                                                                                   \ F4 compiles cons/vari to vmem, instead of dictionary, by      \ {v,}, {cv,}, {vallot}; ptr to vmem from disp at pfa & {>v     ( == cpl ================== : vcons+ : vcons* : cons+ : cons* ) forth definitions                                                                                                               : cons+  <builds , does> @ + ;                                  : cons*  <builds , does> @ * ;                                                                                                  : vcons+ <builds (vp) @ , v, does> >body @ + ;                  : vcons* <builds (vp) @ , v, does> >body @ * ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( == cpl ============================ : enter : entry : ascii ) forth definitions decimal                " nter" count drop @                                                                   : enter                                                           compile branch here [ dup ] literal 0 , ;         immediate   : entry                                                           2swap [ dup ] literal ?pairs here over- swap ! ;  immediate                                                            drop                                                                   : ascii bl word here c@ [compile] literal ;         immediate                                                                                                                                                                                                                                                                                                                                                                                                   ( == cpl ================================ : [f] : [_] : sfind ) root definitions decimal                                                                                                        : [_] ?comp -find 0= 0 ?error drop cfa , ;          immediate   \ : [_] -find 0= dup ?error state@ IF $c1 <                     \   IF compile compile ENDIF cfa , ;S ENDIF cfa drop ; immediate                                                                : [f] context @ >r [_] forth -find r> context !                   if state@ < if cfa , else cfa execute endif endif ; immediate                                                                 forth definitions                                               : sfind dup >r context @ (find) -dup 0=                           if r current @ (find) endif rdrop ;                           ( ..und manche schreiben "then" für "endif", aber das macht nix)                                                                                                                                ( == text == : >uc : >lc : /string : 1/string : s" : key/char ) forth definitions                                               : /string >rr - swap r> + swap dup 0< if + 0 endif ;            : 1/string 0max 0dup 0= -exit 1- swap 1+ swap ;                                                                                 : s" [_] " state@ if compile endif count ;  immediate                                                                           (asci) (up) - ucons [asci]                                      : [k>c] >r 2dup abs - [asci] r> >> #255 and < ;                 : k>c 0. [k>c] -exit drop 1 8 [k>c] -exit drop                    0 16 [k>c] -exit drop -1 24 [k>c] sdrop ;                                                                                     : key>char k>c dup -exit sdrop ;    ( c -- c 1|-1 | ff )        : >lc dup key>char 0dup sdrop 0< 0= -exit uc-lc ;               : >uc dup key>char 0dup sdrop 0> 0= -exit uc-lc ;                                                                               ( == text i/o ================================= : skip : scan ) forth definitions                       ( -?- )                                                                                 : skip >r                                                         begin dup                                                        if swap dup c@ r = if 1+ swap 1- 0 else swap 1 endif           until rdrop ;                                                                                                                 : scan >r                                                         begin dup                                                        if swap dup c@ r - if 1+ swap 1- 0 else swap 1 endif           until rdrop ;                                                                                                                                                                                                                                                                                                                 ( == text i/o =============================== : rskip : rscan ) forth definitions                       ( -?- )                                                                                 : rskip >r swap over + swap                                       begin dup 0dup if 1- swap 1- dup c@ r = endif until rdrop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ( == text =========================== : zcount : scount : -cr ) forth definitions decimal                                                                                                       : -cr if cr endif ;                                                                                                             : zcount 2dup 0 scan swap drop - ;                                                                                              : scount                ( a -- a' u )  ( counted or asciz stg )   count -dup -exit zcount ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( == text ============================================= : h>a ) forth definitions decimal                                                                                                       if-nfound 7+    7 cons+ 7+                                                                                                      : h>a base@ c->s 0= -exit "0 + dup ": < -exit 7+ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \ h>a   ( n -- n' )                                             \   convert numeric byte to the rsp. char code                  \   noop if @base = 256, 'ascii base'                           ( == util ========================================== : v2>pfa )                                                                 : v2>pfa >body pfa >body l>pfa v<nfa pfa ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ v2>pfa    ( pfa1 -- pfa2 )                                    \   convert pfa of a voc to it's 2nd-ary seacrh voc's pfa       ( == util == data-field w. hi-level def. word ======== : pfa+ )                                                                 : n <builds does> ; n nn ' nn @ forget n                                                                                        : pfa+ dup 4- @ [ dup ] literal - -exit 4+ ;                                                                                    : nfa dup 8- @ [ dup ] literal = if 4- endif nfa ;              : cfa dup 8- @ [ dup ] literal = if 4- endif cfa ;                                                                      drop                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ( == util == voc-nfa from vlfa ============== : v<nfa : words ) forth definitions decimal                                                                                                       : v<nfa ( a -- pfa (          a = voc def-block voc-link posn )   [ ' here dup cfa - ] literal + nfa last @                       begin 2dup pfa +@ - while t<nfa swap drop dup 0= until sdrop ;                                                                : words context @ voc-link    ( display all words of all vocs )   enter begin dup 4- context ! vlist cr                           entry +@ -dup 0= ?esc or until context ! ;                                                                                                                                                                                                                                                                                    \ : words last @     ( --     ( short, most simple substitute ) \   begin dup id. t<nfa swap drop -dup 0= until cr ;            ( == util =========================================== : words ) forth definitions decimal                                       if-nfound >v  hex 2081 decimal constant |voc                    if-nfound |voc ' forth @ >v w@ constant |voc                                                                                    : words max-xy drop 8- voc-link                                   begin +@ dup                                                    while cr dup dup 4+ v<nfa id. cr 4- @ 0 >r                       enter begin                                                      dup c@ $1f and 2+ r> + dup 4 pick > if 0= cr endif >r           dup id. n<nfa                                                  entry dup w@ |voc = over @ 0= or until rdrop drop              repeat 2drop cr ;                                                                                                             \ words         ( -- )                                          \   display all words of all vocabularies, in voc-link sequence ( == util == word + its voc ============================= : v ) forth definitions decimal                                                                                                       \ hex 2081 decimal constant |voc                                ' forth @ >v w@ constant |voc                                                                                                   : v if-found  -afind -afind ( search all vocs )                     if-nfound -afind -find  ( search chained context, only )      0= if 0 message ;s endif dup nfa dup id.                        begin n<nfa dup w@ |voc = until pfa cfa v<nfa id. cfa 16 b. ;                                                                                                                                                                                                 \ n<nfa ( nfa1 -- nfa2 ) returns next nfa in wordlist which,    \ ends with the dummy name "|voc" in vocabulary header block.   \ v<nfa ( vcfa -- nfa ) returns the rsp. vocabulary name's nfa  (  : :locals : locals; : >loc : loc> : -loc : (locals : locals)                                                                 forth definitions                                                                                                               : -loc -dup 0=          ( +/-bytes -- cells +/-aligned sign   )   if rdrop exit endif                                             >rr abs 3 + -4 and r> +- >rr r abs 4/ swap r> 0< ;                                                                            if-nfound l0 (up) @ 4 (up) +! ucons l0 ( locals base ptr : l0 )                                                                                                                    -->                                                                          \ -loc      ( +/-bytes -- cells +/-aligned sign )               \   prepare parameters for 'local's de-/allocation.             \ l0        ( -- a )                                            \   'local's reference, base address of local data space.       ( ==== de-/allocate local memory ==============   >loc   loc> ) hidden definitions                                                                                                              : >loc 4* -loc 3 ?error >r         ( n -- ( alloc local cells )   0 do 0 depth 1- minus roll loop r> s0 dup @ to l0 +! ;                                                                        : loc> 4* minus -loc 0= 3 ?error   ( n -- ( de-alloc locals   )   s0 dup @ to l0 +! >rr 0 do depth 1- roll loop r> ndrop ;                                                                      : |loc dup 0< if minus loc> exit endif >loc ; ( F4 kernel word)                                                                                                                            -->  \ >loc          ( n -- )        allocate n local cells          \ loc>          ( n -- )        de-allocate n local cells       \ |loc       ( -/+n -- )        de/allocate -n/+n local cells   \   |loc is the basic F4 kernel word; re f4x.scr                ( ==== local variables ================== : :locals : locals; ) forth definitions                    if-nfound -loc lload -loc                                    if-found :locals 4 +continue  \ top local item at index 0, @tos before allocation.            \  ( n -- )      alloc & init top +n local cells from dstack    : :locals 4* -loc                                                 3 ?error >r 0 do depth minus roll loop r> s0 dup @ to l0 +! ;                                                                                                   if-found locals; 3 +continue  \  ( n -- )      discard top n cells of local datapace          : locals; 4* minus -loc 0=                                        3 ?error s0 dup @ to l0 +! >rr 0 do depth roll loop r> ndrop ;                                                                                                     lword @ 0= if-true -->                     -l :locals -l locals; or if-true ;s                                                                             ( ==== local variables ============================ : l@ : l! ) forth definitions                                                                                                               if-nfound l@ : l@ depth + pick ;           -wl l@ if-true ;s    if-nfound l! : l! depth + 1- minus pick ;  -wl l! if-true ;s                                                                                                                                                                                                                                                               -->  \                                                               \ l@            ( n --x )                                       \   fetch n-th local, n=0 is 1st                                \ l!            ( x n -- )                                      \   store x to n-th local                                       \   l@, l! don't require the rsp. locals defined in current word\   & may refer to any levels' local memory, in the actual order( ==== local variables ========================== : l@n : l!n ) forth definitions                            lload l@ lload l!                                                                  : l@n <builds c, does> c@ l! ;                                  : l!n <builds c, does> c@ l@ ;                                                                                                  0 l@n l@0       1 l@n l@1                                       0 l!n l!0       1 l!n l!1                                                                                                                                                                                                                                                                                               -->                                                                     \ l@n   ( ccc, n -- (X: -- n )                                  \ l!n   ( ccc, n -- (X: n -- )                                  \   defining locals fetching/storeing words                     ( == fetch/store local doubles by named disp ==== l2@n : l2!n ) forth definitions decimal                                                                                                       : l2!n  ( ccc, index -- (X: dn -- )                               create not 8* here 20 allot ' l2!0 cfa @ over 20 cmove          over 4+ over 11 + c! 8+ c! unsmudge ;                                                                                         : l2@n  ( ccc, index -- (X: -- dn )                               create not 8* here 13 allot ' l2@0 cfa @ over 13 cmove          over 4+ over 10 + c! 6 + c! unsmudge ;                                                                                        0 l2@n l@0       1 l2@n l@1                                     0 l2!n l!0       1 l2!n l!1                                                                                                                                                                                                                                     ( ==== local variables ====================== (locals   locals) forth definitions                                                                               if-found (locals 1 +continue    : (locals 1+ dup :locals ; ( n -- )                                                             if-found locals) 1 +continue    : locals)  0 l@  locals; ; ( - -- )                                                                                                                                                                                                                                                                                             \ (locals       ( n -- )                                        \   initiate n local cells from dstack                          \ locals)       ( - -- )                                        \   de-alloc latest by '(locals' installed local cells          \   top local item at index 1, @tos before allocation.          \   size by above words stored to/fetched from posn 0.          ( == Linux/ELF ===================================== : hash11 )                                                                 : hash11 >r 0 swap      ( a u -- n )                              enter begin c@+ rot 4 << + dup 0xf0000000 and \ n a -- a n'      -dup if >rr 24 >> xor r> not and endif swap                    entry r> 1- >rr 0< until rdrop drop ;                                                                                                                                                                                                                         \ from the ELF document:                                        \     unsigned long h = 0, g;                                   \      while (*name)                                            \      { h = (h << 4) + *name++;                                \        if (g = h & 0xf0000000); h ^= g >> 24;h &= ~g;         \      }                                                        \      return h;                                                ( == Linux/ELF =================================== : elf-hash )                                                                 : elf-hash                                                        0 swap count bounds 1- swap 1-                                  do dup 17 << i c@ + + dup 4/ xor -1 +loop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ elf-hash      ( a -- n )                                      \   hash function from binutils/bfd/elf-strtab.c                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                