 ( ******************* F6 : SCREEN-EDITOR ******************* )                         for the QL & TK2                                      COPYRIGHT 1995 h.-peter recktenwald                                      d-12159 berlin                                                   albestr.  21                                                                                             needs "forth_scr" in same dir, or "flp1_", "flp2_", "win6_gf_"           and L-LOAD from "forth_scr" already present                                                                              F6 and its texts or programs may only be copied, used, or        given away according to the GNU General Public License.     F6 mit Texten und Programmen darf ohne Zustimmung des Autors nurgem€œ der GNU-Lizenz benutzt, copiert oder weitergegeben werden.                                                                      - "fig_scr" 6.6 - the latest version of F6 is 8.18 -        1st: 1993 Jul 14 19:41     µ     latest: 1998 Apr 24           ( ****************** F6 : SCREEN : EDITOR ****************** )                                                                         forth if-found view ;s                                          editor if-found ebuf ebuf if-found heap-clr heap-clr            also forth definitions decimal                                  also hidden (prompt) on previous 0 is db-on                     -forget hp also forth also also mem constant hp                 0 variable drv f/n allot                                        drv screen !chname (boot) screen !chname                        drv -count {_ -scan dup 0> - {_ -scan (boot) ! drop             (boot) dup " forth_scr" +text 1 work open work close    ( {*} ) if-true drop ftest flp2_forth_scr                               dup if-true drop ftest win6_gf_forth_scr                        0=  if-true if-nfound -lword (boot) f/n pad !name                                                               -->     ( {*} ( change here for another source of "forth_scr"        )                                                                  if-nfound -lword l-load                                                                                                                         l-load history  l-load heapmem                                  l-load w#0      l-load backup                   if-nfound bh    l-load chans                                                    l-load where    l-load dir                                      l-load printer                                                                                                                                                                                                                          -->                                                                                                                                                                                                      6 load pick-4th cr tick d. hp mem - #. .( bytes ) mem #. cr ;s                                                                 --> ******************  F6 SCREEN EDITOR  ****************** <--                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                --> ******************  F6 SCREEN EDITOR  ****************** <--EMPTY STACK                                                     DICTIONARY FULL                                                 HAS INCORRECT ADDRESS MODE                                      ISN'T UNIQUE                                                                                                                    DISC RANGE ?                                                    FULL STACK                                                      DISC ERROR !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    --> ******************  F6 SCREEN EDITOR  ****************** <--                                                                                                                                CONDITIONALS NOT PAIRED                                         DEFINITION NOT FINISHED                                         IN PROTECTED DICTIONARY                                         USE ONLY WHEN LOADING                                           OFF CURRENT EDITING SCREEN                                      DECLARE VOCABULARY                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( deferred )   only forth also definitions decimal       (  6   {3  constant dr#         \ ascii top dft flp-drive number           defer   ehlp         \ fetch & display helpscreen               defer   >prae        \         --  ( editor preprocessing       defer   prae         \         --     ( key preprocessing       defer   edi-key      \ key key -- key idx ( key decoding        defer   edi-case     \ key idx -- key     ( decoded actions     defer   post         \ key     -- flg ( key postprocessing      defer   >post        \         --  ( editor postprocessing   also qdos also editor also definitions                         0.  constant (in)  constant (bk) \ temp for current in & block      defer   K>           \ cursor                                   defer   (v)          \ temp.                                    defer   (p)          \     exvec                                defer   (i)   -->    \ emit mode                                                                                            ( local, screenfile )                                      ( 7          defer   .l               \ type one line                        defer   pcr     defer PL \ print cr (bh) list to printer        defer   (tt)    defer (tb) \ TAB switching & range              defer   (tc)             \ TAB case                             defer   ltype            \ display (fast vs safe)        ' type is ltype ' ptype cfa ' ltype 2+ !                       here 0 c, 7 c, 2 c, 0 c, 4 c, 5 c, 6 c, 7 c,                    : co [ dup ] literal + c@ ; drop       \ colours                               8 constant tabs         \ standard tab spacing                  0 constant oc           \ std. open-code                   c/l 4+ constant b-len        \ one line in memory     b/buf 4+ b/scr * constant blen         \ scr-len + header bytes : p-len b-len b/scr * mem 2 u/ umin ;  \ one screen in memory         if-nfound max-scr 0 constant max-scr                      $7fff b/scr /    is max-scr       -->  \ max no. of screens/file( memory & vari, window ctrl )                           (  8                                                                   blen              heapmem EBUF      \ editor heap memory        blen 2*          constant elen      \ length of screen buffer   ebuf elen m+    2constant edi       \ aux buff                  edi blen m+     2constant hlp       \ helpscreen buffer         0. constant lb constant wd  0. variable s1 variable s2          0. variable c# variable ss  0. variable sr variable ie          0. variable sc variable sf  0. variable sm constant os          -1 constant mk                                                                                                                  : (lo) to-work flen c/scr m/ rot ! drop ;                       : (loc) sf file (lo) sc screen (lo)                               w#0 chenq is wd 20 min is lb 2drop ;                                                                                  -->                                                                     ( memory & vari, window ctrl )                            ( 9                                                                    if-found fbf           1 +continue                             p-len 2*         cons+ fbf          \ find-buffer on top of pad b-len fbf        cons+ rbf          \ replace-buffer            screen           constant (work)    \ current screenfile name    if-found fbuf          1 +continue                             : FBUF pad fbf ;                    \ find-buffer               : RBUF pad rbf ;                    \ kbd ovf buf               : f-count fbuf -count sdrop ;       \ len in find-buf           $2020 variable spc spc 2+ c/l b/buf max dup allot blanks         f-name mdn        f6wrk                                         f-name msg        win6_gf_msg_scr  \ help-text                  f-name (workfile) flp1_    (workfile) f/n (screen) !name  -->                                                                                                                                  (                         )                              ( 10                                                                   : CLRT pos curdis spc c/l rot - type 0 at ;  \ clear till eol   : 0s 0 co strip ; ( 0 )        : nco 2 co strip space ; ( 2 )                                                                   : u d/wpt -EXIT update ;                                                                                                         if-found pstrg-l       -->     ( printable strg to workch.     : x drop {. ;                                                   : pstrg-l also fp dup previous dup 0> IF 1- 0 ( d.adr len -- flg   DO 2>rr count-l dup                                              range: 32 127 128 ; case: x noop x noop ; 2r> c!l              LOOP 2drop sstrg-l ernum or ;S                                 ENDIF 6 ndrop 1 ;     -->                                                                                                                                                                     (        screen parameter )                              ( 11                                                                   : scr@ scr @ os + ;                        \ adjust scr #                                                                       : >scr< scr@ + max-scr min os sm @ over + within ;              : >scr >scr< os - is scr ;                 \ scr# within file   : scr+ 1 >scr ;                            \ next scr           : scr- -1 >scr ;                           \ previous scr                                                                       : >cl< 0 c/l within ;                      \ -1 < n < c/l+1                                                                                             -->                                                                                                                                                                                                                                                                                                     ( memory & vari, window ctrl )                           ( 12                                                                   : (cp) pad c/l over c! 1+ c/l blanks ;     \ clr top line of pad                                                                 if-found >chan<        4 +continue                             : s><f (screen) here f/n cmove             \ xg filenames & id's  (file) (screen) f/n cmove here (file) f/n cmove                 screen ch-id file dup screen to-chan set-chan ;                                       2 +continue                             : s><f here (screen) over f/n cmove                               (file) dup (screen) f/n cmove f/n cmove screen file >chan< ;                                                                  : w-cls spc c/l wd min lb 0>               \ cls editting area    IF -1 lb 1- DO i 0 at 2dup type -1 +LOOP ENDIF 2drop ;                                -->                                                                                                     ( cursor posn ) only forth qdos pif forth also qdos forth ( 13                  also editor also definitions                    \ voc-stack: editor editor forth qdos pif                                                                                       : line b/scr /mod >scr< (line) drop ; \ current lineaddress                                                                     : #locate r# @ c/l /mod ;          \ - curs. col row            : #row #locate sdrop ;                                          : #line #row line ;                \ - lineaddr                 : #lead #locate line swap ;        \ - lineaddr curs.coln       : #lag #lead >rr + c/l r> - ;      \ - cur.adr cnt.after.cur    : #char #lead + c@ ;               \ - char at curs.                                    -->                                                                                                                                                                                                                                     ( move memory )                                          ( 14                                                                   : -MOVE line c/l cmove u ;              \ ptr n -- to line n                                                                    : x- swap cmove ;                                               : -x -rot cmove ;                                               h] pad p-len 2dup + ; dup               \ one screen + head     : PAD> h, x- ;                          \ temp save pads        : >PAD h, -x ;                          \ restore pads                                                                          : CPAD rbuf b-len 2* + sp@ > -3 ?error  \ init. clear pads        pad fbuf over- b-len 2* + 2dup blanks                           bounds DO c/l i c! b-len +LOOP pad> fbuf off                    " HELP ñ F1" count-w rbuf 6+ swap cmove ;                                                                             -->                                                                     ( curs lines, curs display )                             ( 15                                                                   h] @ 0max dup c/scr < IF over swap c/l /mod                       swap rot co strip 2dup at over line over + c@ emit              rot IF at 0s ;S ENDIF ENDIF 2drop ;  dup                      : CSR in>w curdis 0 c# h, 4 r# h, r# c# @! ; \ display cursor                                                                   : bot+ create , ;Cdoes> lb + 0 at ;          \ curs from bot up   -3 bot+ >K  -2 bot+ P>  -4 bot+ O>  -1 bot+ >U ' >k is k>                                                                     : >p p> 1+ -print pos clrt at ;                                 : P" [compile] " compile >p ; immediate      \ write to pad     : r/o d/wpt (update) @ 0= or dup             ( -- ff              IF bell >u ." read only " ENDIF 0= ;                                                                                  -->                                                                     ( buffering, editting input )                            ( 16                                                                   h] count >cl< dup IF 4 co strip      \ display one line from mem  sover ptype 0s spc c/l rot - 0max type ;S ENDIF 2drop ; dup   : P? p> pad h, nl pad b-len + h, >k ; \ show top 2 pad lines                                                                    : pc pad count ;                     \ string ptr & count       h] pad> >k emit clrt bell (cp) c-key (p) >k clrt ;  dup         : (s#) ' s# is (p) {# h, ;           \ number from keyboard     : (s@) ' s@ is (p) 1 {$ h, c/l pc sover + -rot - blanks ;       : (e@) >k clrt c-key e@ ;            \ -- f ( editting kbd input                                                                h] pad p-len b-len - over b-len + ; dup  \ push & pop pads      : PAD- h, x- p? ;                    \ push pad                 : -PAD h, -x p? ;       -->          \ restore pad                                                                              ( listing )                                              ( 17                                                                   : mss ebuf d0= 0= dup                  \ -- ) flg ss own  buffer  IF ebuf elen m+ 2dup is edi blen m+ is hlp ENDIF is ss ;      : .b+ scr+ scr@ b/scr * b/scr          \ find-screen to blockmem  bounds DO i block drop LOOP ;                                                                                                 h] pon IF p'prt cr ENDIF ; dup ' pcr 2! \ <nl> to printer       : (l) dup 0 at dup line                \ (n-) list/store line n   io-err 1+ s->d swap -9 =/= and sdup c/l ltype pcr               ss @ 0= IF drop sdrop ELSE swap -dup -EXIT base+ ebuf 4 roll    b-len * 2+ m+ c/l cmove-l scr@ ebuf !l 0 ENDIF ;                              ' (l) cfa dup ' .l 2!                           : l. b/scr swap DO i .l -leave LOOP ; \ n-) till e.o.s.                                 -->                                                                                                     ( info lines )                                           ( 18   : pf is-open                                                      IF nco 2* co strip 1+ count 2dup >cl< ltype ENDIF 2drop nco ;                                                                 : .F o> curdis ." s:" scr@ dup 0 3 d.r ." /" sm @ 0. d.r          b/scr * r# @ b/buf / + ."  b:" 0 4 d.r ss @ mss ss @            IF ."  u:" ebuf @l 0 3 d.r ENDIF is ss mk 0< 0=                 IF ."  m:" mk 2 .r ENDIF offset c@ $40 and                      0= (screen) over 0= screen pf (file) swap file pf 0s ie @       IF ." O" ELSE ." I" ENDIF 2 co strip clrt 0s ;                                                                                : U? .f >u r/o drop screen is-open                                IF ."  update " (update) @                                       IF ." en" ELSE ." dis" ENDIF ." abled and "                     prev @ @ 0< 0= IF ." un" ENDIF ." set"                         ELSE ."  screefile not open " ENDIF clrt ;            -->     ( rfsh screen, updt, keybd response )                    ( 19                                                                   : UO (update) 1+ dup 1 toggle c@      \ tog update dis/enabling   0= IF prev @ dup @ abs swap ! update-off ENDIF u? ;           : L curdis                                                        trap0s ss @ sr +! 0. >scr l. ss off trap0r nl p? .f ;         h] l p-prt p-on 0 l. .f pcr pcr p-off ;    dup ' PL 2!                                                                          : SV mss l ;                          \ store screen            : RF 2 co paper oc IF w-cls ENDIF     \ rfsh screen               0s sv u? >k rbuf count-w >cl< ptype k> ;                      : EMOV w#0 in-cons wmov (loc) ;       \ move window                                                                             : Y/N bell ." ? y/n/q" c-key key bl or >k clrt    \ -- flg )      associative: {y {j {q {v ;          \ keys: yY jJ qQ vV         case:   #1 #1 #-1 #-1 #0 ; ;   -->  \ 1 yes / 0 no / -1 quit  ( 1st/2nd screenfile select )                            ( 20                                                                   : (so) empty-buffers screen (screen) c-open ; \ typ -- tf (open                                 safe! here sp@ over- erase      : (scf) here f/n (screen) !name       \ scrptr --(new screenfil   (screen) +nul (e@)                                              IF (screen) f/n pad !name ENDIF                                 (screen) dup @ 2+ (file) w=         \ check 2nd file            IF scr swap @! file screen to-chan ELSE drop ENDIF              screen is-open -dup 0= IF oc (so) ENDIF 0=                      IF p" create file" (screen) 0 work pf                            y/n 0> IF 2 (so) IF scr off ENDIF ENDIF                        ENDIF screen is-ochan -EXIT         \ ? open old file again     dr0 (screen) f/n here !name oc (so) drop ;                                                                            -->                                                                      ( disk data ) also forth also definitions decimal       ( 21                                                                   : workfile                             \ find file & chan in use  (workfile) f/n edif dup is (work) to-work !name ;                                                                             : f-xinf workfile                      \ std. qdos-data           0. is a/fre 0. is a/drv (work) 2+ dup 3+ c@ 15 and is d/num     4 4 512 is b/alc drv ! mdn ! dup drv 2+ 2@! mdn 2+ 2@!          pad> pad xinf 0=                                                IF drv dup off                                                   pad dup 2dup also fp dup previous mdn dup off over +text        $1d + c@ is d/wpt $1e + @ is b/alc $20 + 2@ is a/drv            $2a + @ is b/hed $1c + c@ is d/num $24 + 2@ is a/fre            $16 + +text d/num $30 or >< 1 sp@ drv swap +text 2drop         ENDIF w#0 >pad ;                                -->                                                                           ( 1st/2nd screenfile select ) editor definitions         ( 22                                                                   : (u) pad>      ( scrptr txtptr -- ( screenfile from kbd input    p" [new " 1+ -print ." file]" clrt screen close                 sc off ' os off (scf) screen is-open 0= -7 ?error               (loc) >pad f-xinf mss r/o drop ;                              : s>s dup @ -EXIT scr @ over ! ; ( ptr -- ptr ( store scr#                                                                      : USING" w#0 s1 s>s " screen" (u) rf sc sm @! l ; \ 1st file                                                                    : 2ND" file is-open dup                            \ 2nd file     IF drop p" close 2nd file" y/n dup 0>                           IF drop file close p" open 2nd" y/n 1- ENDIF ENDIF 0< 0=        IF s><f sc @ s2 s>s " 2nd "(u) sc dup sm @! sf @! is sc s><f    ELSE offset off s1 scr @! ENDIF l ;      -->                                                                                  ( toggle 1st/2nd screenfile )                            ( 23                                                                   : SHD                \ toggle files, open if necessary            ' os off scr @ $40 offset 2dup swap toggle c@ and               IF is s1 s2 @ -dup IF is scr ENDIF                               file is-open 0= IF 2nd" ELSE (loc) ENDIF sf s2                 ELSE is s2 s1 @ -dup IF is scr ENDIF                             screen is-open 0= IF using" ELSE (loc) ENDIF sc s1             ENDIF scr @! sm @! f-xinf rf ;                                                                                                h] scr @ sm scr @!   \ append or truncate to flen of sm screens   b/scr 1- line drop workfile fpos -2048 m+ d0<                   0= IF fstrunc ENDIF w#0 u u? (loc) sm @ min is scr ;  dup                                                             -->                                                                                                                                     ( append/truncate screenfile, 1line )                    ( 24                                                                   : S+                                    \ append one screen       workfile flen c/scr m/ 1+ is sm drop h, ;                                                                                     : S-                                \ truncate to current scr >1  p" truncate to #" scr ? y/n 0> 0= -EXIT scr sm @! h, ;                                                                         if-nfound joker -1 constant joker      \ set to any char                                                                       \ updt curs & ret flg : scan ptr len for match to fbuf text     : 1LINE (joker) >r joker is (joker)     \ ptr len -- f            fbuf -count match r# +! r> is (joker) ;        -->                                                                                                                                                                                                            ( line# editting )                                       ( 25                                                                   : H pad- line c/l pad c! pad 1+ c/l cmove p? ;   \ n -) to pad  : O ss @ ss off #row .l drop is ss csr k> ;   \ redraw curs line                                                                : (e) line c/l blanks u ;                                       : E (e) u? l ;                                \ n -- )blank line: >S dup 1- b/scr 2- DO i line i 1+ -move -1 +LOOP e ; \ spread h] b/scr 1- dup rot DO i 1+ line i -move LOOP e ; dup \ drop    : D dup h h, ;                                \ pad & drop      : -C #row h, ;                                \ clear line                                                                      h] pad 1+ swap -move ; dup                                      : RL h, l ;                 \ n1 -- replace line n1 from pad    : IL dup >s h, -pad l ; --> \ n -- drop text from pad to line n                                                                 ( current line editing )                                 ( 26                                                                   : -H #row h csr ;                       \ hold in pad           : -E #row e ;                           \ erase                 : -S #row >s ;                          \ spread                : -R #row rl ;                          \ replace from pad      : L+ scr+ mss l ;                       \ list next screen      : L- scr- mss l ;                       \      previous         : (l#) scr @ - >scr ss off l >pad ;     \ scr -- ) goto scr     : L# p" goto scr#" (s#) (l#) ;          \ standard: enter scr#  : b>r b/scr /mod scr @ - >scr c/l * is r# ; \ block -> cursor   : B# p" goto line#"(s#) b>r l >pad ss off ; \ ALT/TAB: line#    : -I #row il ;                          \ insert                : -D #row d ;                           \ delete & save in pad                                                          -->                                                                     ( cursor )                                               ( 27                                                                   : (m) r# @ + scr@ c/scr m* rot m+ c/scr m/ scr@ - dup             IF >scr l ELSE drop ENDIF 0max is r# ;                                                                                        : M (m) o ;                 : -M (s#) m >pad ; \ n -) move curs : CF f-count (m) ;          \ forward by length in find buffer  : B f-count minus (m) ;     \ back                                                                                              : C-L -1 (m) ;              : C-R 1 (m) ;                       : C-D c/l (m) ;             : C-U c/l minus (m) .f ;            h] r# @ over mod - (m) ; dup                                    : C-T tabs h, ;            : C-sT tabs minus h, ;               : N-L #lag sdrop (m) .f ;                                       : E-L n-l c-l ;             : S-L n-l c-u ;             -->                                                                     ( string find )                                          ( 28                                                                   : F? .f p" searching:" fbuf -count >cl< ptype ;                                                                                 \ find from scr#0 on, which results to changed flag values:     \ -- scr# | -1 ) search screenfile for string at fbuf, or <esc> : FIND ss off             \ flag:=scr# if string from fbuf found  scr @ 0 sm @ within dup is scr os sover + 0max >r               sm @ + 1- c/scr 1-      \ last scr, last char                   BEGIN dup r# @ < dup                                             IF drop over scr@ < dup IF -1 >r ENDIF .b+ r# off ENDIF         #lag 1line or                                                   ?esc IF drop 1 r 0< 0= IF rdrop scr@ -1 2>r ENDIF ENDIF        UNTIL 2drop r r> 0< 0= IF sr off l ;S ENDIF                     r> os - is scr l f? ncol -7 message ;                  -->                                                                    ( string match )                                         ( 29                                                                   : (f@) pad> fbuf 1- 0 over c!               \ input to find buf   " find:" (e@) pad 1+ fbuf c/l 1+ cmove >pad ;                                                                                 : N pad> f? c-r find b drop >pad ;  \ find next prev. text      : F (f@) 0= -EXIT n ;               \ find text from keybd input                                                                 ( prep. string & hotkey input )                                h] pad dup off 1+ swap hot@ 2dup swap 1- c! ; dup \ fetch hotbf : h-get 0 h, ;                                    \ 1st         : h-nxt -1 h, ;                                   \ next        : c-h o >k clrt                                                   pos drop #locate drop at bell 1 s@ pc ;         \ input                                                               -->                                                                      ( backup editfile )                                     ( 30                                                                   : wf>pf (workfile) pad f/n cmove ;                              \ main procedure {-bup} taken from "forth_scr"                                                                                  : bed workfile w#0 p" backup " (workfile) -print                  y/n 0> 0= -EXIT                                                 pad> p" to file" wf>pf p>move pad dup 2- dup off                dup 7+ dup c@ 1+ {1 dr# wraps swap c!                           (e@) clrt IF 1 -bup ENDIF w#0 >pad ;                                                                                  -->                                                                                                                                                                                                                                                                                                                                     ( prep. string & hotkey input )                          ( 31                                                                   \ insert-action                                                 : (c) pad> o> (v) over c@       ( ptr+ count ( source stg         IF u #lead here 2dup + >r dup c/l blanks swap cmove              sover r> 2dup + >r swap cmove                                   #lag rot over min -rot                                          r> swap cmove here #line c/l cmove u r# +!                     ELSE 2drop ENDIF o o> clrt >pad p? clrt ;                                                                                                                                             -->                                                                                                                                                                                                                                                                                                                                     ( string input, hotkey buffer )                          ( 32                                                                   \ : C ' c-h is (v) o> #lead type       \ (n.i.) from keybd input\   4 co strip #lag sdup c@ emit 1+ swap 1- 0s type csr (c) ;                                                                   : C-P pad> -h pc -trailing hot! drop >pad ; \ push to hk                                                                        : D-I ' date$ is (v) (c) ;                  \ write date$       h] is (v) r# @ (c) is r# #row .l drop p? ; dup                  : C-G ' h-get h, ;                          \ 1st hotkey buf    : C-N ' h-nxt h, ;                          \ next hk.buf                                                                       : -EMIT dup #10 = 1- and -dup IF #lag (i) u ENDIF 1 ;                                                                           : C-W drop p" char#" (s#) -emit o ;         \ inst any char                                             -->                     ( delete text )                                          ( 33                                                                   : DELETE c/l mod >r #lag over r over \ n-)clr at cursor by count  >r - swap >rr cmove 2r> + r - r blanks r> minus r# +! u o ;                                                                   : TILL p" delete till " (f@)     \ del till textend               0= -EXIT #lead + #lag 1line 0= -EXIT #lead + swap - delete ;                                                                  : X p" delete " (f@)             \ del next occurrence of text    0= -EXIT find 0< -EXIT f-count delete ;                                                                               -->                                                                     : DELETE c/l mod >r #lag + u r - \ n-) clr back at cursor         #lag r minus r# +! #lead c/l mod + swap cmove r> blanks u o ;                                                                                                                                 ( replace text )                                         ( 34                                                                   \ find strg, quest., if: back curs, till, inst strg, else: next                                                                 : (rp) f-count delete pc ;       \ backup, delete, pad count                                                                    : RPL sr @ sr off p" replace" (f@)                                IF f? find 0< 0=                                                 IF ' (rp) is (v) (s@)                                            BEGIN csr >u ." replace" y/n 1+ dup  ( y:1½2 q:-1½0 n:0½1        IF 2- 0= IF (c) ENDIF f? find 1+ ENDIF 0=                      UNTIL >pad                                                    ENDIF ENDIF is sr ;                                                                                                   -->                                                                                                                                     ( write/ {toggle} emit chars )                           ( 35                                                                   : (ins) -dup                                \ insert              IF 2dup + 1- c@ rbuf dup dup @ >cl<       \ update ovf buffer    1+ dup 1+ rot dup 1+ rot cmove over ! 2+ c! 1- dup              IF 2dup over 1+ swap cmove ENDIF         \ write char           curdis -rot sover c! over 1+ type -1 1 r# +!                   ENDIF =/= ;                                                                                                                   : (ovw) drop 2dup c! swap sbyte pcol ernum 2drop 1 r# +! ; \ ovw                                                                : C? 256 0 DO i 32 192 within?  ( display non printable chars     0= IF i i i 10 = + emit 4 .r 3 spaces ENDIF LOOP ;                                                                                                                                    -->                                                                     ( inst from ovf-buf )                                    ( 36                                                                   : TE ie dup @                 \ toggle emit insert/overwrite      IF ' (ins) ELSE ' (ovw) ENDIF is (i) 1 toggle .f o ;                                                                          : KI pad-                                   \ temp store pad      rbuf 1+ pad over c@ >cl< 1+ cmove p?      \ ovf-buf to pad      ." insert" y/n 1+ -dup                    \ quest               IF 1- 0>                                  \ esc or               IF ' pc is (v) (c) o ENDIF               \ move chars yes/no    p" clear keybord-ovf" y/n 0>             \ esc/no or            IF rbuf off ENDIF                        \ clear buf           ENDIF -pad ;                              \ restore pad                                                                                                                               -->                                                                     ( delete chars )                                         ( 37                                                                   : DEL-L 1 delete ;                                                                                                              : DEL-R #locate drop 1+ c/l =               \ del chars           IF bl #line c/l 1- + c! u ;S ENDIF 1 r# +! del-l ;                                                                            h] #lead ++ c@ bl = over = r# @ ;     dup dup                   : DEL-WL r# @ 0> 0= -EXIT 1 -1 h, drop sdrop u #locate drop 0     DO -1 [ rot ] h, 0> and IF del-l ELSE leave ENDIF LOOP drop ;                                                                 : DEL-WR #lag swap c@ bl = swap 0           \ del words or bl's   DO 0 [ rot ] h, c/scr < and IF del-r ELSE leave ENDIF           LOOP drop ;                                                                                                           -->                                                                     ( split lines, prep. join )                              ( 38                                                                   : SL pad-                                  \ split line at curs   r# @ -h -i #lag blanks o                                        c-d r# @ - dup IF #lead blanks o ENDIF                          1+ 0> IF -pad ENDIF c-u ;                                                                                                     \ for join:  find the next word or return a false flag          h] #row #lag swap bl enclose dup r# +!  \ -- ptr len | 0 )        4 roll < 4 roll #row = and                                      IF over- -rot + swap ;S ENDIF 2drop 0= ;                                                                   -->                                                                                                                                                                                                                                                                                ( join lines )                                           ( 39                                                                   : JL trap0s ss @ ss off                 \ no screen rfsh          r# @ #lag bounds 1- dup rot 1-        \ keep curs               DO i c@ bl - -leave -1 +LOOP          \ find last char+blank    l<i drop - minus dup 0= over 0>       \ in curs line & store    2* ++ m r# @ n-l                      \ cursor, goto next line  ENTER BEGIN                           \ find (next) word         1+ dup r# @ 2>r rot is r# dup #lag rot > >rr                    IF sdup r# +! cmove                  \ move one word & bl       ELSE fdrop ENDIF                                                o u r# @ r> 2r> is r# swap           \ exg curs, make..         IF delete ELSE drop #locate drop r# +! ENDIF o u               ENTRY [ rot ] h, -dup 0=              \ find (next) word        UNTIL drop is r# o >k is ss trap0r ;  \ ..changes permanent                                                           -->     ( refresh, screen from/to buffer)                        ( 40                                                                   h] 1 max is scr r# off c# off rf ; dup   \ top of new scr       : RS 1 h, ;                             \ rfsh & go to 1st scr  : RE sm @ 1- h, ;                       \ go to last scr                                                                        : BK ss off sr @                        \ restore screen          0= -EXIT scr@ ebuf @l - -EXIT         \ from screen buffer      ebuf 2 m+ b/scr 0                                               DO 2dup i b-len * m+ i line base+ c/l cmove-l u LOOP            2drop l mss ss sr @! ;                                                                                                                                                                -->                                                                                                                                                                                                     ( flush, clear )                                         ( 41                                                                   : EFLUSH r/o IF workfile flush ernum 2drop ENDIF w#0 k> ;                                                                       : (ab) dup sm @ os + - dup 0>  \ append blocks if dest# > max#    IF over + b/scr * over 1- b/scr *                               DO i block c/l blanks u LOOP is sm ;S ENDIF 2drop ;                                                                            \ n-) clear screen {n} and write screen-number to 1st line     : CLEAR dup sm @ max-scr within (ab) dup is scr 0 (e)             0 <# bl hold #s bl hold {( hold #> c/l over-                    1- 0 line + swap cmove u b/scr 1 DO i (e) LOOP ;                                                                              : CLEAR# p" clear #"(s#) -dup IF clear eflush l ENDIF >pad k> ; : C-PAD (cp) p? ;                -->       \ clr top line in pad                                                                ( copy )                                                 ( 42                                                                   h] b/scr * swap b/scr * b/scr           \ copy single             bounds DO dup i block 2- ! 1+ u LOOP drop eflush ;                                                            dup is (in)     : (co) offset @ IF offset @ b/scr / - ENDIF max (ab) ;          : (cy) 2dup (co) h, ;                   \ n1 n2-) from 1n to n2                                                                 : (cm) -dup 0> IF                       \ copy multiple if > 0     -rot offset @ b/scr / + 2dup - sgn -dup     \ beyond flen       IF 4dup drop rot sover + -rot + (co)        \ append blks        swap 2swap swap bounds 3 pick                                   0< IF 1- 2dup 1+ - 2swap 1- -rot 1- + -rot \ copy screens      ENDIF DO i over [ (in) , ] over + over +LOOP                   ELSE drop ENDIF ENDIF 2drop ;                         -->                                                                     ( copy multiple, quit )                                  ( 43                                                                   : CY r/o 0= -EXIT scr@ p" to#"(s#)      \ --) scr to scr{#} > 0   -dup IF offset @ b/scr / + (cy) ENDIF >k ;                                                                                    : CM r/o 0= -EXIT p" from#"(s#) p" to#"(s#) p" no."(s#) (cm) ;                                                                  : CI r/o 0= -EXIT p" inst scr#" (s#)    \ insert empty screen     -dup 0= -EXIT dup dup 1+ sm @ os + over- 1+ (cm) clear ;                                                                      : CT bell >k -19 message ;              \ copy 1st to 2nd file                                                                  : (cs) cache cache-off drop -cache drop empty-buffers \ quit      dr0 screen close file close in>w 0. 2 wrst ernum fdrop 0 ;    : CS eflush (cs) ;                      \ quit & flush                                          -->                             ( programmable, line markers                                    : tib> [ 28 +origin @ ] literal tib ! (bk) blk ! ;   \ rst. i/o : >tib blk@ is (bk) tib> tib-max tib +! blk off ;    \ tmp. tib : in> (in) in ! default-is error ;      \ rst i/o ptr           : >in in @ is (in) in off ;             \ prepare interpreting                                                                  case: emk #0 ; 62 here 2dup 6- +! sdup allot erase      \ table : mk# 1+ mk + 15 and dup offset @ abs 0=/= 16* + ;   \ marker no: mk@ #0. 16 #0 DO 2drop i mk# emk dup -LEAVE LOOP -dup \ fetch   IF b/scr /mod swap c/l * is r# (l#) is mk ;S ENDIF drop ;     : mk! #0. 16 #0 DO 2drop i mk# dup emk 0= -LEAVE LOOP   \ store   scr @ b/scr * r# @ c/l / + is emk is mk ;                     : mkc #0 #-1 is mk mk# ' emk 4+ + 32 erase drop ; -->   \ clear \ pre-set markers at scr's 10, 20, .. 90:                       \ case: emk 160 320 480 640 800 960 1120 1280 1440 #0 #0 #0     \ #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 ;  ( programmable )                                        ( 45                                                                   : I> b/scr lb 2- min 0 at ;             \ "at" prog. input line : -k w#0 i> clrt csp! in off ;                                  : -eval -k interpret ;                                                                                                          : (eval) w#0 tib@ tib-max 2dup erase 2- expect -eval ;          : (er) csp! ernum fdrop -1 default-is --> w#0 in> tib> ;                                                                        : EVAL ' (eval) is error               \ evaluate keyboard input  >tib >in -k (eval) (er) ;            \ <acsF5>                                                                                : LSCR ' (er) is error                 \ <aF1>                    ' ;s is --> scr@ load (er) ;         \ load editting screen                                                           -->     \ EVAL is not reliable!                                          ( directory by prog. input acsF5 ( special tab spacing ( 46                                                                    : dir w#0 0. at 0s 0 co paper w-cls [compile] dir ;                                                                              : ptr ; if-nfound rptr             bell     5 +continue         forget ptr             also forth also definitions             : rp 0 here 1+ even rptr ;                                      : PTR in>w -1 d3w! pxenq             ( activate the pif pointer   c-key 2drop %00010010 rp %00100000 rp ernum 4drop c-key ;                             previous previous prevdef                range: tb    #0  8 16 24 32 40 48 56 ; ( standard +ve           case:  tc #0 #8 16 24 32 40 48 56 64 ; ( tab spacing             ' tb dup is (tb) cfa ' (tb) 2+ !                                ' tc dup is (tc) cfa ' (tc) 2+ !                              : bt r# @ c/l mod dup (tb) (tc) swap - (m) .f ;          -->                                                                     ( special tab spacing  ( aTAB ( lprint )               ( 47                                                                    : plmg {l 27 emit emit emit ;   \ nn -- ( left margin           : P-RCOL lmg #70 + plmg ;       : P-LCOL lmg plmg ;                                                                             : editting                                      also hidden       w#0 in-cons !chan w#0 lngbad drop $4a +origin off               decimal sysflg 1+ d0< IF drk fname" par" ENDIF                  w#0 atne in-cons >fount 0. 0. !csp wsav cpad                    c-key workfile work is-open                                     IF (loc) scr@ 0> 0= IF l# ENDIF                                 ELSE dr0 scr@ using" dup 0= + is scr ENDIF ' (ins) is (i)       sc sm @! 2 co paper 0 >scr r# c# @! cpad mss l rf               [compile] also [compile] editor hlp 2@l or -EXIT ehlp ;                                                               -->     \  in-cons is-his 0= IF 80. history ENDIF                       (      start editting)                                  ( 48                                                                    : (llist) printer o-prt         \ nn -- ( print nn screens        IF p-prt p-start dup -1 DO    \       ( start at scr@            2. DO p-on p-top i #70 * lmg + plmg                              6. DO 13 p'work sbyte p-off pl l+ p-on                           1- s->d ?esc or -dup IF d0= LEAVE ENDIF                        LOOP dup 0= -leave                                             LOOP p-pge lmg plmg dup 0= -LEAVE                              12 +LOOP p-off console                                          ENTER BEGIN key drop ENTRY ?terminal 0= UNTIL ENDIF drop ;                                                                    : LLIST                         \ print 2 cols of 6 screens/page  lmg 20 is lmg scr @ minus >scr sm @ (llist) is lmg ;  -->                                     \ key: <acsF1>                  \    6. DO pcr pcr j 0= IF pcr ENDIF p-off pl l+ p-on           ( store help text from next screen, help, end edit )                                            also also forth definitions     : HELP mss (update) off bell hlp 2@l                              d0= IF drv 1 work open                                           IF drop " flp1_fig_scr" 1 work open ENDIF                       IF drop msg 1 work open                                          IF w#0 p" - NO HELP AVAILABLE - " #200 inkey 2drop 1            ELSE drop also fp 0 previous ENDIF                             ELSE [ blk @ ] literal b/scr 2dup mod - + b/buf 0 ENDIF         0= IF u* posab drop hlp c/scr fstrg-l ENDIF                     work close w#0 cpad ;S ENDIF                                   hlp b/scr 0 DO i 0 at 2dup c/l sstrg-l c/l m+ LOOP              2drop ss off key drop ;                                                                           editor definitions          h] (update) dup @ 2>r help l ernum 2drop 1 r> r> ! ;              dup ' ehlp 2!                 previous previous -->             --> cQ ins/ovw cS split csS join  cF fetch ovf aF2 mark <--    c¾   scr{#}         a¾/¿ prev/next scr   c½/¼  del char         as¾  1st scr        as¿  last scr        cs½/¼ del word         as¼  hot get 1st    acs¼ hot get next    as½   push to hotbuf   ac¾  inst date$     ac¿  backup file     acs¾  clr pad          c¾¿  find{text}     a¾¿  find next       s½/¼  move found len   as¾¿ clr till{text} ac¾¿ find&del{text}  s¾¿   replace{text}    cF1  new 1st file   csF1 new 2nd file    sF1   toggle 1st/2nd   aF1  compile screen acF1 print screen    cF2   drop line        F2   push & delete  sF2  copy to pad     csF2  clear line       F3   spread & pop   sF3  copy from pad   csF3  spread & clr     F4   refresh scr    cF4  restore scr     acF4  store scr        sF4  append one scr csF4 truncate file   asF4  copy scr to {#}  aF4  window         F5   flush file      asF5  copy multi       aF5  inst screen    sF5  toggle update   csF5  clr scr{#}       cESC quit (acX)     aESC flush&quit (cX) csESC break (cW)     µ( editor key decoding table )                            ( 51    associative: (eky)                                              -239   -236   -238    -19    252    -09   -251   -248           -250   -244    235    024    023    -24    204    017           -245    245    010    006    228    019    201    233            193    237    205    197    199    211    179    198            246    247    250    -27    031    219   -232    000            238    239    243    236    240    242    196    232            215    234   -246    209    225    217    210    226            202    194    206    229    227    244    251    248            213    221    009    253    208    216    192    200           -235   -233   -179                                          ;                                                          -->       --> aF4 window  aF5 ins scr#  asF5 multicopy  cQ ins/ovw <--   the decoding list may be extended and configured to suit        ( ALT-keys being coded as the -ve character codes )             ( edit case-select )                                    ( 52    case: (ecs)                                                      mkc    mk!    mk@    c?     ptr    (tt)   eval   ci             cm     emov   2nd"   cs     0=     (cs)   cf     te             sv     bk     n-l    ki     rpl    sl     e-l    using"         s-l    -c     c-p    c-g    c-n    d-i    jl     del-wl         s+     s-     uo     cs     0=     bed    lscr   (cs)           -h     -e     -s     -d     -i     -r     b      ehlp           c-pad  shd    cy     l-     n      l+     l#     f              del-r  del-l  del-wr till   x      rf     clear# eflush         rs     re     c-t    c-st   c-u    c-d    c-l    c-r            llist  pl     c-w                                     -emit ; : tt 9 edi-key dup 2* ' (ecs) 4+ + @                              [ ' bt cfa ] literal = IF ' c-t ' l# ELSE ' bt ' b# ENDIF       -rot is (ecs) 210 edi-key swap is (ecs) ;             -->                                                                       -->                 ( editor keys )                    ( 53   \ aF2 set  asF2 goto marked line  acsF2 clear all                 acsF2  aF2    asF2   acS    sSP    aTAB   acsF5  aF5            asF5   aF4    csF1   cX     cW     acX    s½     cQ             acF4   cF4   <nl>    cF     s¾¿    cS     a½     cF1            a¼     cF2    as½    as¼    acs¼   ac¾    csS    sc¼            sF4    csF4   sF5    aESC   csESC  ac¿    aF1    cESC           F2     csF2   csF3   sF2    sF3    F3     s¼     F1             acs¾   sF1    asF4    a¾    s¾¿    a¿     c¾     c¾¿            c½     c¼     cs½    as¾¿   ac¾¿   F4     csF5   F5             as¾    as¿    TAB    sTAB   ¾      ¿      ¼      ½              acsF1  acF1   acsS                                  key-emit   c CTRL         s SHIFT         a ALT           <nl> ENTER      neu aTAB toggle tab      cs+ ñ csS  acsS poke acS display chars     aF4 window move      aF1 cpl screen       sSP pointer sprite                                                                 .( editor ready) cr ( editting procedure )              ( 54                                                                    ' (eky) is edi-key    ' (ecs) is edi-case    ' tt is (tt)                                                                      : EDIT ' noop is k> editting scr@ 0= IF ehlp ENDIF >prae          BEGIN csp! in>w                                                  csr key dup prae edi-key edi-case post 0= ernum -dup drop       IF in>w >k dup . message clrt 200 inkey 2drop bell 1 ENDIF     UNTIL                                                           250 edi-key ' uo is (ecs) ' >k is k>          also hidden       [compile] forth >post (update) on -1 $4a +origin !              in>w 0 co dup strip paper 7 co ink >k ;                                                                                        ' edit also also forth definitions is edit previous    -->                                                                                                                                             if-found bh     5 +continue                             : FVIEW                                    ( any file read only   250 edi-key ' noop is (ecs) default-is ltype                    (update) off 1 is oc edit                                       0 is oc ' type is ltype (update) on ;                                                                                                                 \ 56 load                                                                                                                       only forth also definitions also safe!                                                        ;s                                                                                                                                                                                                                                                                                                                                                                                                        case: lky #0 #1 #2 #3 4 5 6 7 8 9 10 11 12 13 14 15 16 185 178   179 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38    39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  80 81 83 84 85 86 87 88 89 90 91 92 39 49 59 69 79 89 99 100   101 102 193 104 105 106 107 108 109 110 111 112 113 114 115     116 117 118 119 120 121 122 123 124 125 126 169                 228 227 229 233 246 245 248 252 231 241 230 128 225 224 226 235 232 234 239 237 236 238 243 242 244 250 249 251 223 162 165  39 196 197 194 201 214 213 216 220 199 209 198 129 131 155 137 139 181 182 146 161 191 127 167 164 171 187 176 247 150 151 152 153  15 200 202 203   6 254 146  11 {p  {h  {k  {k  {\ {_  142  12  141   8 174  14 {O  221 205 206 {-  177 {c  {=   {< {=  {>  138 157 156 158 133 132 134 {F  {y  {K  {i  166 140 188 189 190 {w  8 154 144 143 145 {u 172 208 136  183 135 147 148 149 130 159 ;                                                 -->             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               lh rh  lu ru      eth     gamma                            OME pi  x  (R)SIGMA  x 221 205 206 [-] . ccedi  219 lge neq gge  . 224  .   .   .    .   . Fr                                                              wrzl -D  .  .  ...                                                                                                                                                      -->                                                                                                                             \ ¨ 168         ª 170                ­ 173         ¯ 175        \                             ´ 180                             \ ¸ 184         º 186                                           \ À 192  Á 193         Ã 195                                    \                             Ì 204                Ï 207        \ Ð 208         Ò 210  Ó 211  Ô 212                × 215        \        Ù 217  Ú 218  Û 219                Þ 222                                                                               \ ð 240  ñ 241                                                  \                                    ý 253  þ 254  ÿ 255                                                                                                                                                                                                                                                                                                                                                                                                        : (lat) drop lky dup ;                                          : >lat1 ' (lat) is prae lat1 0 >fount ;                         : >atne default-is prae atne 0 >fount ;                                                                                                                                                 ;s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      