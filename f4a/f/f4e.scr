( =================== < F4 screen editor > =================== )                     f4e@lxhp.in-berlin.de                                                                                                                 <f4e.scr>                                       f4e.scr F4 fig-style screenfile editor                          based on previously compiled figed.scr                      experimental software, not tested, no warranty                                                                                 Copyright (C) 2003 by h-peter recktenwald, Berlin          QT-License applies, re "lib4th" and "f4a" documentation files.                                                                                       Th 2003-03-13 07:10                                             Sa 2003-08-16 05:08                                             Mo 2004-01-18 06:12                                                                                       NOTE: keys vs. code values refer to the german keyboard lay-out!--> ================= < F4 screen editor > ================= <--                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                --> ================= < F4 screen editor > ================= <--                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                --> ================= < F4 screen editor > ================= <--                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                --> ERROR MESSAGES                                              EMPTY STACK                                                     DICTIONARY FULL                                                 HAS INCORRECT ADDRESS MODE                                      ISN'T UNIQUE                                                                                                                    DISC RANGE ?                                                    FULL STACK                                                      DISC ERROR !                                                                                                                                                                                                                                                                                                                                                                                                                                                    F4                                                   SEP 2, 2002--> COMPILATION ONLY, USE IN DEFINITION                         EXECUTION ONLY                                                  CONDITIONALS NOT PAIRED                                         DEFINITION NOT FINISHED                                         IN PROTECTED DICTIONARY                                         USE ONLY WHEN LOADING                                           OFF CURRENT EDITING SCREEN                                      DECLARE VOCABULARY                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              F4                                                   SEP 2, 2002( =================== : F4 screen editor > =================== )forth definitions decimal                                       if-found exit-ed if-found (ky -- ) i.e, comment till eof            warning @ 0 warning !   ( no messages        )                  0 lword !               ( prevent "lword" text evaluation )     #10 load                                                        warning !               ( rst "warning" state             )     ;S                                                                                                                              1 warning !             ( screenfile text messages        )                                                                 : (-> (vp) @ #16 b. ":B emit blk ? lword print .s [-->] ;        immediate ' (-> is -->                                         : (-> ":S emit scr ? ":B emit blk ? lword print .s [-->] ;       immediate ' (-> is -->                                         bel pad 400 dr? bchan ch-name cr type ":3: emit cr order vocs cr                                                                                                                                                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( =================== < F4 screen editor > =================== )                                                                                                                                                                                                                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( =================== < F4 screen editor > =================== )xlload !hlp     xlload vdef     xlload -compile xlload palias   xlload order    xlload vocs     xlload a-close  xlload enter-do xlload mem?     xlload debug    xlload dumpl    xlload 3+       xlload chans    xlload hlp      xlload w        xlload kbd-key  xlload pad-size xlload pad2     xlload string   xlload ch-name  xlload mkdir    xlload fflush   xlload which    xlload slist:   xlload case:    xlload range:   xlload associative:             xlload e\type   xlload cure     xlload pwd      xlload argstg   xlload tib-size xlload readml   xlload readm    xlload readmc   xlload <mdfl>   xlload [f]      xlload is@      xlload vt-chr   xlload .e"      xlload #er      xlload save'    xlload is-case  xlload ch-eof   xlload casehead-size            xlload esc?     xlload vt       xlload fname    xlload f"       xlload file>file                                                         -->                                                                    ( =================== < F4 screen editor > =================== )                                                                \ ( by lload f4ed:) xlload f4e      \ laedt figed.scr                                                                                                                                   -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     f" f4ans.scr" pad2 place                                        pad2 dup "hlp string ' "t&d' l-load drop                                                                                        if-found hlp! hlp!                                              forth                                                                                                                           : bye xy 0. csr at-xy cure empty bye ;                                                                                  -->                                                                                                                                                                                                                                                                     \  search order after <lload vdef>:                             \  context :float linux hidden forth vt elf editor              \  current :forth vt elf editor linux hidden                                                                                    xlload? [e]                                                                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ : :HIER: [_] \ ; immediate   ( while testing... )                                                                             : kk ." <esc>key.. " kbd-key 27 - -exit                           depth >r begin kbd?key 0= until                                 depth r> - dup 1 do dup [f] i - 1+ roll emit loop 2drop ;                                                                                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     --> -------------------------------------------------------- <-- edit.f8  L4 fig-style screenfile editor                         f4e.scr  F4 fig-style screenfile editor                              Copyright (C) 2003 by h-peter recktenwald, Berlin               QT-License applies, re "lib4th" documentation files.      ---------------------------------------------------------------- "f4ed" is not an ANS-4th program.                               though not un-portable, purposely, it won't easily be portable  screen display, best w/ min 132x43 width console window,        also suitable to rxvt and - probably - xterm, etc.             ---------------------------------------------------------------- sample X-window manager ("wmaker") menu entries:                "F8ED" EXEC rxvt -T "f8ed" -g 132x56 -e f8ed                    "4E"   EXEC rxvt -T "4e"   -g 132x56 -e 4 edit edit            ----------------------------------------------------------------                                                                --> -------------------------------------------------------- <-- loading and, w. 2nd call starting the editor:                                                                                   edit edit                                                       re-entering w.o. change of data or editting state by:                                                                           ed                                                              {edit} and {ed} are 'root' words, always accessible.                                                                           ----------------------------------------------------------------                                                                                                                                                                                                                                                                                                                                                                                                --> -------------------------------------------------------- <--                                                                                                                                                                                                                                                                                                                                ----------------------------------------------------------------                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                --> -------------------------------------------------------- <-- display:                                                       ================================================================ top<                                                            16 lines screenfile listing with                               <--> .. <--> left border: line#/screen, right border: line#/file 1 line status : line no, scr no, ovw/ins mode, filename         2 lines monitor: pad, top 2 lines                               1 line misc. (editor input, command stg, error msgs)           ----------------------------------------------------------------                                                                 (top of scrolling region, single display)                                                                                      ==============================================================                                                                                                                                  --> -------------------------------------------------------- <-- (other window                                                  ---------------------------------------------------------------- (top of scrolling region, double display                       ==============================================================   forth command i/o                                              ---------------------------------------------------------------- status line:                                                    [ _(d#)_(S/U):(s#)/(m#)_(I/O):(cu/ch){_M(mrk/#mrk)}_(fname)_ ] ----------------------------------------------------------------                                                                                                                                                                                                                                                                                                                                                                                                --> -------------------------------------------------------- <--status line fields:                                                                                                              d#     display no. (0 or 1)                                     S/U    "U" if the particular screen was 'update'd               s#     current screen no.                                       m#     file size by screens                                     I/O    'I'nserting/'O'verwriting input mode, rsp.               (cu    cursor column                                            ch)    character code at cursor position                        M      marker diplay visible if any markers set:                (mrk   top mrk number at current screen, else "-"               #mrk)  number of markers set                                    fname  path+name of file currently in screen                           leading part cut to fit into editor window              ------------------------------------------------------------------> -------------------------------------------------------- <--                                                                 status colours:                                                                                                                  line     black on red   write enabled                           line     black on cyan  read only                              d#        reversed video screen in 'un-do' buffer               S/U       "U:" yellow bg screen updated                                    "S:" cyan bg  any screen updated, remains                                     after by r/w forced 'flush'            I/O " O:" reversed video if overwriting                             line  yellow on cyan 'other' screen display                                                                                ----------------------------------------------------------------other colour:                                                   colourname ' colourword >body !  ( re ink! paper! and vt words  --> -------------------------------------------------------- <-- keys, console vs X-windows "rxvt"                               F1...F5    e[[A...e[[E  (console)    e[11~...e[15~  (X)         F6...F10   e[17~..e[21~                                         F11  F12   e[23~  e[24~      F11..20: <shift>F1..F10 (X)        F13  F14   e[25~  e[26~      F13..20: <shift>F1..F8 (console)   F15  F16   e[28~  e[29~                                         F17..F20   e[31~..e[34~                                         pos1,ins,del,end,pgup,pgdn  e[1~...e[6~ (console)               e[7~         e[8~                       (X, else as console)    up,dn,rgt,lft arrows       e[A...e[D                            left<ALT> (console)        <esc>       (console, X)            numeric keypad (not locked):                                      *,+,-,del,/,ins,end,pdn,cul,5,crg,cdn,ps1,cup | w doubly defd!eOj,k,m,n  ,o,p  ,q  ,s  ,t  ,u,v  ,w  ,w  ,x   | <cdn> = <pos1>----------------------------------------------------------------  --> ( ============= < F4 screen editor > ============= ( <-- )                                                                \ NOTE  that not even in the console those F.. keys do          \ always return the same sequence!                              \ e.g. F1 received as <esc>[[A (which is correct)               \ and, also as <esc>[11~ (which is X-windows mode)                                                                              \ check received chars:                                          : kk ." <esc>key.. " kbd-key 27 - -exit                           depth >r begin kbd?key 0= until ." \e"                          depth r> - dup 1 do dup [f] i - 1+ roll emit loop 2drop ;                                                                    ---------------------------------------------------------------- kbd coding re man 1 dumpkeys, loadkeys, showkey; 5 keymaps     ----------------------------------------------------------------                                                                ( =================== < F4 screen editor > =================== )root definitions                                                                                                                if-nfound \\    : \\ blk@ 1- 0< if quit endif rdrop ; immediate if-found exit-ed \\                                                                                                             : exit-ed empty ;       \ trigger forget handlers which may be  editor                  \ def'd to cleaning up channels, files..' edit defer ed         \ : ed the editor, in {root}            ' noop defer >prae      \ : >prae in {ky}, for <f4b>            ' noop defer >post      \ : >post dto.                                                                                                                                                  -->                                                                                                                                                                                                     root definitions                                                                                                                : e-vocs      forth definitions      ' linux is forth           if-found float ' float is forth      ' linux is float                          ' elf is linux       \ ' editor is elf                          ' vt is editor        ' hidden is vt                            ' assembler is hidden ' forth is assembler                      [_] forth definitions [_] editor ;                                                                               : (?) cr dup #16 b. space id. space .s cr cr ;                  : [?] latest [_] literal compile (?) [ 0 to cmc ] ; immediate                                                                                                                           -->     \ e-vocs    ( -- )                                              \   context :editor vt hidden assembler forth float linux elf   \   current :forth float linux elf editor vt hidden assembler   forth definitions                       \ uvari, ucons                                                                          if-nfound out@ out (up) - ucons out@                            if-nfound fld@ fld (up) - ucons fld@                            if-nfound scr@ scr (up) - ucons scr@                            if-nfound r#@  r#  (up) - ucons r#@                             if-nfound [p]  (p) (up) - ucons [p]                             if-nfound [i]  (i) (up) - ucons [i]                             if-nfound #tab (up) @ dup ucons #tab 4+ (up) !                                            4 to #tab     \ initial <tab> stepping                                                                                                                                                                                        -->                                                                                                                                     \ out@ : sr@ : r#@ : [p] : [i] : #tab : fld@                    root definitions decimal                                                                                                        : sh-e           ( call {sh} w. empty env. array )                -8 +origin dup dup@ 2>r                                         0 >r rp@ swap ! sh rdrop 2r> swap ! drop ;                                                                                    : ls [_] f" -dup 0= if drop exit endif pad2 place                 s" ls -lL --color " minus pad2 +place pad2 sh-e ;                                                                             : sh` "` word here sh-e ;                                                                                               -->                                                                     \ ls            ccc( -- )                                       \       list directory by stg(ccc) w/ long names                \ sh`           ccc( -- )                                       \       execute shell cmd in <` string `>                       linux definitions decimal                                                                                                       " ebadf"   #er drop           \ initiate ernum words            " ebadf"   #er constant BADF  \ after {rw!} to r/o file         " erofs"   #er constant ROFS  \ r/o file                        " eexist"  #er constant EXIST \ file/dir already exists         " enodata" #er constant NODATA \ file/dir already exists                                                                        : .message ( n -- ) 2 warning +!                                  xy max-xy 1- at-xy rot message at-xy -2 warning +! ;                                                                          if-found (fm)  NODATA is (fm) \ F4/F14 message if text not found                                                        -->                                                                                                                                     ( : BADF : ROFS : EXIST : NODATA )                              forth definitions                                                                                                               if-nfound -rot : -rot rot rot ;                                 if-nfound off  : off 0 swap ! ;                                 if-nfound 2and : 2and rot and -rot and swap ;                   if-nfound umin : umin 2dup u< 0= if swap endif drop ;                                                                           : sprint scount type ;                                                                                                                                                                  -->                                                                                                                                                                                                                                                                                                                                                                                                     forth definitions vt                                                                                                            ' cure defer [cure] \ whether called by cmd-line or in the edito' noop defer [xw]   \ clr kbd-queue if in X-windows                     0 is [xw]   \ in-active (console) is default state                                                                      : <xy> [ (xy) @ , ] [xw] ;    ' <xy> is xy                                                                                      if-nfound max-x : max-x max-xy drop ;                           if-nfound max-y : max-y max-xy sdrop ;                          if-nfound y-cur : y-cur xy sdrop ;                                                                                                                                                      -->     if-nfound row   : row xy sdrop ;                                if-nfound rows  0 variable rows            ( {cr} counts rows ) ( : [cure] : [xw] )                                             forth definitions                                                                                                               : kbd-type  ( a u -- ( type to kbd channel )                      kbd chp c@ -1 fwrite drop ;                                                                                                   if-nfound plw   c/l constant plw            ( : plw in in f4p ) : cr editor                                                       out@ max-x stdout ch-cons 0= if 2drop (col) plw endif           / 1+ (row) +! 0. (col) ! out ! cr ;                                                                                           : cls editor 0. (col) 2! vt cls ;                                                                                       -->                                                                                                                                                                                                                                                                     forth definitions                                                                                                               if-found casehead-size 2 +continue                              vhere case: otto ; vhere forget otto - dup vallot                           minus constant casehead-size                                                                                        ' update palias [upd]                                           ' update defer update                                                                                                   -->                                                                                                                                                                                                                                                                                                                                                                                                     ( : casehead-size : [upd] : update )                            forth definitions                                                                                                               : e"        \ ccc( -- )stg | ( -- ) def escaped stg to kbd-chan   [_] s" <builds here 1+ e\stg dup 1+ allot swap 1- c!            does> count kbd-type ;                                                                                                        : tib>dft [ (tb) 4+ @ ] literal (tb) @+ tib ! ! ;                                                                               : write-line <nl> fwrite ;                                      : write-file >rr -1 fwrite drop r> ch-rnum dup 1- 0< ;                                                                          vt if-nfound <ht> definitions 9 constant <ht>                                                                                                                                           -->                                                                     \ : <ht>                                                        editor definitions                                                                                                                                  \ if-found  0=/= ' 0=/= palias >f           : >>f 0=/= minus ;  \ if-found  0=/= ' 0=/= palias >>f          : >f  0= 1- ;       \ if-nfound 0=/= : >f 0= 1- ;               warning @ 0 is warning : 0=/= 0= 1- ; warning !                                                                                 if-nfound true  -1 constant true                                if-nfound false ' 0 palias false                                              0 -1 2constant 0-1    \ success flag for <esc>chrs                                                                if-nfound b/b prev @ +buf  constant b/b drop ( bytes/buf in mem)if-nfound b>b blk @ block prev @ - cons+ b>b ( disp to 1st char)                                                                                                                        -->     \ : >f : >>f : true : false : b/b : b>b : 0.1                   editor definitions                                                                                                              : work-ch work chan ;                                                                                                           dr? bchan constant scr-chan                                     : dr! dup bchan to scr-chan dr! ;   \ duplicate kernel defns    : dr0 0 editor dr! ;                \  which store to {scr-chan}: dr1 1 editor dr! ;                                            : ?dr scr-chan 1 bchan =if -1 exit endif 0 bchan = ;            : scr-id scr-chan ch-id ;                                                                                                                                                               -->                                                                                                                                     \ ?dr   ( -- flg )                                              \   ret flg -1:dr1; 1:dr0; 0: no screenfile channel open        editor definitions                  \ : scr-chan : [al]                                                                         : update-off $7fffffff prev @ and! ;                            : update? @ @ 0< ;   ( a -- flg ( tf if blk at a is 'update'd )                                                                 ' noop defer [al]                                                                                                       -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     editor definitions                                                                                                              : [re] >r dr? bchan >rr ch-id 0< if 2rdrop exit endif             0 [f] r fposre  2r> path-max >rr >loc 2>r                       l0 path-max [f] r ch-name l0 place [f] r close drop             l0 r> r> swap open fposre drop r> loc> ;                                                                                      : reading r/o [re] ;                                            : editting w/r [re] ;                                                                                                   -->                                                                                                                                     \ reading   ( -- )                                              \   re-open current screenfile in r/o mode                      \ editting   ( -- )                                             \   re-open current screenfile in w/r mode                      0 vcons+ edd                \ : edd base of ref into data field : edd@ <builds , does>@ edd @ ; \ @ at disp from data-field     : edd! <builds , does>@ edd ! ; \ ! at disp to data-field       \ alterable fg and bg colours                                   : ink!   <builds vp , v, does>v @ fg ; \ def {ink} setting      : paper! <builds vp , v, does>v @ bg ; \ def {paper} setting                                                                                                                            -->     \ ink!      (C: colour -- )(X: -- )                             \ paper!    (C: colour -- )(X: -- )                             \   define words which set fg and bg colours, rsp.              \   alerable, e.g: { colour  ' inkdefn >body ! }                : edd@ <builds , does> @ edd @ ; \ @ at disp from data-fie      : edd! <builds , does> @ edd ! ; \ ! at disp to data-field      : ink!   <builds vp , v, does> @ >v @ fg ; \ def {ink} setting  : paper! <builds vp , v, does> @ >v @ bg ; \ def {paper} settinglc-ignore                                                       ' lc-ignore palias [li] immediate                               ' lc-depend palias [ld] immediate                                                                                               \ cons & vari                                                                                                                   \ aux.                                                          0 =: [ax]  \ alarm-hnd installation flag                        0 =: [w]   \ flag whether in X-windows                          0 =: [sp]  \ stack ptr safety, in {ky}                                                                                          \ for the home directory                                        0. path-max stg $HOME                                                                                                   -->                                                                     \ : [li] : [ld] : [ax] : [w] : [sp] : $HOME                     \ editor cons/{value}s                                          -1. 2constant wdw-xy \ wdw resize ctl, initial setting          -1  =: eno       \ enable 'other', 2ndary screenfile display     0  =: shadow    \ parallel display of 2nd-ary file, if =/= 0    0  =: [sho]     \ : [sho] "shadow screen" offset                0  =: [u]       \ : [u]   flag whether 'update' pending        "_  =: [c]       \ : [c]   non-printing chars replacement                                                                        0 variable r[a] \ : r[a]  flag whether replacing 'all`                                                                                                                                 -->                                                                                                                                                                                                     \ : wdw-xy : eno : shadow                                       \ 8  =: [tab]    \ : [tab] <tab> spacing                        \ 4-chars <tab> spacing bit pattern line (c/l bytes)            1 variable [ts] [ts] c/l erase c/l 4- vallot                    : ts! [ts] c/l bounds do 1 [f] i ! 4 +loop ; ts! forget ts!                                                                     \ lines                                                         b/scr b/buf c/l */ =: l/scr  \ line per screen                  b/scr b/buf *      =: c/scr  \ chars=bytes per screen           c/scr 1-           =: max-r# \ cursor ovf mask ((2^n)-1)        c/scr 2*           =: c/epad \ 2 screens' intermediate buffer   c/epad c/l /       =: l/epad \ max #lines in epad               c/l 2*             =: c/fpad \ size of find- and replace-buffer                                                                                                                         -->                                                                                                                                     ( : l/scr : c/scr : max-r# : l/epad : c/epad : c/fpad : |c/scr )                                                                \ columns                                                       4                  =: #lmg   \ : #lmg 1st col of screenfile text6                  =: #rmg   \ : #rmg line-no field             0                  =: c-left \ : c-left left col of display wdw c/l 2+             =: c-lin  \ : c-lin line no. wrt file        #lmg c-left c-lin #rmg                                                       + + + =: c-wdt  \ : c-wdt min console window width c-wdt 1+           =: c-help \ : c-help left col of help-text   #lmg minus         =: ~#lmg  \ : ~#lmg for {.r}                 #rmg minus         =: ~#rmg  \ : ~#rmg for {.r}                                                                                                                                         -->                                                                                                                                                                                                                                                                     \ un-comment to enabling i/o pipe channels                      \ -1 =: p1   \ : p1 read-pipe channel                           \ -1 =: p2   \ : p2 write-pipe channel                                                                                          \ lines, current display & relative to bot of top wd            0   constant l-top  \ : l-top top of screenfile display         16  constant l-sta  \ : l-sta 1st status line                   17  constant l-pad  \ : l-pad top two stacked pad lines         19  constant l-cmd  \ : l-cmd command output                    20  constant l-bot  \ : l-bot bot of listing window                                                                                                                                     -->                                                                                                                                                                                                                                                                     : vt0                 ( -- ( set console top left co-ordinates )  xy 0. at-xy xy 2swap at-xy                                      dropd     to l-top    \ top of screenfile display               dup 16 +  to l-sta    \ 1st status line                         dup 17 +  to l-pad    \ top two stacked pad lines               dup 19 +  to l-cmd    \ command output                              20 +  to l-bot ;  \ bot of listing window                                                                                   -6 cons+     i-cmd    \ min. bottom lines for command i/o        0 constant  e-bot    \ max editting bot. line                                                                                if-nfound -0 0 not 1 >> not constant -0                                                                                 -->                                                                     ( : i-cmd : e-bot )                                             \ screenfile state flag masks                                   -0 constant nwf nwf not constant ~nwf \ : nwf 'new file'         1 constant sbf sbf not constant ~sbf \ : sbf 'screen buffered'  2 constant upf upf not constant ~upf \ : upf 'block updated'                                                                   \ array => 2 wd-s, <nul>-initiated                              \ extendable but, further adjustments required (below)          0    constant [e1] \ : [e1] disp to editor data table base ptrs 0    constant [e2] \ : [e2] disp to editor data table base ptrs : ed1d [e1] >v ;                                                : ed2d [e2] >v ;                                                                                                                0    constant +ebuf \ : +ebuf                                                                                           -->                                                                                                                                                                                                     0                                                               4+ ddup edd@ @top edd! !top \ : !top of screenfile display      4+ ddup edd@ @hlp edd! !hlp \ : !hlp left of help scn           4+ ddup edd@ @#ed edd! !#ed \ : !#ed display no.                4+ ddup edd@ @sta edd! !sta \ : !sta status line                4+ ddup edd@ @pad edd! !pad \ : !pad top two stacked pad lines  4+ ddup edd@ @cmd edd! !cmd \ : !cmd command line (?)           4+ ddup edd@ @bot edd! !bot \ : !bot bot of listing window      4+ ddup edd@ @scr edd! !scr \ : !scr scr no.                    4+ ddup edd@ @r#  edd! !r#  \ : !r#  cursor                     4+ ddup edd@ @cl  edd! !cl  \ : !cl  tmp line storeage                                                                  -->                                                                                                                                                                                                                                                                     4+ ddup edd@ @mxs edd! !mxs \ : !mxs scr size                   4+ ddup edd@ @sch edd! !sch \ : !sch screenfile channel         4+ ddup edd@ @ins edd! !ins \ : !ins 'insert'/'overwrite' mode  4+ ddup edd@ @flg edd! !flg \ : !flg flags: new file, scn buff'd4+ dup is +ebuf             \ : +ebuf 1 screen 'undo'-buffer    b/scr b/b * +                                                   4+ ddup edd@ @ebuf edd! !ebuf \ : !ebuf scr no. & edit-buffer   vp dup       is [e1]                                            over 4+ +    is [e2]                                            dup 4+ 2* vallot ed1d swap erase                                                                                        -->                                                                                                                                                                                                     \ buf. rfsh w/ different scr at next 'update', old content lost                                                                 0 variable epad         \ vari w. buffered lines count          vp epad ! c/epad vallot \ common editor workspace, 2 scr-s      0 variable fpad                                                 vp fpad ! c/fpad vallot \ {f}ind buffer                         0 variable rpad                                                 vp rpad ! c/fpad vallot \ eR, replace-buffer                                                                                                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                     ( : epad : fpad : rpad )                                        \ init display screen & environmental data                                                                                      : home-dir!                     \ sto HOME dir to stg-vari        " HOME" getenv to-stg $home ;                                                                                                 : e-home        ( -- )          \ editor home-dir                 $home scount 0= if home-dir! endif drop                         $home scount pad2 dup off place s" /.f4ed" pad2 +place          pad2 mkdir                                                      dup EXIST = swap 0= or 0= -exit \ no "home"-dir                 pad2 count to-stg $home ;                                                                                                                                                             -->                                                                                                                                                                                                     \        wr rd  cursor posn markers                             case: mk #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0                 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 ;                                                                31     constant mwm \ marker count wrap mask; no. of markers can                    \ be extended to any 2^n, less than 16K     mwm 1+ constant mkm \ max marker count                                                                                          : mk0=  ( -- f ( tf if no marker set ( by {e2sl} )                0 mkm 0 do [f] i mk or loop 0= >f ;                                                                                                                                                   -->                                                                                                                                                                                                     ( : mk : mwm : mkm )                                            \ marker words, 1st by {e2sl} scr #80+                                                                                          : #mk ( -- n1 n2 )   \ n2 > -1 marker# at current scr,            0. mwm 2+ 2 do     \ n1 > 0  # of markers set ( tf = -1 )        [f] i dup mk dup 0= 1- 4 pick over- -4 pick  \ #markers set     swap c/scr / scr@ = >f and and max           \ ? m# in scr     loop 2- ;                                                                                                             -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : ed0 dr0 ed1d to edd ;        \ select 1st file                : ed1 dr1 ed2d to edd ;        \ select 2nd file                                                                                : ed+ @#ed case: ed1 ed0 ; ;   \ select next/other                                                                              : ebuf +ebuf edd ;             \ screen buffer                  : -ebuf -1 !ebuf ;             \ invalidate ebuf                                                                                : cur> r#@ !r# scr@ !scr ;     \ copy cursor                                                                                                                                        -->                                                                                                                                                                                                                                                                                                                                         : frc 4+ c/fpad erase ;                                                                                                         : cepad                     \ init, clr editor- and find-buffer   0 epad !+ c/epad blanks fpad frc rpad frc pad 4- frc ;                                                                        : (sp depth [sp] - ndrop ;  \ rst safe stackptr                                                                                 : fl flush 0 to [u] ;       \ flush & clr updated screens count                                                                 : -u [u] 2- to [u] update-off ;                                                                                                 : erw?      ( -- f ) \ screen-file open-mode r/o(ff) or r/w(tf)   dr? bchan cdt <mdfl> @ 15 and 2 = ;                                                                               -->                                                                         vt definitions                                                                                                                  : cls>cml editor \ cls comand line                                c/l #rmg + 1+ 0 <# "P hold #s "[ hold #27 hold #> [type] ;                                                                                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \ console windows                                               editor definitions         \ 2nd-voc editor vt  2nd-voc vt forth                                                                \ console colour correction                                     : e-pal [w] -exit 200 200 0 yellow palette ;                                                                                    \ (alterable) colours                                                                                                           blue paper!   d-p           \ : d-p screen display              white  ink!   d-i           \ : d-i                             red  paper!   c-p           \ : c-p cursor                                                                          -->                                                                                                                                         \ modify colour at run-time (re F5 editor command)              \ for instance:         black ' d-p >body !                     \ status line                                                                                                                   red     ink!  s-i        \ : s-i   ink if open r/o              cyan  paper!  s-p        \ : s-p   status paper                 black   ink!  s-ii       \ : s-ii  inactive screen, r/o, ink    cyan  paper!  s-pi       \ : s-pi  inactive status, r/o, paper                                                                  \ status line, r/w                                              black   ink!   s-wi     \ : s-wi  r/w, ink                      red     paper! s-wp     \ : s-wp  r/w, paper                    white   ink!   s-wii    \ : s-wii inactive screen, r/w, ink     magenta paper! s-wpi    \ : s-wpi inactive screen, r/w, paper                                                                                                                           -->                                                                                                                                                                                                     green paper! p-p        \ : p-p pad                             red ink!     p-i        \ : p-i                                                                                                 green paper! n-p        \ : n-p linum                           black ink!   n-i        \ : n-i                                                                                                 black paper! a-p        \ : a-p date+time by <alarm>            cyan ink!    a-i        \ : a-i                                                                                                 : s-colr                \ status line                             normal erw? if s-wp s-wi exit endif s-p s-i ;                 : s-icolr               \ in-active window status line            normal erw? if s-wpi s-wii exit endif s-p s-ii ;                                                                  -->                                                                                                                                         : p-colr                \ pad lines                               normal p-p p-i ;                                                                                                              : n-colr                \ line numbers                            bold n-p n-i ;                                                                                                                : d-colr                \ screen display                          normal d-p d-i ;                                                                                                              : c-papr   ( -- n )     \ cursor backg'd, ret prev. 'paper'       [p] c-p ;                                                                                                         -->                                                                                                                                                                                                                                                                         : i-colr                \ defaults                                normal                \ attrib                                  white fg              \ text                                    black bg ;            \ background                                                                                            : e2xx  ( -- tf )       \ set X-windows/console flag, cons [w]    true " DISPLAY" getenv 1/string 0dup                            if [number] sdrop sdrop 0= endif to [w] ;                                                                                         -->                                                                                                                                                                                                                                                                                                                                                                                         \ error handler redir                                                                                                           : 4-ec revd cure             \ re-enable console cursor           [ (abort) @ ] literal is [abort] ;                                                                                            : [ac] sp! rp! revd cure is< [cure]                               .e" \n\t<ed> re-enters the editor\n" [ (abort) @ , ] ;        : e-ec ' [ac] is [abort] 0 is [cure] ;                                                                                          ' 4-ec defer {ec}               \ : {ec} editor forget handler  forget: {ec} e-ec                                                                                                       -->                                                                                                                                                                                                                                                                     \ system, error handler redir, console/x-windows determination                                                                  : y/n .e"  [Y]\e[m[no] "                                          kbd-key associative: "y "Y "j "J #10 ; ;                                                                                      3 constant [-y]                 \ : [-y]   top 'yes' index      4 constant [-ynl]               \ : [-ynl] 'yes' and <enter>    5 constant [+ynl]               \ : [+ynl] negative response                                                                                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                     ( == backup screen-file =============================== : bup )                                                                 \ bup           ( -- )      forth                               \   backup/copy file to supplied path+name or directory.        \   preferrably by linux "cp --backup=t", falling back to       \   overwriting transfer w/ {file>file} if "cp" not executeable \   or returning an error, and permitted by issued query.       \   adds source basename if stg ends with "/",                  \   stores to editor-home if just filename given.               \   names should include no blanks!                                                                                             hidden definitions                                              0. 4096 stg bupcmd                                                                                                      -->                                                                     \ : bupcmd                                                      forth definitions                                                                                                               : bup    ( -- )                                                   s" cp --backup=t " to-stg bupcmd              editor            pad2 pad-size 2dup erase scr-chan ch-name                       2dup +to-stg bupcmd s"  " +to-stg bupcmd                        pad2 place s" .bk" pad2 +place                                  pad2 count over + off dup path-max                              reve cure edlin curd revd [cure]                                zcount -trailing bl skip 2dup pad2 place                        2dup +to-stg bupcmd                                             "/ rscan sdrop 1- -dup                                                                                                   -->                                                                                                                                                                                                                                                                    if                                                               0< if $HOME scount sdrop                                         if bupcmd scount pad2 count sdrop - to-stg bupcmd                $HOME scount +to-stg bupcmd                                     s" /" +to-stg bupcmd pad2 count +to-stg bupcmd                 endif                                                          endif                                                          else                                                             pad2 pad-size scr-chan ch-name                                  "/ rscan 1/string +to-stg bupcmd                               endif                                                           .e" \n\e[K" bupcmd scount pad2 e\stg bupcmd place               bupcmd sh dup 1- 0< 0= if drop exit endif message                                                                     -->                                                                                                                                       bupcmd bl rscan bl skip pad2 place            \ destn fname     .e" \n<sh> executeable not found\n"                             .e" \e[7mcopy overwriting\e[27m to:" pad2 print                 y/n [-y] > -exit                                                pad2 w/r cre new-chan open dup 0> if                             >rr scr-chan swap 0. $7fffffff file>file r> close drop          dup 0> if . ." bytes sent to " pad2 print exit endif           endif message ;                                                                                                                                                                       -->                                                                                                                                                                                                                                                                                                                                     editor definitions                  \ editor screen setup                                                                       \ scrolling region  ( -- )                                      : 4-scr cur! 0 max-y csr cur@ ;     \ full screen                                                                               : e-scr e-bot max-y csr vt@state ;  \ i/o window                                                                                : (eh) ed0 i-colr 4-scr ;                                       if-nfound [eh] ' (eh) defer [eh]                                               ' (eh)    is [eh]                                forget: [eh] e-scr                  \ rst forth colours & scr                                                                                                                           -->                                                                                                                                     \ : [eh]                                                        \ editting wds' bottom line                                                                                                     : set-bot 0 edd ed1d to edd @bot ed2d to edd @bot                 @mxs -1 > >f and 2dup max to e-bot rot to edd = -exit e-scr ;                                                                 \ clear screen                                                  : i-cls i-colr revd cls vt@state ;       \ i/o display                                                                          : e-cls max-x e-bot 1- at-xy cls>cur vt@state ; \ listing displa                                                                : CLS 0 vt@state e-bot at-xy cls>eos ;      \ i/o display, home : -cls e-bot y-cur [xw] < -exit CLS ;                                                                                   -->                                                                                                                                                                                                     editor definitions                                                                                                              : e-attrib                      \ sto window attibutes            0 max-y [xw] at-xy vt!state ;                                                                                                 : 4>pmt hex ' .s is (ok) ;      \ prompt                                                                                        : e-set  ( -- )                 \ adjust if wdw sizes changed     set-bot                       \ editor bottom line              i-colr ;                      \ default colours                                                                               : w-set                                                           max-xy 2dup wdw-xy d- or 0= -rot to wdw-xy -exit e-set ;                                                                                                                              -->                                                                                                                                     : l2-set ( -- )                 \ actual 2nd display lines        1 eno                                                           if drop max-y i-cmd l-bot 2* 1- min l-bot - l-top max endif     ed1                                                             dup l-top + !top              \ top of screenfile display       dup l-sta + !sta              \ 1st status line                 dup l-pad + !pad              \ top two stacked pad lines       dup l-cmd + !cmd              \ command output                      l-bot + !bot              \ bot of listing window           @scr 0max !scr                                                  @mxs -1 max !mxs                                                @r# 0max !r# ;                                                                                                        -->                                                                                                                                                                                                     : l2-unset      ( -- )          \ un-assign 2nd-ary display       ed1 -1 !mxs -1 !scr -1 !r# ;                                                                                                  : (ld 0= -exit scr@ !scr r#@ !r# ;      ( flg -- )              : ld) @scr dup !scr scr ! @r# r# ! ;    \ scr-size                                                                              : l1d                                   \ activate 1st display    ?dr 0< (ld ed0 ld) ;                                                                                                          : l2d                                   \ activate 2nd display    ?dr 0> (ld ed1 @mxs 0< if l2-set endif ld) ;                                                                          -->                                                                                                                                                                                                                                                                     \ leaving the editor                                            \ revert to standard {bye} after orderly return from editting                                                                   : eby                           \ rst screen at exit              4-scr i-colr cls 0 [ ' bbi is@ drop cfa , ] ;                                                                                 : f>bye is< bbi ;      ( -- )   \ rst {bye} to system word      : e>bye ' eby is bbi ; ( -- )   \ redirect {bye}                                                                                ' f>bye defer fby                                               forget: fby e>bye               \ 'emergency handler'                                                                   -->                                                                                                                                                                                                                                                                     \ file, i/o                                                                                                                     \ redirectable display, dft to non-escaping {type}, {emit}      ' [type]  defer (e-type)        \ editor {type}                 ' [emit]  defer (e-emit)        \ editor {emit}                                                                                 : d-defer                       \ init dft to display-only        ' [type] is type                                                ' [type] is (e-type) ' [emit] is (e-emit) ;                                                                                   : p-defer ;             \ printing mode                         : s-defer ;             \ simultaneously printing & displaying                                                          -->                                                                                                                                                                                                     : e-emit        ( c -- )        \ emit printable                  key>char 0= if drop [c] endif (e-emit) ;                                                                                      : e-type        ( p u -- )      \ type printable                  2dup printing? >r drop 2dup <lf> scan sdrop 0= r> and           if (e-type) else              \ entire stg else by chars        -dup if 0 do c@+ e-emit loop endif drop endif ;                                                                       -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           if-found scr-eof 3 +continue      ( from mod. figed.scr ) : scr-eof       ( -- flg )                                        scr-chan flen dup ermax u< 0= -exit   ( ernum, no channel )     #locate scr@ b/scr * + c/l * + < 0= ; ( 0|1 )                                                                                                                                         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : scr-error?    ( -- flg )      \ 0< if scr-chan not valid        scr-chan ch-rnum dup 0< -exit drop scr-chan ch-opn 1- ;                                                                       : scr-size      ( -- )          \ set @mxs to no. of screens      scr-id 0< -exit scr-chan flen dup ermax u<                      if dup |c/scr - c/scr / 0max !mxs endif drop ;                                                                                : e-file?       ( -- f )        \ flg =/= 0 if scr-file NOT open  0 scr-chan fposre ermax u< scr-chan cons? or 0= ;                                                                     -->                                                                                                                                                                                                                                                                                                                                                                                                                     ( -- ) \ flush, clr updt count, close scr-chan  : (fe scr-id 1- 0= -exit fl scr-chan close drop ;                                                                               : q                             \ flush, close, quit editor       vt@state is< [cure] cure ed1 (fe ed0 (fe 4-scr                  0 to e-bot i-cls e-cls cls ;                                                                                                                                                          -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : inis          ( -- )                                            e-home                                                          ed2d is edd vt0 dr? dr1 -1    \ dr1 mxs =: -1                   2 0 do                                                           l-top !top l-top !hlp l-sta !sta                                l-pad !pad l-cmd !cmd l-bot !bot                                dup !mxs dup !scr dup !r#                                       [f] i !#ed scr-chan !sch 1 !ins                                 ed1d is edd                                                     dr0 0=                                                         loop drop dr!                                                   @bot is e-bot -1 !ebuf cepad ;                                                                                        -->                                                                                                                                     \ listing                                                                                                                       \ cursor                                                        : cur0 #lmg 1+ c-left + @top #locate ; ( -- x0 y0 xcur ycur )   : ecur cur0 d+ ; ( -- x y )     \ xy-cur.pos                    : e2ccur                        \ display char at cursor          ecur at-xy #locate line + c@ e-emit ;                         : e-ccur d-colr e2ccur ;        \ clear cursor marker           : e-cur c-papr e2ccur bg ;      \ mark cursor                   : e-lcur d-colr  ( -- )         \ display cursor line & cursor    cur0 sdrop dup line >r + at-xy r> c/l [type] e-cur ;                                                                                                                                  -->                                                                                                                                     note: d+ in {ecur} substitutes { rot + rot rot + swap }                                                                         \ pad, top two lines                                            : e2pad         ( -- )          \ display top two lines from pad  epad @+ 0max 2 min 2 over- -rot                                 -dup if 0 do                                                      epad @ [f] i - ~#lmg .r                                         dup c/l [type] #rmg spaces cr c/l +                           loop endif drop                                                 -dup 0= -exit                                                   0 do #lmg c/l + #rmg + spaces cr loop ;                                                                                       : e-pad 0 @pad at-xy p-colr e2pad ;     ( -- )                                                                          -->                                                                                                                                                                                                                                                                     : .scr-name     ( -- )                    \ display scrfile name  pad2 path-max scr-chan ch-name c/l #lmg + out @ - >r            enter begin "/ skip "/ scan entry dup [f] r < until             rdrop [type] ;                                                                                                                : e2s# scr@ @ebuf = rev out off  \ rev if scr already buffered    ?dr 0> 1+ ~#lmg .r revd ;     \ display#                                                                                      : e2su prev update? dup [u] or to [u]     \ "U"pdated/"S"creen    if [p] black bg ." U:" bg exit endif                            [p] [u] if cyan bg endif ." S:" bg ;                                                                                                                                                  -->                                                                                                                                     \ status line                                                                                                                   : e2sc scr@ @mxs 0 <# #s drop "/ hold # #s #>   \ current/mx scr  type @ins if ."  I:" else <rev> ."  O:" <rev> endif ;                                                                         : e2cc r#@ c/l mod #lag drop c@ 0       \ col-no"/"charcode       <# bl hold # # # drop "/ hold # # #> type ;                                                                                   : e2sm mk0= 0= if ." M:" #mk dup 0<     \ other, else current sc  if drop ." - " else 1+ . bs ." /" endif . endif ;                                                                                                                                     -->                                                                                                                                                                                                                                                                                                                                     : e2sl  ( -- ( display status line ( in: 'e-sl', 'xwd', 'sl' )    e2s# e2su e2sc e2cc    \ "U"pdt/"S"cr current"/"max col/chr   \ dsp# upd  scr# col/char                                         e2sm .scr-name c/l #lmg #rmg + + out @ - spaces ;             \ mark                                                                                                                          : e-sl 0 @sta at-xy s-colr e2sl ;       ( -- ( in: '>u', 'm' )                                                                                                                          -->                                                                                                                                                                                                       scr@ @ebuf = rev out off  \ rev if scr already buffered         e2s# e2su e2sc e2cc \ "U"pdt/"S"cr current"/"max col/chr                                                                      \ screen listing                                                                                                                : sl? scr@ 0max @mxs min dup !scr scr ! scr-error?                dup if scr-size drop scr-error? endif \ retry if irregular opn  dup BADF = erw? 0= - and dup 0= -exit \ no ro-err after {clear  -cls true                                                      .e" \n\t\tscr-file i/o error\n\t\ttry L+, RL or E-FILE cmd\n" ;                                                                : slcl #lead e-type c-papr  ( l c -- l c s )                      #lag over c@ e-emit 1/string rot bg e-type scr@ ;                                                                                                                                                                                                     -->                                                                                                                                                                                                                                                                     : sl            ( -- )      \ in: 'l', 'o'      \ list            sl? -exit                                                       w-set #locate sdrop c-left @top at-xy         \ .. -- l         l/scr 0 do                                    \ .. -- l          n-colr   [f] i dup ~#lmg .r                  \ .. -- l i        d-colr   2dup -                                                 if scr@ 2dup (line) e-type                   \ .. -- l i s      else slcl endif                                                 n-colr l/scr * + ~#rmg .r cr                 \ .. -- l         loop drop                                                       s-colr e2sl cr p-colr e2pad                                     [al] vt@state e-attrib ;                      \ rst cursor                                                            -->                                                                                                                                     \ 2nd-ary display                                                                                                               : xwd   ( -- )                  \ adapt display size              @sch ch-id 0< if e-cls exit endif                               0 @sta at-xy s-icolr e2sl ;                                                                                                   : xdr   ( -- )                  \ toggle editting wdw             ?dr 0> if l2d else l1d endif scr-size ;                                                                                                                                               -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : xdf           ( -- )          \ 'other' is current, dft to prv  scr-id 1+ 0> -exit            \ ? file open                     1 dr? - bchan cdt dr? bchan cdt   \ copy channel description    [ 1 cdt 0 cdt - ] literal cmove ; \ from prev to new current                                                                  : o             ( -- )          \ 'other' display, tog 1st & 2nd  xwd xdr xdf                   \ determine display parameters    scr-size                      \ files' no. of scr-s             vt@state e-set sl ;           \ set new bottom, list screen                                                                                                                           -->                                                                                                                                                                                                                                                                                                                                     : l 0 edd 0= if inis endif      ( -- )                            shadow if [xw] scr@ [sho] ?dr +- +                              r#@ xdr r# ! scr ! cur> sl xwd xdr endif sl ;                                                                                 : l# scr ! cur> l ;             ( n -- ) \ list screen #n                                                                       : rl @scr                       ( -- ) \ re-fetch & list scr@     limit first do                       \ clr screen @scr blocks   dup [f] i @ $3fffffff and b/scr / = if $3fffffff [f] i ! endif  [ b/buf 8+ ] literal +loop drop -ebuf l ;                                                                                                                                                                                                             -->                                                                                                                                     \ help-screens                                                                                                                  0 constant (hx                  \ help text selection                                                                           0  constant c-ehs               \ min width for help-screen     54 constant #hlpc               \ line width for help display                                                                                                                           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ : (hx : c-ehs : #hlpc                                                                                                         0. c/l b/scr * dup 0. rot stg hlpc 2* stg hlpt                                                                                  : xx hlpc enter begin + 1+ entry scount -dup 0= until ;         : zz blk@ b/scr + b/scr / b/scr * b/scr bounds  forth             do i block c/l -trailing xx place loop ;                                                                                       zz forget xx                                                                              b/scr 2* blk@ b/scr mod - +continue                                                                  \ NOTE: keys vs code values wrt german keyboard                                                                                                                                                                                                                                                                                                                                                  F1   other   F6   file    F11  to scr#   F16  copy              F2   >pad    F7   join    F12  c>pad     F17  pdrop             F3   <pad    F8   split   F13  c<pad     F18  ldrop             F4   ftext   F9   nxt M   F14  fnext     F19  prv M             F5   command F10  set M   F15  clear     F20  clr M             pos1 sol     end  eol     ins  ins/ovw   del  r>del             ^A   set tb  e^A  clr tb  e^B  cpl+xit   eB   bup.seq           ^B   backup  ^D   <date   e^H  help4th   eC   char#             ^E   erase   ^F   flush   e^I  l<tab     eD   del>txt           ^H   l<del   ^K   compare e^J  <nl>up    eI   <import           ^L   refresh ^R   reload  e^N  no Mark   eL   lft wrd           ^S   +/-sync ^T   top     e^Q  fls+xit   eM   hostnam           ^U   +/-updt ^W   r/w     e^S  ins mty   eR   replace                        eW   nxwrd   e^T  resize    eS   sh cmd            e+   dft tab e-   no tabs e^_  fls+bye   eU   buf/rst           ^\   abort                e<esc> leave   e#   line#                                                                            : .hl   ( a -- )                                                  xy dup #16 + max-y < minus and 2>r                              enter begin + dup c@ 0= +                                       entry                                                            scount 2dup type 2r> -dup if 1+ else max-y cr endif             2>rr at-xy -dup 0=                                             until 2rdrop drop ;                                                                                                                                                                                                                                                                                                   -->                                                                                                                                                                                                     \ -----------------------------------------------------------|54                                                                : hx            ( row -- )     \ display help-text at <row>..     max-x 56 - swap xy 2swap at-xy .e" \e[s\e[?7l\e[K"              curd (hx .hl .e" \e[?7h" [cure] vt@state at-xy ;                                                                              : h-io y-cur [xw] hx ;                                          : h-le @hlp hx ;                                                                                                                : (le hlpc is (hx ;   (le      \ dft to command line editting                                                                   : e-help        ( -- )         \ display line-editor help-screen  c-ehs c-help + max-x > if h-io exit endif h-le ;                                                                                                                                      -->                                                                                                                                                                                                     : efile     ( p u ~f -- p' u' | xx 0 ( ~f = 0 enables file creat  >r -trailing bl skip              \ w.o. lead-/trailing blanks  pad place pad scount dup if       \ -- u, save input stg @pad    pad2 path-max 2swap $home scount path? \ -- bf,fil,p+f f        0= if 2drop                      \ -- buf() fil()                fname -dup [f] r or             \ -- p+f uflg | p 0             0= if drop pad count 2dup pad2 place \ requested filename        .e" \n\t\t:" [type] bold ." : create?"                          y/n [-ynl] <                   \ -- f                                                                              -->                                                                     \ efile     ( p u ~flg -- p' u' | xx 0 )                        \   find filename(p,u) in editor-home, PATH or, CWD;            \   create if name(p,u) not found; ret path+file(p',u').        \   leading & trailing blanks stripped off name(p,u) parameter.                                                                      if                                                               pad2 w/r cre new-chan open dup 0>     \ -- ch er                if                                                               >r pad path-max [f] r ch-name        \ -- fil(p1,u1)            2dup + c/scr 2dup blanks                                        [f] r -1 fwrite r> close 2drop       \ -- fil(p1,u1)           else message 0. endif                 \ -- 0 0                 else 0. endif                          \ -- 0 0                endif                                   \ -- p u | p 0         else 2swap 2drop 2swap 2drop endif       \ -- x 0              endif rdrop [cure] ;                      \ -- fil() | x 0                                                                                                                            -->                                                                                                                                                                                                     : "efile        ( -- p u ( input screenfil-name to pad )          -cls pad path-max scr-chan ch-name + off   \ asciz, dft input   (fe pad c@ scr-chan ch-id 0< 1- and  \ tf=1\ flsh & clo scr-ch  if .e" file closed\n\t\t:" reve pad sprint revd cr endif        ." f8ed home:" reve $home sprint revd                           .e" \ncwd  is  :" reve pwd revd                                 .e" \n[] or screen-file name\n\t\t\a:"                          pad dup path-max 2dup erase                                     argc if 0 argstg else s" f4edh.scr" endif pad 1- place          reve cure edlin curd revd zcount ;    \ -- stg(p,u)|(x,0)                                                                                                                             -->                                                                                                                                                                                                                                                                     : .efile        ( -- ( adjust new screen-file display parm )      scr-id 0<                                                       if -2 message 0 to shadow ?dr                                     0< if e-cls l2-unset cls o e-help endif                       else                                                             here path-max scr-chan ch-name                                  .e" \n\t\t:\e[7m" [type] revd cr                                scr-chan 0< if l2-set endif scr-size                            @flg nwf or ~sbf and !flg -ebuf                                endif cr e-set [cure] ;                                                                                                                                                               -->                                                                                                                                                                                                                                                                     : e-file        ( -- )                                            "efile 0 efile >rr here place r>                                if empty-buffers here using endif .efile ;                                                                                    : using" e-file? 0= if endif                                      [_] f" here place here using                                    dr? bchan ch-opn 0= -exit .efile ed ;                                                                                 -->                                                                                                                                     \ e-file    ( -- )                                              \   close old & open/create new file for editting               \   files searching: $home/.f8ed, cwd, {path}                   \ using"    ( ccc, -- )                                         \   find file ccc in F4 PATH and open for editting, elso noop.                                                                  s" \a\n\t\e[7mwindow too small for "                pad2 place  s" the editting screen\e[27m\n\n\a"                 pad2 +place pad2 scount dup stg w-txt                                                                                                       s" \n\tenter\t'ed'\t\tscreen editor\n\tor\n\t\t"    pad2 place  s" 'e-help'\tshort glossary\n\t\t'e-file' or "      pad2 +place string ` '" (filename)" using' new file`     scount pad2 +place s" \n\t\t'q'\t\tclose & flush, leave editor\n\t\t"  pad2 +place s" 'bye'\t\tquit the program\n\n\n\n"               pad2 +place pad2 scount dup stg i-txt                                                                                               -->                                                                                                                                                                                                                                                                                                                                     : e-txt         ( -- )          \ initial message                 max-xy at-xy                                                    max-x c-wdt < if w-txt scount [etype] endif                     i-txt scount [etype] cup ;                                                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : v-ini         ( -- )                                            0 edd 0= if inis endif                                          tib>dft  \ in case of invocation by {evaluate} from r/o memory  e>bye                         \ redirect {bye}                  e-ec                          \ {error} and {abort}           if-found opi opi                \ open pipes                      (le                           \ command-line ed. helptext       e-set                         \ display sizes & colours         i-colr e-attrib e-pal         \ colours                         magenta e2xx if drop white endif                                ' s-wi >body !                \ status line r/w, ink            home-dir!                     \ get editor-home                 e-home    ;                   \ test/create editor home dir                                                           -->                                                                                                                                     : e-ini                                                           v-ini                         \ init cons & vari                e-cls                         \ clr display "window"            i-cls                         \ clr i/o "window"                e-vocs                        \ editting search order           e-txt                         \ sign on                         e-file? if e-file endif       \ check/request file              scr-error? 0= if l cepad endif \ 1st listing, cld editor pad    scr-size                      \ initial screenfile size         e-help                        \ short glossary                  4>pmt decimal                 \ prompt w/ stack display         scr-id 1+ if ed endif ;       \ enter the editor                                                                                                                                      -->                                                                     \ editting                                                      editor definitions lc-depend                                                                                                    : >u scr@ @ebuf = -exit ( -- )  \ buffer scr before 1st 'update'  ebuf b>b scr@ dup !ebuf b/scr * dup b/scr + swap                do [f] i block over c/l cmove b/b + loop drop e-sl vt@state ;                                                                                                                         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : >pad          ( -- )          \ push pad to epad                pad c@ c/l - -exit            \ exit if not a 'line'            epad dup@ 1+ l/epad min over !                                  4+ dup c/l + c/epad c/l - move                                  pad 1+ epad 4+ c/l move ;                                                                                                     : pad>          ( -- )          \ pop epad to pad, noop if empty  epad dup@ 1- 0max over !                                        4+ dup dup pad c/l over c! 1+ c/l move                          c/l + swap c/epad c/l - move ;                                                                                                : epad;         ( n -- n | )    \ early exit if epad empty        epad @ -exit rdrop ;                                                                                                  -->                                                                     hidden definitions  \ = F4: alarm mit "." SCHEITERT in segv = \                                                                 : t&d "t&d 3 - here place here count ;                                                                                          : {al}              editor      \ '.time&date' by alarm sighnd    revd xy [p] [i]                                                 t&d max-x over- #rmg - l-cmd 1- at-xy                           a-p a-i [type] fg bg ( to [i] to [p] vt@state ) at-xy ;                                                                       ' {al} is [al]                                                                                                          -->                                                                                                                                                                                                                                                                     ( [al] hld-bereich direkt vor pad wird ueberschrieben - warum? )editor definitions              \ better useable 'find' variant:                    if-found N -->                              context 2@ hidden definitions                                   : r#+ r# @ + c/scr /mod scr +! r# ! ;       context 2!                                                                          : N         ( -- )                                                -2 fld and! 0                 \ clr flag                        enter begin                                                      #lag pad count match r#+ >f ( 0=/=) dup fld or!                entry scr-eof or                                                until r# @ !r# scr@ !scr                                        fld@ 1 and -exit NODATA .message ;                                                                                            -->                                                                                                                                                                                             editor definitions \ cursor posn, lines/screen rfsh                                                                             : cmd> vt@state e-cur ;  \ mark cursor                          : cmc> e-lcur cmd> ;     \ repeat cursor line                   : pmc> e-pad  cmc> ;     \ rfsh pad display, clr intermed text  : cms> cmd> l ;          \ mark cursor & repeat screen listing                                                                  : >cmd e-ccur vt@state ; \ clr curs                             : >cmc dup !cl >cmd ;  \ sto line arg, >cmd; {d},{h},{i},{r},{e}: >cmu >u >cmc ;                                                                                                                                                                        -->                                                                                                                                                                                                                                                                     \ add pad opr and screen listing to editor commands                                                                             : d >cmu D >pad e-pad cms> ;       \ F2  : drop, push to pad    : h >cmc H >pad e-pad cmd> ;       \ F12 : copy, push to pad    : i epad; >cmu pad> I e-pad cms> ; \ F3  : inst, pop from pad   : r epad; >cmu pad> R e-pad cmc> ; \ F13 : replace, pop from pad: t >cmc T >pad e-pad cmd> ;       \ type and push to pad                                                                       \ add screen listing to editor commands                         : c >cmu C cmc> ;                  \ inst text at cur           : e >cmu E cmc> ;                  \ blank line                 : f >cmd 1 text FIND cur> cms> ;   \ find text                  : n >cmd FIND cur> cms> ;          \ find next                                                                          -->     : n >cmd N cur> cms> ;             \ find next                                                                                  \ cursor                                                                                                                        : b >cmd B cmd> ;       ( -- )  \ back by text-len in pad       : m                ( curs -- )  \ +/- curs, prev/next scr         e-ccur r#@ + scr@ dup !scr c/scr * + 0max                       c/scr /mod dup @scr - -rot scr ! r# !                           cur> e-cur e-sl vt@state 0= -exit l ;                         : 0m    0   m ;         ( -- )  \ rfsh curs & status line       : +m    1   m ;         ( -- )  \ col right & status            : -m   -1   m ;         ( -- )  \ col left & status             : ml  c/l * m ;         ( -- )  \ move cursor by n lines        : ml+ c/l   m ;         ( -- )  \ line down & status            : ml- [ c/l minus ] literal m ;    ( -- ) \ line up             : top >cmd 0 !cl r#@ abs minus m ; ( -- ) \ curs to top left                                                            -->                                                                     \ screen                                                                                                                        : l+ c/scr m ;                   \ list next screen             : l- [ c/scr minus ] literal m ; \ list previous screen                                                                         : p >cmu P cms> ;   \ n -- ) replace line # w/ text from input  : s >cmu S cms> ;   \ n -- ) insert blank line at #             : x >cmu X cms> ;   \ del next occurrence of text in current scr: delete >u DELETE cmc> ; \ n -- ) del backwards # chars        : till >cmu TILL cms> ;     \ del until beginning of text       : truncate                  \ n -- ) resize file to end of scr #  >cmd TRUNCATE cmd> scr-size l ;                               : u prev update?            \ toggle 'update', show status line   if -u else update endif 0m ;                                                                                          -->                                                                     \ 4th pad                                                                                                                       : 1text >cmd 1 text ;           \ text from input stream to pad                                                                 root definitions decimal                                        : man            editor         \ get manual page                 >pad 1text s" LC_ALL=C man  " minus pad +place                  xy sr# 0. csr pad sh drop csr at-xy [xw] pad> ;               editor definitions decimal                                                                                              -->                                                                                                                                                                                                     \ man           ccc( -- )                           forth       \   display manual page by arguments stg <ccc> to linux "man"   \ by external shell w/ "LC_ALL=C man ccc".                                                                                      : (ms) ( n -- n )  \ copy/clear, can extend file if beyond eof    dup @mxs 2dup >  \ -- n n m f                                   if over TRUNCATE endif max !mxs ;                                                                                             : clear ( n -- )   \ clear scr #                                  @mxs 1+ over (ms) swap 2dup >                                   if do [f] i CLEAR loop else 2drop endif CLEAR scr-size l ;                                                                    : copy             \ copy scr #1 to #2, clr & xtd if required     COPY scr-size l ;                                                                                                                                                                     -->                                                                                                                                                                                                     \ screen editor                                                 lc-ignore                                                                                                                       \ yet missing:                                                  \   cF    fetch ovf                                             \   cs><  del word                                              \   acF1  print screen                                                                                                          : x_x drop ascii . ;            \ invalid, code ovf                                                                                                                                     -->                                                                                                                                                                                                                                                                                                                                                                                                     ' noop defer csky             \ : csky <csi> + sing             ' noop defer ctl              \ : ctrl ctrl-s 0..31             ' noop defer ectl             \ : ectl <esc>ctl                 ' noop defer eky              \ : eky  basic key-code table     ' noop defer esky             \ : esky 1st <esc> list           ' noop defer 2cs              \ : 2cs  <csi> + double or more   ' noop defer 1es              \ : 1es  single ctrls             ' noop defer 2es  \ ( .. -- n flg ) : 2es <esc>aped <esc>ctrls  ' noop defer psk              \ : psk seqs which send parameters' noop defer prk              \ : prk seqs which receive paramet                                                                                                                        -->                                                                                                                                                                                                     \ remaining keys                                                                                                                \ vt no-op                                                      : nop1ky kbd-key 0 ;    \ ( -- c 0 ) discard next & ret         : utfky  0 nop1ky ;     \ unicode charset switching             : nopseq                \ ( c -- ) discard until terminal char    >r begin kbd?key 0= swap [f] r = or until rdrop ;             : nopky  0 nopseq ;     \ ( c -- ) discard all pending          : nopky1 0 1 nopky ;    \ ( c -- 0 tf ) discard all pending     : nop]ky #7 nopseq ;    \ xterm text sequence                   : nop\ky "\ nopseq ;    \ dev ctrl, privacy msgs, app. prog. cmd                                                                                                                        -->                                                                                                                                                                                                                                                                                                                             -->                                                                     : e-xx  ( -- tf )   \ adapt kbd response to console or X, rsp.    e2xx [w] 0= -exit >>f ' nopky is [xw] ;                                                                                                                                               -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ (commonly used)                                                                                                               \ e[1~                                                          : sol           ( -- )          \ curs to start of line           0and r#@ c/l mod minus m ;                                                                                                    \ e[4~                                                          : eol           ( -- )          \ curs to end of line             0and c/l r#@ over mod - 1- m ;                                                                                                : cJ sol ml+ ;  ( -- )          \ new line                                                                                                                                              -->                                                                                                                                                                                                     \ sing key actions                                                                                                              : Y             ( p u -- )      \ insert text at cursor           #lag 4 ndup 2swap sdrop rot rot 2 pick -                        0 2over + sdrop swap move 2drop swap cmove 0 m update ;                                                                       : -emit         ( chr -- ff )   \ ovw/ins printing chars          <lf> =if 0 cJ exit endif >u @ins                                if here c! here 1 Y cmc> else #lead + c! update endif \ ins/ov  +m 0 ;                                                                                                                        : #emit #case emit l ;          \ direct vt ctrl ^N & ^O (G1/G0)                                                                                                                        -->                                                                                                                                                                                                     : -del              \ ( -- ff ) 127, del @cursor                  >u @ins if +m 1 delete            \ ins/ovw                     else bl prev @ r#@ + c! endif 0. m update ;                                                                                   : -bs -m -del ;     \ ( -- ff ) ^H, curs left, blank, curs lft                                                                  : ldel drop -bs ;   \ ( xx -- ff ) <127> '<=' del left                                                                          \ function keys                                                 : #cp           ( -- n ) \ file ptr at cursor                     scr@ c/scr u* r#@ [f] m+ drop ;                                                                                       -->                                                                                                                                                                                                     \ function keys                                                 : mk#           ( -- )  \ advance idx to next unset posn; {mk+}   mkm -1 enter-do 0 mk 1+ mwm and 0 is-case mk \ next posn to se  entry 0 mk 2+ mk 0= -leave loop ;           \ exit if un-set                                                                  : @mk           ( -- n ) \ fetch next marker                      0 mkm 0 do                                                      drop 1 mk dup 1+ mwm and 1 is-case mk 2+ mk dup -leave loop ;                                                                 : mk!           ( n -- ) \ sto posn at marker to scr & r#, list   -dup 0= -exit 0 c/scr u/mod scr ! r# ! l ;                                                                            -->                                                                                                                                     : F19 <mk -1 ; : F20 mk- -1 ; : F10 mk+ true ; : F9 >mk true ;    zurck         lschen        neu              voran                                                                          : mk+           ( -- )  \ set marker                              mk# #cp 0 mk 2+ 1 IF is-case mk ENDIF ;                                                                                       : mk-           ( -- )  \ clr marker                              #cp mkm 0 do @mk over = -leave loop                             drop 1 mk 1+ mk 0= -exit 0 1 mk 1+ 1 IF is-case mk ENDIF ;                                                                    : >mk @mk mk! ;         \ ( -- ) goto next marker                                                                               : <mk           ( -- )  \ goto prev marker                        0 mkm 0 do                                                       drop 1 mk 1- mwm and dup 1 is-case mk 2+ mk dup -leave         loop mk! ;                                                                                                            -->                                                                                                                                     : #line r#@ c/l / ; ( -- n ) \ line # in screen                                                                                 : (c        ( -- x0 y0 x y )  \ introducing opr on text in pad    >pad xy #lmg @cmd 2dup at-xy ;                                : c)        ( x y -- tf )     \ trailer after xec on text in pad  pad> pmc> revd at-xy true ;                                                                                                   : [i        ( -- x y   \ cmd line input, ret escaped text to pad  >r (c c/l spaces at-xy ": emit                                  pad r> over and! scount c/l > if 0 over ! endif c/fpad 4-       over swap cure reve edlin revd curd                             zcount here e\stg pad place ;         \ enable escaped input                                                          -->                                                                                                                                                                                                     : (i  0 [i ; ( -- x y \ cmd line text input, escaped text to pad: (e -1 [i ; ( -- x y \ cmd line text input, w. default txt @pad                                                                : (#            ( -- x y n )    \ cmd line numeric input          (i -1 dpl ! pad scount                                          dup 1- 0= if over c@ "- = if 2drop -1 exit endif endif          0= if drop -1 exit endif              \ empty stg             if-found -flt  [_] -flt >rr 0= if [_] int endif                   forth base@ >r decimal 1- [number] r> base !                  if-found -flt r> 0= if [_] flt endif    \ rst state of f.p. i/o   0= sdrop minus and ;                  \ 0 if not a number                                                                                                                             -->                                                                                                                                                                                                     : <0>              \ ret after "":0, "-":max, "<num>":num         pad c@ 0= 1- and @mxs umin ;                                                                                                  : ("               \ cmd-line leading chars (max 3)               >r (c 0 over at-xy r> emit 2drop c) drop ;                                                                                    : >ins  ( p u -- ) \ ovw/ins string at curs                       >u @ins 0= if dup delete endif Y cmc> pad> ;                                                                                  \ e[[A, e[11~      \ ( -- tf ) toggle display                   : F1 o true ;                                                                                                           -->                                                                                                                                                                                                                                                                                                                                     \ e[[B, e[12~           \ ( -- tf ) drop, push to pad           : F2 #line d true ;                                                                                                             \ e[[C, e[13~           \ ( -- tf )                             : F3 editor \ pop from pad & inst; spread & clr line if epad mty  #line epad @ 0> if i else s endif true ;                                                                                      \ e[[D, e[14~           \ ( -- tf )                             : F4 fld off \ enter '\e'scape-able text to {pad} & find in file  fpad count pad place "dnf (" (i pad count fpad place n c) ;                                                           -->                                                                                                                                                                                                                                                                     \ e[[E, e[15~                                                   : F5     \ command input                                          "dmc (" (i pad count -trailing pad2 dup off place c)            pad2 dup c@ if cr evaluate vt@state [cure] ?stack exit endif    drop ;                                                                                                                        \ e[17~                                                         : F6 e-file true ; \ close (and open new) file                                                                                                                                          -->                                                                     \ F17: e[31~ F18: e[32~                                                                                                                                                                                                                                                                                                         \ e[18~     join at cursor w/ next line                         : F7 >u                                                           [ c/l minus dup minus ] literal |loc                            #lag l0 place                                                   #line [ l/scr 1- ] literal <                                    if scr@ l/scr * #line + 1+ block c/l l0 +place endif            l0 count                                                        enter begin                                                       bl readm -dup                                                   if 0 do c@+ -emit drop loop bl -emit drop endif drop          entry dup 0= until                                              2drop #lag blanks update l cmc> true literal |loc ;                                                                   -->                                                                                                                                                                                                     \ e[19~ split line at cursor                                    : F8 editor                                                       >u #line H #line I #lag blanks cmc> \ clr rmg chrs of 1st line  ml+ #lead blanks cmc> true ;                                                                                                                 -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \ e[20~                                                         : F9  >mk true ; \ goto next marker                                                                                             \ e[21~                                                         : F10 mk+ true ; \ set marker                                                                                                   \ e[23~ goto scr#, -ve for last scr                             : F11 ">== (" (# <0> -rot c) swap l# ;                                                                                          \ e[24~                                                         : F12 #line h true ;                     \ copy, push to pad                                                            -->                                                                                                                                                                                                                                                                     \ e[25~                                                         : F13 #line r true ;                     \ replace, pop from pad                                                                : fld.      ( -- n ( display fld@/2, ret len of displayed string  fld@ 2/ 0 <# ": hold #s ": hold bl hold #> sover type ;                                                                       \ e[26~  find next occurrence of text in {pad}                  : F14                                                             ":dnf (" (c c/l fpad count 2dup pad place dup -rot              reve [type] revd - -rot xy 2swap  \ txt to find @cmd-lin        at-xy n at-xy fld@ 1 and 2* fld +! fld. - spaces c) l ;                                                                                                                                                                                               -->                                                                                                                                     \ e[28~ clear scr#, current if empty input; can extend the file : F15 "rlc (" (# dup 0< if >u drop scr@ endif clear c) ;                                                                                                                                -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ by F16 & <esc>^S                                              \ copy count n3 screens from scr# n1 to scr# n2,                \ from < to: start at (from+count-1) w/ descending scr-numbers. \ from > to: start at from w/ ascending scr-numbers.            : cys ( n1 n2 n3 -- )                                             over @mxs > if over clear endif \ clr last+1 till 1st past eof  >r 2dup >                                                       if r> 0 do 2dup [ld] copy [li] 1 1 d+ loop                      else [f] r + swap [f] r + swap                                   r> 0 do 1 1 d- 2dup [ld] copy [li] loop                        endif 2drop ;                                                                                                                 : isc scr@ dup @mxs over- 1+ over 1+ swap cys clear ;                                                                   -->                                                                                                                                     \ e[29~  copy multiple: from#1, to#2, count#3                   \ noop if count < 1, e.g. after empty num-entry.                : F16   \ copy scr#1, current if -ve, to scr#2                    "mrf (" (# -rot c) drop  dup 0< if drop scr@ endif              ">ot (" (# -rot c) -rot  dup 0< if 2drop exit endif                                           \ xit after false input           "mun (" (# -rot c) drop 3dup 1- 0< -rot = or                    if 3drop exit endif           \ zero count or same ranges       cys ;                                                                                                                 -->                                                                                                                                                                                                                                                                                                                                                                                                     \ e[31~ drop line from editor-pad to pad                        : F17 pad> l true ;                                                                                                             \ e[32~ remove line                                             : F18 >pad #line [ld] D [li] F17 ;                                                                                              \ e[33~ goto prev. marker                                       : F19 <mk true ;                                                                                                                \ e[34~ clr marker                                              : F20 mk- true ;                                                                                                                                                                        -->                                                                                                                                                                                                     : -ml 1 ml- ;   ( -- tf )       \ cur to prev row               : +ml 1 ml+ ;   ( -- tf )       \ cur to next row               : -m  1  -m ;   ( -- tf )       \ cur to prev col               : +m  1  +m ;   ( -- tf )       \ cur to next col                                                                                                                                       -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ cursor & other <csi> ctrls                                    \ e[1~                                                          : pos1 sol 0and ;               \ 1: curs to 1st col of line    \ e[2~                                                          : ins                           \ 2: toggle insert/overwrite      0and @ins 0= !ins 0m ;                                        \ e[3~                                                          : rdel drop -del ;              \ 3: del right                  \ e[4~                                                          : endl eol 0and ;               \ 4: curs to last col of line   \ e[5~                                                          : pg-up l- ;                    \ 5: next pg                    \ e[6~                                                          : pg-dn l+ ;                    \ 6: previous pg                                                                        -->                                                                                                                                     \ <esc>#, goto #line, same column, "-" eof, "" 1st              : li# 0 "#sl (" (# pad c@ 0= 1- and -rot c)                       swap l/scr @mxs over * + 1- umin                                c/l c/scr */mod swap r#@ c/l mod + r# ! scr ! l ;                                                                             \ <esc>C, ins char by #                                         : ch# 0 "#hc (" (# -rot c) drop -emit ;                                                                                         \ <esc>U, buffer scr/rst curs line                              : eu scr@ @ebuf = if                                              r#@ dup c/l mod minus r# +!                                     ebuf b>b #line b/b * + c/l Y r# ! cmc>                          else >u endif 0. ;                                                                                                    -->                                                                                                                                     : .dun #lmg @cmd at-xy cls>cml bel                                ".nud (" 0-1 fld@ 0> 0= -exit fld. drop ;                                                                                     : rpl0 .dun cmc> 2rdrop ;   \ leave {rpl} word                                                                                  : rpl1              \ replace & advance cursor by text length     update fpad count delete drop rpad count                        sover Y rpad count sdrop max m ;                                                                                              : rpl2 1 r[a] ! rpl1 ;                                                                                                          : -rpa kbd chan ?input 0dup drop >uc ddup                         if nopky endif \e = swap "S = or 0= r[a] and! r[a] @ ;                                                                -->                                                                                                                                     : (u prev update? 0= if >u endif [u] 2+ to [u] [upd] ;          ' (u is update                                                                                                                  : ?rsc      \ {rrpl}, ret key <esc>,"Q,"S:0 "R:1 "A:2 other:3     -rpa -dup -exit (c 0-1 2and at-xy cls>cml                       fpad count reve [type]                                          .e" \e[27m <= \e[7m" rpad count type revd                       fld@ 0> if fld. drop endif                                      .e" \e[27m ?\e[7m[R]\e[27meplace \e[7m[A]\e[27mll "             .e" \e[7m[S]\e[27mtop \e[7m[]\e[27mcontinue"                    kbd-key associative: #27 #27 "Q "q "S "s  "R "r "A "a ; nopky   2/ 2- -rot cls>cml c) drop ;                                                                                          -->                                                                                                                                                                                                     \ <esc>^R, find & replace w/ previous strings                   : rrpl  ( -- tf )                                                 true r[a] off fld off         \ clr termination flag for "A     enter begin                                                      ?rsc case: rpl0 rpl1 rpl2 nopky ; cmc>                         entry                                                            scr@ >r                                                         >cmd fpad count pad place    \ ?f                               n fld@ 1 and dup 2* fld +!   \ 1 if found                       scr@ r> - if fl endif        \ flush if on different scr        cur> cms>                                                      0= until nopky .dun ;                                                                                                                                                                 -->                                                                                                                                     \ <esc>R, flush, find & replace/delete                          : rpl                                                             fpad count c/fpad 4- min pad place                              "dnf (" (i pad count fpad place c) drop                         "lpr (" (i pad count rpad dup off place c)                      drop rrpl ;                                                                                                           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ <esc>M goto marker#                                           : ims                                                             "#M (" (# -rot c) drop 0max #mk drop min 1+ mk mk! 0-1 ;                                                                      \ <esc>D, del till text on cursor line                          : til                                                             0 "lit (" (i #lead + 1line 0= if drop c) exit endif             #lead + swap - [ld] DELETE [li] c) ;                                                                                                                                                  -->                                                                                                                                                                                                                                                                                                                                                                                                     \ begin <esc>I, import file, screenfile or by lines             : iff       ( -- )                                                0 erw? 0= if (c 2drop ROFS message c) exit endif \ r/o screen   ":ni (" (i pad count true efile here place       \ -- c f1 f2   here r/o work-ch >rr open -rot c) swap           \ 0 -1 ch      r> = -exit (c 2drop rot message c) ;             \ open-err                                                                                                                           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : ifc   ( -- ) ( copy external into screenfile )                  >u @ins >r 0 !ins                                               enter begin                                                      <nl> =if #lag sover blanks update m                             else key>char 0= if drop bl endif -emit drop endif             r# @ 0= if isc endif                                            entry work-ch >rr ?input 0= esc? or r> ch-eof or until          r> !ins ;                                                                                                                     \ <esc>I, import file, screenfile or by lines                   : ift iff ifc work-ch close drop ;                                                                                      -->                                                                                                                                                                                                                                                                     \ <esc>L, back to begining of preceding word                    : mbt                                                             #lead -dup 0= if -1 or m #lead endif                            2dup blbl rskip -dup 0= if over endif dup minus m sdrop -       blbl rscan -dup 0= if #lead sdrop 1+ endif minus m 0-1 ;                                                                      \ <esc>S, xec shell command                                     : scm 0 ">hs (" (i vt@state cure pad sh drop curd c) cms> ;                                                                     \ <esc>W, move curs right to before next word                   : mtw                                                             #lag drop c/scr r#@ - 2dup bl scan bl skip sdrop - m 0-1 ;                                                            -->                                                                                                                                                                                                     \ <esc>-, clear all tabulators                                  : 0tab [ts] c/l erase 0 true ;                                                                                                  \ <esc>+, dft tabs                                              : 1tab 0tab #tab 0= if 8 to #tab endif                            #tab [ts] c/l 0 do 1 over c! over + over +loop                  drop 0and true ;                                                                                                      -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ sequential file backup                                                                                                        : [w0 pad 0 work-ch write-line ;   ( -- u|er ) \ insert <nl>                                                                                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : [wm ( -- )   \ modifier words in converted file                 depth >r [w0                                                    s" ' \ is -->" work-ch >rr write-line                           s" ' drop is load" r write-line                                 s" : ;s state@ if compile exit else [_] \\ endif ; immediate"   r write-line [w0                                                s" .(  {-->}, {load} and {;s} re-defined) cr" r write-line      s" .(  ========================================) cr"            r> write-line [w0                                               depth r> - ndrop ;                                                                                                                                                                    -->                                                                                                                                                                                                                                                                     : [ws   ( n -- )                \ send source screen no.          s" ( scr#" work-ch >rr write-file 2drop                         0 <# ") hold bl hold #s #> r> write-line drop ;                                                                               : [wl   ( flg blk c/l -- f' blk' ( write line, discard mty lines  dup2 -trailing 2dup 0= swap c@ 0= or dup                        if 4 pick if 3drop exit endif endif                             -3 pick work-ch write-line drop ;                                                                                                                                                     -->                                                                                                                                                                                                                                                                                                                                                                                                     : s>s   ( n -- )            \ sequential mode send current        0 @mxs 1+ rot do          \ screenfile beginning at scr# n       [f] i [ws b/scr 0 do [f] i [f] j (line) [wl c/l + loop drop     scr-chan ch-eof -leave   \ prevent err if file incomplete      loop drop ;                                                                                                                   : seq   ( -- 0 1 )          \ <esc>B, backup as sequential file   0 "qes (" (i pad w/r cre work-ch open                           dup 0< if space message c) exit endif                           "ts1 (" (# -rot c) dropd 0< if drop scr@ endif                  [wm s>s c) drop ;                                                                                                     -->                                                                                                                                                                                                     \ 2nd key selection                                                                                                             \          0 "1   "2  "3   "4   "5    "6    "7,X "8,X           case: ccky 0 pos1 ins rdel endl pg-up pg-dn pos1 endl 0 ;       \            [    ...   console   ...    ]                      : curky  ( c -- 1 )             \ cursor F-keys w. trailing '~'   kbd-key "~ =/= if nopky exit endif ccky 1 ;                                                                                   : f~ky   ( #case -- c f | 0 0 ) \ cursor F-keys w. trailing '~'   kbd-key dup "~ -                                                if sdrop kbd-key "~ =/= exit endif \ ( -- c f )                 drop ccky -1. ;                    \ ( -- x tf )                                                                                                                                      -->                                                                                                                                                                                                     : f0ky  ( -- f )        \ console F1..F5                          kbd-key associative: "A "B "C "D "E ;                                          case: F1 F2 F3 F4 F5 rdrop ; ;                                                                                 : f1ky 1 f~ky -exit     \ ins; X F1..F8,   console F6..F8         associative: "1 "2 "3 "4 "5 "7 "8 "9 ;                                 case: F1 F2 F3 F4 F5 F6 F7 F8 0= ; ;                                                                                                                                           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                     : f2ky 2 f~ky -exit     \ X & console F9..F16                     associative: "0 "1  "3  "4  "5  "6  "8  "9 ;                           case: F9 F10 F11 F12 F13 F14 F15 F16 0= ; ;                                                                            : f3ky 3 f~ky -exit     \ X & console F17..F20                    associative: "1  "2  "3  "4 ;                                          case: F17 F18 F19 F20 0= ; ;                                                                                           : #curky #case curky ;                                                                                                  -->                                                                                                                                                                                                                                                                                                                                                                                                     : csiky 0 kbd-key                                                 associative: "[ "1 "2 "3 "4 "5 "6 "7 "8 "A "B "C "D "P ;        case: f0ky f1ky f2ky f3ky #curky #curky #curky #curky #curky          -ml +ml +m -m ims nopky ; ;                                                                                             ' csiky is csky                                                                                                         -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ filter noops and multi-char escapes, execute sings w/ <esky>  : e2k           ( .x. c -- ... )                                  drop kbd-key 2es dup 1- 0=                                      if 0and dup exit endif       \ <esc>+ctrl-char, leaves #case                                 \ if not a lo ctrl, else xit ok    key>char 0dup >f and >uc                                       associative: "[ "# "U "C "R "M "I  "L "W  "%  "S "D "B "- "+ ;  case: csky li# eu  ch# rpl ims ift mbt mtw utfky scm til seq     0tab 1tab nopky1 ; drop ;                                     ' e2k is esky                                                                                                                                                                           -->                                                                                                                                                                                                     \ 1st key, set by dft case:-list, deferred to {1es}:            \ ^B, ^D,^E,^F,^G,^H,^I,^J, ^L, ^R,^S,^T,^U, ^W, <esc>          \ cannot use: ^C,^Z                                                                                                             : @tab #lead sdrop [ts] 2dup + ;                                                                                                \ ^A, set tabulator                                             : +tab 1 @tab -rot 2drop c! ;           ( -- )                                                                                                                                          -->                                                                                                                                                                                                                                                                     \ @tab  ( -- n1 a2 a3 )                                         \   cursor column n1, tab spacing table a2, table at curpos a3                                                                  \ backup/copy, numbered backup/copy by shell command (cp...)    \ adds source basename if destn ends with "/"                   : cB  "kcb (" (c 2drop bup c) drop ;    ( -- )                                                                                  \ ^D, inst date+time                                            : cD >pad t&d >ins ;                    ( -- )                                                                                  \ ^E, erase cursor line                                         : cE #line e ;                          ( -- )                                                                                  \ ^F, flush                                                     : cF fl 0m ;                            ( -- )                                                                                                                                          -->                                                                                                                                     \ ^G, bell                                                                                                                      \ ^H, delete to the left                                                                                                        \ ^I hor. tab                                                   : cI @tab 1+ begin c@+ until 1- swap - swap - m ;       ( -- )                                                                  \ ^J, curs to start of next line                                                                                                                                                        -->                                                                                                                                                                                                                                                                                                                                                                                                     \ ^K, compare current w. other display/screenfile by lines,     \ beginning at the rsp. cursor line                             : cK xdr scr-chan xdr ch-id 0< -exit            ( -- )            #lead sdrop minus m                                             enter                                                            begin ml+ xdr ml+ xdr                                          entry                                                            scr-chan ch-eof >r #lead drop c/l xdr                           scr-chan ch-eof >r #lead drop c/l xdr                           s= 2r> or or                                                   until ;                                                                                                               -->                                                                                                                                                                                                                                                                     \ ^L, rfsh screen display                                       : cL i-cls e-cls e-help -cls                    ( -- )            scr-id 0> if l endif [cure]                                     ?dr 0< if                                                        ed0 scr-id ed1                                                  0> if scr-id o 0> if o exit endif exit endif                    e-attrib exit                                                  endif ed1 scr-id ed0 2- 0< -exit o o ;                                                                                                                                                -->                                                                     \ ^M    new line                                                \ ^N    view w. g1 charset                                      \ ^O    view w. g0 charset                                      \ ^P    -frei-                                                                                                                  \ ^Q, flush, exit, leave channels open but r/o                  : cQ fl ed1 reading ed0 reading vt@state -cls -1. ;                                                                             \ ^R, rfsh display screen                                                                                                       \ ^S, sync 2nd & 1st display w.  offset #, for "shadow screens": cS shadow dup 0= to shadow -exit                                "sfo (" (# dup 1+ 0= 1- and to [sho] c) drop o o ;                                                                    -->     \ ^T, curs to top left                                          \ : top ...                                                                                                                     \ ^U, toggle 'update' state                                     \ : u ...                                                                                                                                                                                       \ toggle r/o and r/w mode, ask whether flushing                 : cW    ( -- )                                                    erw? if                                                          (c .e" \e[7mflush?" y/n -rot at-xy cls>cml -rot c) drop         [+ynl] < if fl endif reading                                   else editting endif 0m ;                                                                                                                                                              -->                                                                     \ ^V    -frei-                                                  \ ^X    -frei-                                                  \ ^Y    -frei-                                                  \ ^Z    linux (puts job into background)                                                                                                                                                        \ 1e    ( c -- f ) tf exits                                     \ <esc>(0..31) 2nd-ary ctrls by {2es} or, vt-sequence.          \        0^ES  1^A    2^B   3^C   4^D   5^E   6^F   7^G         \                   backup (sys) date  erase flush klingel      case: 1e 0=  +tab      cB   >f   cD    cE    cF   bel           \        8^H     9^I 10^J 11^K 12^L 13^M  14^N   15^O           \        del-lft tab  nl  comp rfsh line+ G1-chr G0-chr                  -bs     cI   cJ   cK   cL  ml+   #emit  #emit          \        16^P  17^Q  18^R  19^S  20^T    21^U    22^V  23^W     \              xit   rfsh shadow topleft +/-updt      r/w|o              >f      cQ   rl     cS  top      u      >f     cW      \        24^X  25^Y  26^Z   27    28     29      30,^^ 31,^_    \                         <esc>chr                                       >f    >f    >f    2es  >f      >f      >f    >f   ;    ' 1e is 1es                                             -->                     ( 0=/= replaces w. >f )                                                                                         : (ct 0 swap 1es ;              \ {ctrl} lo ctrls 0..31         ' (ct is ctl                   \ 1st level call, by case:-list                                                                  \ <esc>^A (1), clear tabulator                                  : -tab 0 @tab -rot 2drop c! 1or ;                                                                                       -->                                                                                                                                     \ <esc>key,                                                     \   all w/ stack flow ( c -- x true ), exit if -1 @nos          \   2nd-ary <esc>s, redirectable by user supplied case:-list    \   to deferred {2es}. default list defines:                    \       ^B, ^D, ^G,^H,^I,^J, ^N, ^Q, ^S,^T, <esc>, ^_           \   cannot use: ^C,^Z                                                                                                                                                                           \ <esc>^B (2), compile current line and exit                    : -cpl 0-1 cure depth >r here pad over- erase                     #lag here place here evaluate depth r> - ndrop [xw] ;                                                                         \ <esc>^G (7), nothing useful, just noise...                                                                                    \ <esc>^H (8), get help to a forth word                         : -help                                                           "drw (" (i pad c@ if vt@state -cls cr pad [help] endif c) ;                                                                   \ <esc>^I (9), backward hor. tab                                : btab @r# #tab mod dup 0= >f #tab and or minus m 1or ;                                                                 -->                                                                     : btab @r# [tab] mod dup 0= >f [tab] and or minus m 1or ;                                                                       \ <esc>^J (10), curs to start of previous line                  : +nl sol ml- 1or ;                                                                                                             \ <esc>^N (14), clear all markers                               : mk0 mkm 2+ 0 do 0 [f] i is-case mk loop 1or ;                                                                                 : e<esc> cL -cls cure vt@state >f -1. 2rdrop ;                  \ <esc>^Q (17), flush screenfiles, reset display, back to 4th   : -q q e<esc> ;                                                                                                                 \ <esc>^S (19), insert empty screen                             : iss isc 0 true ;                                                                                                      -->                                                                                                                                                                                                     \ e^T (20) truncate/extend at end of scr# (current if empty inpu: -trnc                                                           "nrt (" (# dup 0< if drop scr@ endif                            truncate [p] [i] e-pad fg bg c) ;                                                                                             \ <esc><esc> (27) exit editor w/o {flush}                                                                                       \ <esc>^_ (31), flush screenfiles, reset display, quit program  : efbye q bye ;                                                                                                                                                                         -->                                                                                                                                                                                                                                                                     \ after leading <esc> char, by df'd {2es} checked 1st in {e2k}  \ ( xx c -- tf|ff ) done if tf(1), else(>1) ext'd vt sequence   \       0^ES 1^A   2^B   3^C   4^D   5^E   6^F   7^G    \       case: 2e 0=  -tab  -cpl  >f    >f    >f    >f    bel            \       8^H  9^I   10^J  11^K  12^L  13^M  14^N  15^O   \       \          tab-bk nl/up                   clr-mk        \              -help btab  +nl   >f    >f    >f    mk0   >f             \      16^P  17^Q  18^R  19^S  20^T  21^U  22^V  23^W   \       \            quit  repl  insmty trunc                   \              >f     -q   rrpl   iss  -trnc >f    >f    >f             \      24^X  25^Y  26^Z  27    28    29    30,^^ 31,^_  \       \                        quit                    fls+xit\              >f    >f    >f    e<esc> >f   >f    >f    efbye                 #case ;                                                  ' 2e is 2es         \ stack: -1 -1 0 2es -- -1 0                                                                        -->     \ filter ctrls, emit printable chars                            \ 1: ctrl 2:esky 3:ctrl 4:emit 5:del 6:csi 7:emit 0,8:non-printg\         0    1   2    3    4    5    6    7     8     9       range: rky   #0   27   28   32   127  128  155   156   256 ;    case: kky x_x ctl esky ctl -emit ldel -emit csky -emit x_x ;    ' kky is eky                                                                                                                                                                            -->                                                                                                                                                                                                                                                                                                                                                                                                     \ eky   ( n1 n2 -- flg )                                        \  editor input key character code n1, words' group n2                                                                          : (ky                           \ editting loop                   e-attrib begin (sp kbd-key dup rky eky until 4-ec ?stack ;                                                                    : ky                            \ editor                          tib>dft 1 depth to [sp] e-ec curd ' noop is [cure]              (le e-help >prae (ky (le >post                                  e-help (sp drop 4-ec is< [cure] cure ;                                                                                        ' ky is ed                      \ the editor                    ' e-ini is edit                 \ prepare & enter the editor                                                                    \  .e" \n\n\tenter the editor w/ 'edit'\n\n"                                                                            ;S                                                                                                                                      -- ---------------------------------------------------------- --range: rky   #0   27   28   32   127  128  155   156   256 ;    case: kky x_x ctl esky ctl -emit ldel -emit csky -emit x_x ;           `-eky    |   |    |                     `-{csiky}                        |   `-{e2k} filter multi-char escapes,                          |        |  filter noops, execute sings                         |        |                                                      `--------`-{1es} in {(ct}, sing ctrls                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           